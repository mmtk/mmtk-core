<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>NoGC - MMTk User Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="The guide describes the usage of MMTk for GC and language runtime developers.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../assets/css/api-migration-details.css">
        <link rel="stylesheet" href="../../assets/css/mdbook-admonish.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MMTk User Guide</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/mmtk/mmtk-core/tree/master/docs/userguide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/mmtk/mmtk-core/edit/master/docs/userguide/src/portingguide/howto/nogc.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="starting-a-port-nogc"><a class="header" href="#starting-a-port-nogc">Starting a Port: NoGC</a></h1>
<p>We always start a port with NoGC. It is the simplest possible plan: it simply allocates memory and never collects.
Although this appears trivial, depending on the complexity of the runtime and how well factored (or not) its internal GC interfaces are, just getting this working may be a major undertaking.
In the case of V8, the refactoring within V8 required to get a simple NoGC plan working was substantial, touching over 100 files. So itâ€™s a good idea not to underestimate the difficulty of a NoGC port!</p>
<p>At a high level, in order to implement NoGC, we need to handle MMTk initialization, mutator initialization, and memory allocation.</p>
<p>If you're ever stuck at any point, feel free to send a message in the <code>#Porting</code> channel of our <a href="https://mmtk.zulipchat.com/">Zulip</a>!</p>
<h2 id="set-up"><a class="header" href="#set-up">Set up</a></h2>
<p>You want to set up the binding repository/directory structure before starting the port. For the sake of the tutorial guide we assume you have a directory structure similar to the one below. Note that such a directory structure is not a requirement<sup class="footnote-reference"><a href="#1">1</a></sup> but a recommendation. We assume you are using some form of version control system (such as <code>git</code> or <code>mercurial</code>) in this guide.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>In fact some bindings may not be able to have such a directory structure due to the build tools used by the runtime.</p>
</div>
<ul>
<li><code>mmtk-X/mmtk</code>: The MMTk side of the binding. This includes the implementation of <a href="https://docs.mmtk.io/api/mmtk/vm/trait.VMBinding.html">the <code>VMBinding</code> trait</a>,
and any necessary Rust code to integrate MMTk with the VM code (e.g. exposing MMTk functions to native, allowing up-calls from the MMTk binding to the runtime, etc).
To start with, you can copy <a href="https://github.com/mmtk/mmtk-core/tree/master/docs/dummyvm">the <code>DummyVM</code></a> code and start from there.
<code>DummyVM</code> provides all the Rust boilerplates that you need to implement in the binding side.
You can also take a look at one of our officially maintained language bindings as an example: <a href="https://github.com/mmtk/mmtk-openjdk/tree/master/mmtk">OpenJDK</a>,
<a href="https://github.com/mmtk/mmtk-jikesrvm/tree/master/mmtk">JikesRVM</a>, <a href="https://github.com/mmtk/mmtk-v8/tree/master/mmtk">V8</a>, <a href="https://github.com/mmtk/mmtk-julia/tree/master/mmtk">Julia</a>,
<a href="https://github.com/mmtk/mmtk-v8/tree/master/mmtk">V8</a>.</li>
<li><code>mmtk-X/X</code>: Runtime-specific code for integrating with MMTk. This should act as a bridge between the generic GC interface offered by the runtime and the MMTk side of the binding. This is implemented in the runtime's implementation language. Often this will be one of C or C++.</li>
<li>You can place your runtime repository at any path. For the sake of this guide, we assume you will place the runtime repo as a sibling of the binding repo. You can also clone <code>mmtk-core</code> to a local path. Using a local repo of <code>mmtk-core</code> can be beneficial to your development in case you need to make certain changes to the core (though this is unlikely).</li>
</ul>
<p>Your working directory may look like this (assuming your runtime is named as <code>X</code>):</p>
<pre><code>Your working directory/
â”œâ”€ mmtk-X/
â”‚  â”œâ”€ X/
â”‚  â””â”€ mmtk/
â”œâ”€ X/
â””â”€ mmtk-core/ (optional)
</code></pre>
<p>You may also find it helpful to take inspiration from the <a href="https://github.com/mmtk/mmtk-openjdk">OpenJDK binding</a>, particularly for a more complete example of the relevant <code>Cargo.toml</code> files.</p>
<p>For this guide, we will assume your runtime is implemented in C or C++ as they are the most common implementation languages. However note that your runtime does not <em>need</em> to be implemented in C/C++ to work with MMTk.</p>
<h2 id="adding-a-rust-library-to-the-runtime"><a class="header" href="#adding-a-rust-library-to-the-runtime">Adding a Rust library to the runtime</a></h2>
<p>We recommend learning the ins and outs of your runtime's build system. You should try and add a simple Rust "hello world" library to your runtime's code and build system to investigate how easy it will be to add MMTk. Unfortunately this step is highly dependent on the runtime build system. We recommend taking a look at what other bindings do, but keep in mind that no two runtime build systems are the same even if they are using the same build tools.</p>
<p>In case the build system is too complex and you want get to hacking, a quick and dirty way to add MMTk could be to build a static and/or dynamic binary for MMTk and link it to the runtime directly, manually building new binaries as necessary, like so:</p>
<ol>
<li><code>cd mmtk-X/mmtk</code></li>
<li><code>cargo build</code> to build in debug mode or add <code>--release</code> for release mode</li>
<li>Copy the shared or static<sup class="footnote-reference"><a href="#2">2</a></sup> library from <code>target/debug</code> or <code>target/release</code> to your desired location</li>
</ol>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>You would have to change the <code>crate-type</code> in <code>mmtk-X/mmtk/Cargo.toml</code> from <code>cdylib</code> to <code>staticlib</code> to build a static library.</p>
</div>
<p>Later, you can edit the runtime build process to build MMTk at the same time automatically.</p>
<p><strong>Note:</strong> If the runtime you are targeting already links some Rust FFI libraries, then you may notice "multiple definition" linker errors for Rust stdlib functions. Unfortunately this is a current limitation of Rust FFI wherein all symbols are bundled together in the final C lib which will cause multiple definitions errors when two or more Rust FFI libraries are linked together. There is ongoing work to stabilize the Rust package format that would hopefully make it easier in the future. A current workaround would be to use the <code>-Wl,--allow-multiple-definition</code> linker flag, but this unfortunately isn't ideal as it increases code sizes. See <a href="https://internals.rust-lang.org/t/pre-rfc-stabilize-a-version-of-the-rlib-format/17558">here</a> and <a href="https://github.com/rust-lang/rust/issues/73632">here</a> for more details.</p>
<p><strong>Note:</strong> It is <em>highly</em> recommended to also check-in the generated <code>Cargo.lock</code> file into your version control. This improves the reproducibility of the build and ensures the same package versions are used when building in the future in order to prevent random breakages.</p>
<p>We recommend using the <code>debug</code> build when doing development work as it has helpful logging statements and assertions that will make catching bugs in your implementation easier.</p>
<h2 id="the-vmbinding-trait"><a class="header" href="#the-vmbinding-trait">The <code>VMBinding</code> trait</a></h2>
<p>Now let's actually start implementing the binding. Here we take a look at the Rust side of the binding first (i.e. <code>mmtk-X/mmtk</code>). What we want to do is implement the <a href="https://docs.mmtk.io/api/mmtk/vm/trait.VMBinding.html"><code>VMBinding</code></a> trait.</p>
<p>The <code>VMBinding</code> trait is a "meta-trait" (i.e. a trait that encapsulates other traits) that we expect every binding to implement. In essence, it is the contract established between MMTk and the runtime. We discuss each of its seven key traits briefly:</p>
<ol>
<li><a href="https://docs.mmtk.io/api/mmtk/vm/trait.ActivePlan.html"><code>ActivePlan</code></a>: This trait implements functions related to mutators such as how many mutators exist, getting an iterator for all mutators, etc.</li>
<li><a href="https://docs.mmtk.io/api/mmtk/vm/trait.Collection.html"><code>Collection</code></a>: This trait implements functions related to garbage collection such as starting and stopping mutators, blocking current mutator thread for GC, etc.</li>
<li><a href="https://docs.mmtk.io/api/mmtk/vm/trait.ObjectModel.html"><code>ObjectModel</code></a>: This trait implements the runtime's object model. The object model includes object metadata such as mark-bits, forwarding-bits, etc.; constants regarding assumptions about object addresses; and functions to implement copying objects, querying object sizes, etc. You should <em><strong>carefully</strong></em> implement and understand this as it is a key trait on which many things depend. We will go into more detail about this trait in the <a href="#object-model">object model section</a>.</li>
<li><a href="https://docs.mmtk.io/api/mmtk/vm/trait.ReferenceGlue.html"><code>ReferenceGlue</code></a>: This trait implements runtime-specific finalization and weak reference processing methods. Note that each runtime has its own way of dealing with finalization and reference processing, so this is often one of the trickiest traits to implement.</li>
<li><a href="https://docs.mmtk.io/api/mmtk/vm/trait.Scanning.html"><code>Scanning</code></a>: This trait implements object scanning functions such as scanning mutator threads for root pointers, scanning a particular object for reference fields, etc.</li>
<li><a href="https://docs.mmtk.io/api/mmtk/vm/slot/trait.Slot.html"><code>Slot</code></a>: This trait implements a slot in an object, on the stack or other places (such as global variables). If a slot in your runtime simply holds the address of an object (or 0 for NULL references), you may use the <a href="https://docs.mmtk.io/api/mmtk/vm/slot/struct.SimpleSlot.html"><code>SimpleSlot</code></a> type. But if your VM uses tagged pointers or compressed pointers, you will need to implement it manually.</li>
<li><a href="https://docs.mmtk.io/api/mmtk/vm/slot/trait.MemorySlice.html"><code>MemorySlice</code></a>: This trait implements functions related to memory slices such as arrays. This is mainly used by generational collectors.</li>
</ol>
<p>For the time-being we can implement all the above traits via <code>unimplemented!()</code> stubs. If you are using the Dummy VM binding as a starting point, you will have to edit some of the concrete implementations to <code>unimplemented!()</code>. Note that you should change the type that implements <code>VMBinding</code> from <code>DummyVM</code> to an appropriately named type for your runtime. For example, the OpenJDK binding defines the zero-struct <a href="https://github.com/mmtk/mmtk-openjdk/blob/54a249e877e1cbea147a71aafaafb8583f33843d/mmtk/src/lib.rs#L139-L162"><code>OpenJDK</code></a> which implements the <code>VMBinding</code> trait.</p>
<h3 id="object-model"><a class="header" href="#object-model">Object model</a></h3>
<p>The <code>ObjectModel</code> trait is a fundamental trait describing the layout of an object to MMTk. This is important as MMTk's core doesn't know of how objects look like internally as each runtime will be different. There are certain key aspects you need to be aware of while implementing the <code>ObjectModel</code> trait. We discuss them in this section.</p>
<h4 id="header-vs-side-metadata"><a class="header" href="#header-vs-side-metadata">Header vs Side metadata</a></h4>
<p>Per-object metadata can live in one of two places: in the object header or in a separate space used just for metadata. Each one has its pros and cons.</p>
<p>Header metadata sits in close proximity to the actual object address but it is not easy to perform bulk operations. On the other hand, side metadata sits in a dedicated metadata space where each possible object address is assigned some metadata. This makes performing bulk operations easy and does not require stealing bits from the object header (there may in fact be no bits to steal for certain runtimes), but can result in large heap sizes given the metadata space is counted as part of the heap.</p>
<p>The choice of metadata location depends on the runtime and its object model and header layout. For example the JikesRVM runtime reserved extra space at the start of each object for GC-related metadata. Such space may not be available in your runtime. In such cases you can use side metadata to reserve per-object metadata.</p>
<h4 id="local-vs-global-metadata"><a class="header" href="#local-vs-global-metadata">Local vs Global metadata</a></h4>
<p>MMTk uses multiple GC policies and each policy may use a different set of object metadata from each other. A moving policy, for example, may require extra metadata (in comparison to a non-moving policy) to store the forwarding bits and forwarding pointer. Such a metadata, which is local to a policy, is referred to as "local" metadata.</p>
<p>However, in certain cases, we may need to have metadata globally for the entire heap space. The classic example is the valid-object bit metadata which tells us if an arbitrary address is allocated/managed by MMTk. Such a metadata, which spans multiple policies, is referred to as "global" metadata.</p>
<p>For example, the <em>Forwarding bits and pointer</em> metadata is a local metadata used by copying policies to store forwarding bits (2-bits) and forwarding pointers (word size). Often runtimes require word-aligned addresses which means we can use the last two bits in the object header (due to alignment) and the entire object header to store the forwarding bits and pointer respectively. This metadata is almost always in the header.</p>
<p>We recommend going through the <a href="https://docs.mmtk.io/api/mmtk/vm/trait.ObjectModel.html#required-associated-consts">list of metadata specifications</a> that are defined by MMTk. You should set them to locations that are appropriate for your runtime.</p>
<h4 id="objectreference-vs-address"><a class="header" href="#objectreference-vs-address"><code>ObjectReference</code> vs <code>Address</code></a></h4>
<p>A key principle in MMTk is the distinction between <a href="https://docs.mmtk.io/api/mmtk/util/address/struct.ObjectReference.html"><code>ObjectReference</code></a> and <a href="https://docs.mmtk.io/api/mmtk/util/address/struct.Address.html"><code>Address</code></a>. The idea is that very few operations are allowed on an <code>ObjectReference</code>. For example, MMTk does not allow address arithmetic on <code>ObjectReference</code>s. This allows us to preserve memory-safety, only performing unsafe operations when required, and gives us a cleaner and more flexible abstraction to work with as it can allow object handles or offsets etc. <code>Address</code>, on the other hand, represents an arbitrary machine address. You might be interested in reading the <a href="https://users.cecs.anu.edu.au/~steveb/pubs/papers/vmmagic-vee-2009.pdf"><em>Demystifying Magic: High-level Low-level Programming</em></a> paper which describes the above in more detail.</p>
<p>In MMTk, <code>ObjectReference</code> is a special address that represents an object.  It is required to be
within the address range of the object it refers to, and must be word-aligned.  This address is used
by MMTk to access side metadata, and find the space or regions (chunk, block, line, etc.) that
contains the object.  It must also be efficient to locate the object header (where in-header MMTk
metadata are held) and the object's VM-specific metadata, such as type information, from a given
<code>ObjectReference</code>.  MMTk will need to access those information, either directly or indirectly via
traits implemented by the binding, during tracing, which is performance-critical.</p>
<p>The address used as <code>ObjectReference</code> is nominated by the VM binding when an object is allocated (or
moved by a moving GC, which we can ignore for now when supporting NoGC).  VMs usually have their own
concepts of "object reference" which refer to objects.  Some of them, including OpenJDK and CRuby,
uses addresses to the object (the starting address or at an offset within the object) to refer to an
object.  Such VMs can directly use their "object reference" for the address of MMTk's
<code>ObjectReference</code>.</p>
<p>Some VMs, such as JikesRVM, refers to an object by an address at a constant offset after the header,
and can be outside the object.  This does not satisfy the requirement of MMTk's <code>ObjectReference</code>,
and the VM binding needs to make a clear distinction between the VM-level object reference and
MMTk's <code>ObjectReference</code> type.  A detailed example for supporting such a VM can be found
<a href="https://github.com/mmtk/mmtk-jikesrvm/issues/178">here</a>.</p>
<p>Other VMs may use tagged references, compressed pointers, etc.  They need to convert them to plain
addresses to be used as MMTk's <code>ObjectReference</code>.  Specifically, if the VM use such representations
in object fields, the VM binding can deal with the encoding and the decoding in its
<a href="https://docs.mmtk.io/api/mmtk/vm/slot/trait.Slot.html"><code>Slot</code></a> implementation, and always present plain <code>ObjectReference</code>s to MMTk. See [this
test] for some <code>Slot</code> implementation examples.</p>
<h4 id="miscellaneous-configuration-options"><a class="header" href="#miscellaneous-configuration-options">Miscellaneous configuration options</a></h4>
<p>There are many constants in the <code>ObjectModel</code> trait that can be overridden in your binding in order to meet your runtime's requirements. For example, the <code>OBJECT_REF_OFFSET_LOWER_BOUND</code> constant which defines the minimum offset from allocation result start (i.e. the address that MMTk will return to the runtime) and the actual start of the object, i.e. the <code>ObjectReference</code>. In other words, the constant represents the minimum offset from the allocation result start such that the following invariant always holds:</p>
<pre><code>OBJECT_REFERENCE &gt;= ALLOCATION_RESULT_START + OFFSET
</code></pre>
<p>We recommend going through the <a href="https://docs.mmtk.io/api/mmtk/vm/trait.ObjectModel.html">list of constants in the documentation</a> and seeing if the default values suit your runtime's semantics, changing them if required.</p>
<h2 id="mmtk-initialization"><a class="header" href="#mmtk-initialization">MMTk initialization</a></h2>
<p>Now that we have most of the boilerplate set up, the next step is to initialize MMTk so that we can start allocating objects.</p>
<p>In short, MMTk uses the builder pattern. The binding needs to create an <a href="https://docs.mmtk.io/api/mmtk/struct.MMTKBuilder.html"><code>MMTKBuilder</code></a>,
create an <a href="https://docs.mmtk.io/api/mmtk/mmtk/struct.MMTK.html"><code>MMTK</code></a> instance from the builder, and then initialize MMTk's collection
when the runtime system is ready for GCs.
The following steps describes details. In an actual binding implementation, the binding may choose to combine several
steps into one function call to make things simpler.</p>
<ol>
<li>Create an <code>MMTKBuilder</code> using <a href="https://docs.mmtk.io/api/mmtk/struct.MMTKBuilder.html#method.new"><code>MMTKBuilder::new()</code></a>. You can set
runtime options via <a href="https://docs.mmtk.io/api/mmtk/struct.MMTKBuilder.html#method.set_option"><code>set_option()</code></a> for things like
the GC plan to use, heap sizes, etc. This is <a href="https://docs.mmtk.io/api/mmtk/util/options/struct.Options.html">a full list of runtime options</a>.
You can also set options by directly accessing the <code>options</code> in the builder, such as <code>builder.options.threads.set(4)</code>.
It is a common practice that the VM parses its command line arguments, then sets some GC-related options
to MMTk here. You can also set virtual memory layout for MMTk. Some runtimes may require special layouts, such as using compressed pointers
with a fixed heap range. However, both setting options and VM layouts are optional -- MMTk will use the default values if none is set.</li>
<li>Create an <code>MMTK</code> instance via <a href="https://docs.mmtk.io/api/mmtk/memory_manager/fn.mmtk_init.html"><code>memory_manager::mmtk_init()</code></a>. This
enables the binding to use most of the MMTk APIs in <a href="https://docs.mmtk.io/api/mmtk/memory_manager/index.html"><code>memory_manager</code></a>, as most
APIs require a reference to <code>MMTK</code>.</li>
<li>When the runtime is ready for GCs (including getting its thread system ready to spawn GC threads), it is expected to call <a href="https://docs.mmtk.io/api/mmtk/memory_manager/fn.initialize_collection.html"><code>memory_manager::initialize_collection</code></a>. Once the function returns, MMTk may trigger a GC at any appropriate time.
In terms of getting NoGC to work, this step is optional, as NoGC will not trigger GCs.</li>
</ol>
<p>In practice, it greatly depends on the runtime about how to expose the MMTk's Rust API above to native, and when to call the native API in the runtime.
In the following example, we assume a <code>MMTKBuilder</code> is created statically (Step 1), and expects a call from the runtime to set heap sizes to the builder
via <code>mmtk_set_heap_size()</code>. We will create an <code>MMTK</code> instance from the builder in <code>mmtk_init()</code> (Step 2). Step 3 is omitted, as we do not need it for NoGC.</p>
<h3 id="runtime-side-changes"><a class="header" href="#runtime-side-changes">Runtime-side changes</a></h3>
<p>Create a <code>mmtk.h</code> header file in the runtime folder of the binding (i.e. <code>mmtk-X/X</code>) which exposes the functions required to implement NoGC and <code>#include</code> it in the relevant runtime code. You can use the <a href="https://github.com/mmtk/mmtk-core/blob/master/docs/dummyvm/include/mmtk.h">example <code>mmtk.h</code> header file</a> as an example.</p>
<p><strong>Note:</strong> It is convention to prefix all MMTk API functions exposed with <code>mmtk_</code> in order to avoid name clashes. It is <em>highly</em> recommended that you follow this convention.</p>
<p>Having a clean heap API for MMTk to implement makes life easier. Some runtimes may already have a sufficiently clean abstraction such as OpenJDK after the merging of <a href="https://openjdk.org/jeps/304">JEP 304</a>. In (most) other cases, the runtime doesn't provide a clean enough heap API for MMTk to implement. In such cases, it is recommended to create a class (or equivalent) that abstracts allocation and other heap functions like what the <a href="https://chromium.googlesource.com/v8/v8/+/a9976e160f4755990ec065d4b077c9401340c8fb/src/heap/third-party/heap-api.h">V8</a> and ART bindings do. This allows making minimal changes to the actual runtime and having a concrete implementation of the exposed heap API in the binding, reducing MMTk-specific code in the runtime. Ideally these changes are upstreamed like in the case of V8.</p>
<p>It is also recommended that any change you do in the runtime be guarded by build-time flags as it helps in maintaining a clean port.</p>
<p>At this step, your <code>mmtk.h</code> file may look something like this:</p>
<pre><code class="language-C">#ifndef MMTK_H
#define MMTK_H

#include &lt;stddef.h&gt;
#include &lt;sys/types.h&gt;

// The extern "C" is only required if the runtime
// implementation language is C++
extern "C" {

// An arbitrary address
typedef void* Address;
// MmtkMutator should be an opaque pointer for the VM
typedef void* MmtkMutator;
// An opaque pointer to a VMThread
typedef void* VMThread;

/**
 * Initialize MMTk instance
 */
void mmtk_init();

/**
 * Set the heap size
 *
 * @param min minimum heap size
 * @param max maximum heap size
 */
void mmtk_set_heap_size(size_t min, size_t max);

} // extern "C"

#endif // MMTK_H
</code></pre>
<p>Now we can initialize MMTk in the runtime. Note that MMTk should ideally be initialized around when the default heap of the runtime is initialized. You will have to figure out where is the best location to initialize MMTk in your runtime.</p>
<p>Initializing MMTk requires two steps. First, we set the heap size by calling <code>mmtk_set_heap_size</code> with the initial heap size and the maximum heap size. Then, we initialize MMTk by calling <code>mmtk_init</code>. In the future, you may wish to make the heap size configurable via a command line argument or environment variable (See <a href="#setting-options-for-mmtk">setting options for MMTk</a>).</p>
<!-- You may have noticed the `mmtk_initialize_collection` function defined above in the `mmtk.h` file. This function is called after the runtime has completely set up including (but not limited to) its thread system. This function will spawn GC threads and allow MMTk to collect objects. For the time-being we can ignore calling this function as NoGC does not collect objects so does not require calling `mmtk_initialize_collection`. -->
<h3 id="mmtk-side-changes"><a class="header" href="#mmtk-side-changes">MMTk-side changes</a></h3>
<p>On the Rust side of the binding, we want to implement the two functions exposed by the <code>mmtk.h</code> file above. We use an <a href="https://docs.mmtk.io/api/mmtk/struct.MMTKBuilder.html"><code>MMTKBuilder</code></a> instance to actually create our concrete <a href="https://docs.mmtk.io/api/mmtk/struct.MMTK.html"><code>MMTK</code></a> instance. We recommend following the paradigm used by all our bindings wherein we have a <code>static</code> single <code>MMTK</code> instance and an <code>MMTKBuilder</code> instance that we can use to set relevant options. See the <a href="https://github.com/mmtk/mmtk-openjdk/blob/54a249e877e1cbea147a71aafaafb8583f33843d/mmtk/src/lib.rs#L169-L178">OpenJDK binding</a> for an example.</p>
<p><strong>Note:</strong> MMTk currently assumes that there is only one <code>MMTK</code> instance in your runtime process. Multiple <code>MMTK</code> instances are currently not supported.</p>
<p>The <code>mmtk_set_heap_size</code> function is fairly straightforward. We recommend using the implementation in the <a href="https://github.com/mmtk/mmtk-openjdk/blob/54a249e877e1cbea147a71aafaafb8583f33843d/mmtk/src/api.rs#L94-L104">OpenJDK binding</a>. The <code>mmtk_init</code> function is straightforward as well. It should simply manually initialize the <code>MMTK</code> <code>static</code> variable using <code>lazy_static</code>, like <a href="https://github.com/mmtk/mmtk-openjdk/blob/54a249e877e1cbea147a71aafaafb8583f33843d/mmtk/src/api.rs#L83-L86">here</a> in the OpenJDK binding.</p>
<p>By this point, you should have MMTk initialized. If you are using a debug build (which is recommended) and have logging turned on a message similar to below would be printed out:</p>
<pre><code>[...]
[INFO  mmtk::memory_manager] Initialized MMTk with NoGC (FixedHeapSize(10485760))
[...]
</code></pre>
<h2 id="binding-mutator-threads-to-mmtk"><a class="header" href="#binding-mutator-threads-to-mmtk">Binding mutator threads to MMTk</a></h2>
<p>For MMTk to allocate objects, it needs to be aware of mutator threads. MMTk only allows mutator threads to allocate objects. We do this by "binding" a mutator thread to MMTk when it is initialized in the runtime.</p>
<h3 id="runtime-side-changes-1"><a class="header" href="#runtime-side-changes-1">Runtime-side changes</a></h3>
<p>Add the following function to the <code>mmtk.h</code> file:</p>
<pre><code class="language-C">[...]

/**
 * Bind a mutator thread in MMTk
 *
 * @param tls pointer to mutator thread
 * @return an instance of an MMTk mutator
 */
MmtkMutator mmtk_bind_mutator(VMThread tls);

[...]
</code></pre>
<p>The <code>mmtk_bind_mutator</code> function takes in an opaque pointer representing an instance of the runtime's mutator thread and returns an opaque pointer to a <a href="https://docs.mmtk.io/api/mmtk/plan/struct.Mutator.html"><code>Mutator</code></a> instance back to the runtime. The runtime <em><strong>must</strong></em> store this pointer somewhere, preferably in its runtime thread local storage implementation, as MMTk requires a <code>Mutator</code> instance to allocate and perform other actions.</p>
<p>The placement of the <code>mmtk_bind_mutator</code> call in the runtime depends on the runtime's implementation of its thread system. It is recommended to call <code>mmtk_bind_mutator</code> when the runtime initializes the thread local storage of a newly created thread. This ensures that the thread can allocate from MMTk immediately after initialization.</p>
<h3 id="mmtk-side-changes-1"><a class="header" href="#mmtk-side-changes-1">MMTk-side changes</a></h3>
<p>The Rust side of the binding should simply defer the actual implementation to <a href="https://docs.mmtk.io/api/mmtk/memory_manager/fn.bind_mutator.html"><code>mmtk::memory_manager::bind_mutator</code></a>. See the <a href="https://github.com/mmtk/mmtk-openjdk/blob/54a249e877e1cbea147a71aafaafb8583f33843d/mmtk/src/api.rs#L106-L109">OpenJDK binding</a> for an example.</p>
<h2 id="allocation"><a class="header" href="#allocation">Allocation</a></h2>
<p>Now we can finally implement the allocation functions.</p>
<h3 id="runtime-side-changes-2"><a class="header" href="#runtime-side-changes-2">Runtime-side changes</a></h3>
<p>Add the following two functions to the <code>mmtk.h</code> file:</p>
<pre><code class="language-C">[...]

/**
 * Allocate an object
 *
 * @param mutator the mutator instance that is requesting the allocation
 * @param size the size of the requested object
 * @param align the alignment requirement for the object
 * @param offset the allocation offset for the object
 * @param allocator the allocation semantics to use for the allocation
 * @return the address of the newly allocated object
 */
void *mmtk_alloc(MmtkMutator mutator, size_t size, size_t align,
        ssize_t offset, int allocator);

/**
 * Set relevant object metadata
 *
 * @param mutator the mutator instance that is requesting the allocation
 * @param object the ObjectReference address chosen by the VM binding
 * @param size the size of the allocated object
 * @param allocator the allocation semantics to use for the allocation
 */
void mmtk_post_alloc(MmtkMutator mutator, void* object, size_t size, int allocator);

[...]
</code></pre>
<p>In order to perform allocations, you will need to know what object alignment the runtime expects. Runtimes often align allocations at word boundaries (i.e. 4- or 8-bytes) as it allows the CPU to access the data faster at execution time. Additionally, the runtime may use the unused lowest order bits to store flags (e.g. type information), so it is important that MMTk respects these expectations. Once you have figured out the alignment requirements for your runtime, you should update the <a href="https://docs.mmtk.io/api/mmtk/vm/trait.VMBinding.html#associatedconstant.MIN_ALIGNMENT"><code>MIN_ALIGNMENT</code></a> constant in <code>VMBinding</code> to the correct value.</p>
<p>Now that MMTk is aware of each mutator thread, you have to change the runtime's allocation functions to call into MMTk to allocate using <code>mmtk_alloc</code> and set object metadata using <code>mmtk_post_alloc</code>. Note that there may be multiple allocation functions in the runtime so make sure that you edit them all!</p>
<p>When calling <code>mmtk_alloc</code>, you should use the saved <code>Mutator</code> pointer as the first parameter, the requested object size as the next parameter, and any alignment requirements the runtimes has as the third parameter.</p>
<p>If your runtime requires a non-zero allocation offset (i.e. the alignment requirements are for the offset address, not the returned address) then you have to provide the required value as the fourth parameter. Note that you <em><strong>must</strong></em> also update the <a href="https://docs.mmtk.io/api/mmtk/vm/trait.VMBinding.html#associatedconstant.USE_ALLOCATION_OFFSET"><code>USE_ALLOCATION_OFFSET</code></a> constant in the <code>VMBinding</code> implementation if your runtime requires a non-zero allocation offset.</p>
<p>For the time-being, you can ignore the <code>allocator</code> parameter in both these functions and always pass a value of <code>0</code> which means MMTk will pick the default allocator for your collector (a bump pointer allocator in the case of NoGC).</p>
<p>The return value of <code>mmtk_alloc</code> is the starting address of the allocated object.</p>
<p>Then you should nominate a word-aligned address within the allocated bytes to be the
<code>ObjectReference</code> used to refer to that object from now on.  It doesn't have to be the starting
address.</p>
<p>Finally, you need to call <code>mmtk_post_alloc</code> with your chosen <code>ObjectReference</code> in order to
initialize MMTk-level object metadata, such as logging bits, valid-object (VO) bits, etc.  As a VM
binding developer, you can ignore the details for now.</p>
<p><strong>Note:</strong> Currently MMTk assumes object sizes are multiples of the <code>MIN_ALIGNMENT</code>. If you encounter errors with alignment, a simple workaround would be to align the requested object size up to the <code>MIN_ALIGNMENT</code>. See <a href="https://github.com/mmtk/mmtk-core/issues/730">here</a> for the tracking issue to fix this bug.</p>
<h3 id="mmtk-side-changes-2"><a class="header" href="#mmtk-side-changes-2">MMTk-side changes</a></h3>
<p>The Rust side of the binding should simply defer the actual implementation to <a href="https://docs.mmtk.io/api/mmtk/memory_manager/fn.alloc.html"><code>mmtk::memory_manager::alloc</code></a> and <a href="https://docs.mmtk.io/api/mmtk/memory_manager/fn.post_alloc.html"><code>mmtk::memory_manager::post_alloc</code></a> respectively. See the <a href="https://github.com/mmtk/mmtk-openjdk/blob/54a249e877e1cbea147a71aafaafb8583f33843d/mmtk/src/api.rs#L125-L136">OpenJDK</a> <a href="https://github.com/mmtk/mmtk-openjdk/blob/54a249e877e1cbea147a71aafaafb8583f33843d/mmtk/src/api.rs#L151-L161">binding</a> for an example.</p>
<p>Congratulations! At this point, you hopefully have object allocation working and can run simple programs with your runtime using MMTk!</p>
<h2 id="miscellaneous-implementation-steps"><a class="header" href="#miscellaneous-implementation-steps">Miscellaneous implementation steps</a></h2>
<h3 id="setting-options-for-mmtk"><a class="header" href="#setting-options-for-mmtk">Setting options for MMTk</a></h3>
<p>The preferred method of setting <a href="https://docs.mmtk.io/api/mmtk/util/options/index.html">options for MMTk</a> is by setting them via the <code>MMTKBuilder</code> instance. See <a href="https://github.com/mmtk/mmtk-openjdk/blob/54a249e877e1cbea147a71aafaafb8583f33843d/mmtk/src/api.rs#L79">here</a> for an example in the OpenJDK binding.</p>
<p>The <a href="https://docs.mmtk.io/api/mmtk/memory_manager/fn.process.html"><code>process</code></a> function can also be used to pass options. You may want to set multiple options at the same time. In such a case you can use the <a href="https://docs.mmtk.io/api/mmtk/memory_manager/fn.process_bulk.html"><code>process_bulk</code></a> function.</p>
<p>MMTk also supports setting options via environment variables. This is generally only recommended at early stages of the porting process in order for quick development. For example, to use the NoGC plan, you can set the environment variable <code>MMTK_PLAN=NoGC</code>.</p>
<p>A full list of available options that you can set can be found <a href="https://docs.mmtk.io/api/mmtk/util/options/struct.Options.html">here</a>.</p>
<h3 id="runtime-specific-steps"><a class="header" href="#runtime-specific-steps">Runtime-specific steps</a></h3>
<p>Often it is the case that the above changes are not enough to allow a runtime to work with MMTk. For example, for the ART binding, the runtime required that all inflated locks be deflated prior to writing the boot image. In order to fix this, we had to implement a heap visitor that visited each allocated object and checked if it had inflated locks, deflating them if they were.</p>
<p>Unfortunately there is no real magic bullet here. If you come across a runtime-specific idiosyncrasy (and you almost certainly will), you will have to understand what the underlying bug is and either fix or work around it.</p>
<p>If you have any confusions or questions, please free to reach us on our <a href="https://mmtk.zulipchat.com/">Zulip</a>! We would be glad to help.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../portingguide/howto/prefix.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../portingguide/howto/next_steps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../portingguide/howto/prefix.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../portingguide/howto/next_steps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../assets/js/api-migration-details.js"></script>


    </div>
    </body>
</html>
