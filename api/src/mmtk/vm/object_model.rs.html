<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/vm/object_model.rs`."><title>object_model.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../../../static.files/src-script-813739b1.js"></script><script defer src="../../../src-files.js"></script><script defer src="../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">mmtk/vm/</div>object_model.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-3"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="kw">use </span>atomic::Ordering;
<a href=#2 id=2 data-nosnippet>2</a>
<a href=#3 id=3 data-nosnippet>3</a><span class="kw">use </span><span class="self">self</span>::specs::<span class="kw-2">*</span>;
<a href=#4 id=4 data-nosnippet>4</a><span class="kw">use </span><span class="kw">crate</span>::util::copy::<span class="kw-2">*</span>;
<a href=#5 id=5 data-nosnippet>5</a><span class="kw">use </span><span class="kw">crate</span>::util::metadata::header_metadata::HeaderMetadataSpec;
<a href=#6 id=6 data-nosnippet>6</a><span class="kw">use </span><span class="kw">crate</span>::util::metadata::MetadataValue;
<a href=#7 id=7 data-nosnippet>7</a><span class="kw">use </span><span class="kw">crate</span>::util::{Address, ObjectReference};
<a href=#8 id=8 data-nosnippet>8</a><span class="kw">use </span><span class="kw">crate</span>::vm::VMBinding;
<a href=#9 id=9 data-nosnippet>9</a>
<a href=#10 id=10 data-nosnippet>10</a><span class="doccomment">/// VM-specific methods for object model.
<a href=#11 id=11 data-nosnippet>11</a>///
<a href=#12 id=12 data-nosnippet>12</a>/// This trait includes 3 parts:
<a href=#13 id=13 data-nosnippet>13</a>///
<a href=#14 id=14 data-nosnippet>14</a>/// 1. Specifications for per object metadata: a binding needs to specify the location for each per object metadata spec.
<a href=#15 id=15 data-nosnippet>15</a>///    A binding can choose between `in_header()` or `side()`, e.g. `VMGlobalLogBitSpec::side()`.
<a href=#16 id=16 data-nosnippet>16</a>///    * in_header: a binding needs to specify the bit offset to an object reference that can be used for the per object metadata spec.
<a href=#17 id=17 data-nosnippet>17</a>///      The actual number of bits required for a spec can be obtained from the `num_bits()` method of the spec type.
<a href=#18 id=18 data-nosnippet>18</a>///    * side: a binding does not need to provide any specific storage for metadata in the header. Instead, MMTk
<a href=#19 id=19 data-nosnippet>19</a>///      will use side tables to store the metadata. The following section Side Specs Layout will discuss how to correctly create
<a href=#20 id=20 data-nosnippet>20</a>///      side metadata specs.
<a href=#21 id=21 data-nosnippet>21</a>/// 2. In header metadata access: A binding
<a href=#22 id=22 data-nosnippet>22</a>///    need to further define the functions with suffix _metadata about how to access the bits in the header. We provide default implementations
<a href=#23 id=23 data-nosnippet>23</a>///    for those methods, assuming the bits in the spec are always available to MMTk. A binding could implement their
<a href=#24 id=24 data-nosnippet>24</a>///    own routines to access the bits if VM specific treatment is needed (e.g. some bits are not always available to MMTk).
<a href=#25 id=25 data-nosnippet>25</a>/// 3. VM-specific object info needed by MMTk: MMTk does not know object info as it is VM specific. However, MMTk needs
<a href=#26 id=26 data-nosnippet>26</a>///    some object information for GC. A binding needs to implement them correctly.
<a href=#27 id=27 data-nosnippet>27</a>///
<a href=#28 id=28 data-nosnippet>28</a>/// Note that depending on the selected GC plan, only a subset of the methods provided here will be used.
<a href=#29 id=29 data-nosnippet>29</a>///
<a href=#30 id=30 data-nosnippet>30</a>/// # Side Specs Layout
<a href=#31 id=31 data-nosnippet>31</a>///
<a href=#32 id=32 data-nosnippet>32</a>/// ## Short version
<a href=#33 id=33 data-nosnippet>33</a>///
<a href=#34 id=34 data-nosnippet>34</a>/// * For *global* side metadata:
<a href=#35 id=35 data-nosnippet>35</a>///   * The first spec: VMGlobalXXXSpec::side_first()
<a href=#36 id=36 data-nosnippet>36</a>///   * The following specs: VMGlobalXXXSpec::side_after(FIRST_GLOAL.as_spec())
<a href=#37 id=37 data-nosnippet>37</a>/// * For *local* side metadata:
<a href=#38 id=38 data-nosnippet>38</a>///   * The first spec: VMLocalXXXSpec::side_first()
<a href=#39 id=39 data-nosnippet>39</a>///   * The following specs: VMLocalXXXSpec::side_after(FIRST_LOCAL.as_spec())
<a href=#40 id=40 data-nosnippet>40</a>///
<a href=#41 id=41 data-nosnippet>41</a>/// ## Detailed explanation
<a href=#42 id=42 data-nosnippet>42</a>///
<a href=#43 id=43 data-nosnippet>43</a>/// There are two types of side metadata layout in MMTk:
<a href=#44 id=44 data-nosnippet>44</a>///
<a href=#45 id=45 data-nosnippet>45</a>/// 1. Contiguous layout: is the layout in which the whole metadata space for a SideMetadataSpec is contiguous.
<a href=#46 id=46 data-nosnippet>46</a>/// 2. Chunked layout: is the layout in which the whole metadata memory space, that is shared between MMTk policies, is divided into metadata-chunks. Each metadata-chunk stores all of the metadata for all `SideMetadataSpec`s which apply to a source-data chunk.
<a href=#47 id=47 data-nosnippet>47</a>///
<a href=#48 id=48 data-nosnippet>48</a>/// In 64-bits targets, both Global and PolicySpecific side metadata are contiguous.
<a href=#49 id=49 data-nosnippet>49</a>/// Also, in 32-bits targets, the Global side metadata is contiguous.
<a href=#50 id=50 data-nosnippet>50</a>/// This means if the starting address (variable named `offset`) of the metadata space for a SideMetadataSpec (`SPEC1`) is `BASE1`, the starting address (`offset`) of the next SideMetadataSpec (`SPEC2`) will be `BASE1 + total_metadata_space_size(SPEC1)`, which is located immediately after the end of the whole metadata space of `SPEC1`.
<a href=#51 id=51 data-nosnippet>51</a>/// Now, if we add a third SideMetadataSpec (`SPEC3`), its starting address (`offset`) will be `BASE2 + total_metadata_space_size(SPEC2)`, which is located immediately after the end of the whole metadata space of `SPEC2`.
<a href=#52 id=52 data-nosnippet>52</a>///
<a href=#53 id=53 data-nosnippet>53</a>/// In 32-bits targets, the PolicySpecific side metadata is chunked.
<a href=#54 id=54 data-nosnippet>54</a>/// This means for each chunk (2^22 Bytes) of data, which, by definition, is managed by exactly one MMTk policy, there is a metadata chunk (2^22 * some_fixed_ratio Bytes) that contains all of its PolicySpecific metadata.
<a href=#55 id=55 data-nosnippet>55</a>/// This means if a policy has one SideMetadataSpec (`LS1`), the `offset` of that spec will be `0` (= at the start of a metadata chunk).
<a href=#56 id=56 data-nosnippet>56</a>/// If there is a second SideMetadataSpec (`LS2`) for this specific policy, the `offset` for that spec will be `0 + required_metadata_space_per_chunk(LS1)`,
<a href=#57 id=57 data-nosnippet>57</a>/// and for a third SideMetadataSpec (`LS3`), the `offset` will be `BASE(LS2) + required_metadata_space_per_chunk(LS2)`.
<a href=#58 id=58 data-nosnippet>58</a>///
<a href=#59 id=59 data-nosnippet>59</a>/// For all other policies, the `offset` starts from zero. This is safe because no two policies ever manage one chunk, so there will be no overlap.
<a href=#60 id=60 data-nosnippet>60</a>///
<a href=#61 id=61 data-nosnippet>61</a>/// # Object Layout Addresses
<a href=#62 id=62 data-nosnippet>62</a>///
<a href=#63 id=63 data-nosnippet>63</a>/// MMTk tries to be general to cope with different language implementations and different object models. Thus it does not assume the internal of the object model.
<a href=#64 id=64 data-nosnippet>64</a>/// Instead, MMTk only uses the following addresses for an object. If you find the MMTk's approach does not work for your language in practice, you are welcome to submit an issue
<a href=#65 id=65 data-nosnippet>65</a>/// or engage with MMTk team on Zulip to disucss further.
<a href=#66 id=66 data-nosnippet>66</a>///
<a href=#67 id=67 data-nosnippet>67</a>/// ## (Raw) Object Reference
<a href=#68 id=68 data-nosnippet>68</a>///
<a href=#69 id=69 data-nosnippet>69</a>/// See [`crate::util::address::ObjectReference`]. This is a special address that represents the
<a href=#70 id=70 data-nosnippet>70</a>/// object. MMTk refers to an object by its object reference. An object reference cannot be NULL,
<a href=#71 id=71 data-nosnippet>71</a>/// must be inside the address range of the object, and must be word aligned
<a href=#72 id=72 data-nosnippet>72</a>/// ([`crate::util::address::ObjectReference::ALIGNMENT`]).
<a href=#73 id=73 data-nosnippet>73</a>///
<a href=#74 id=74 data-nosnippet>74</a>/// ## Object Start Address
<a href=#75 id=75 data-nosnippet>75</a>///
<a href=#76 id=76 data-nosnippet>76</a>/// This address is returned by an allocation call [`crate::memory_manager::alloc`]. This is the start of the address range of the allocation.
<a href=#77 id=77 data-nosnippet>77</a>/// [`ObjectModel::ref_to_object_start`] should return this address for a given object.
<a href=#78 id=78 data-nosnippet>78</a>///
<a href=#79 id=79 data-nosnippet>79</a>/// ## Object header address
<a href=#80 id=80 data-nosnippet>80</a>///
<a href=#81 id=81 data-nosnippet>81</a>/// If a binding allows MMTk to use its header bits for object metadata, it needs to supply an object header
<a href=#82 id=82 data-nosnippet>82</a>/// address ([`ObjectModel::ref_to_header`]). MMTk will access header bits using this address.
<a href=#83 id=83 data-nosnippet>83</a></span><span class="kw">pub trait </span>ObjectModel&lt;VM: VMBinding&gt; {
<a href=#84 id=84 data-nosnippet>84</a>    <span class="comment">// Per-object Metadata Spec definitions go here
<a href=#85 id=85 data-nosnippet>85</a>    //
<a href=#86 id=86 data-nosnippet>86</a>    // Note a number of Global and PolicySpecific side metadata specifications are already reserved by mmtk-core.
<a href=#87 id=87 data-nosnippet>87</a>    // Any side metadata offset calculation must consider these to prevent overlaps. A binding should start their
<a href=#88 id=88 data-nosnippet>88</a>    // side metadata from GLOBAL_SIDE_METADATA_VM_BASE_ADDRESS or LOCAL_SIDE_METADATA_VM_BASE_ADDRESS.
<a href=#89 id=89 data-nosnippet>89</a>
<a href=#90 id=90 data-nosnippet>90</a>    </span><span class="doccomment">/// A global 1-bit metadata used by generational plans to track cross-generational pointers. It is generally
<a href=#91 id=91 data-nosnippet>91</a>    /// located in side metadata.
<a href=#92 id=92 data-nosnippet>92</a>    ///
<a href=#93 id=93 data-nosnippet>93</a>    /// Note that for this bit, 0 represents logged (default), and 1 represents unlogged.
<a href=#94 id=94 data-nosnippet>94</a>    /// This bit is also referred to as unlogged bit in Java MMTk for this reason.
<a href=#95 id=95 data-nosnippet>95</a>    </span><span class="kw">const </span>GLOBAL_LOG_BIT_SPEC: VMGlobalLogBitSpec;
<a href=#96 id=96 data-nosnippet>96</a>
<a href=#97 id=97 data-nosnippet>97</a>    <span class="doccomment">/// A local word-size metadata for the forwarding pointer, used by copying plans. It is almost always
<a href=#98 id=98 data-nosnippet>98</a>    /// located in the object header as it is fine to destroy an object header in order to copy it.
<a href=#99 id=99 data-nosnippet>99</a>    </span><span class="kw">const </span>LOCAL_FORWARDING_POINTER_SPEC: VMLocalForwardingPointerSpec;
<a href=#100 id=100 data-nosnippet>100</a>
<a href=#101 id=101 data-nosnippet>101</a>    <span class="doccomment">/// A local 2-bit metadata for the forwarding status bits, used by copying plans. If your runtime requires
<a href=#102 id=102 data-nosnippet>102</a>    /// word-aligned addresses (i.e. 4- or 8-bytes), you can use the last two bits in the object header to store
<a href=#103 id=103 data-nosnippet>103</a>    /// the forwarding bits. Note that you must be careful if you place this in the header as the runtime may
<a href=#104 id=104 data-nosnippet>104</a>    /// be using those bits for some other reason.
<a href=#105 id=105 data-nosnippet>105</a>    </span><span class="kw">const </span>LOCAL_FORWARDING_BITS_SPEC: VMLocalForwardingBitsSpec;
<a href=#106 id=106 data-nosnippet>106</a>
<a href=#107 id=107 data-nosnippet>107</a>    <span class="doccomment">/// A local 1-bit metadata for the mark bit, used by most plans that need to mark live objects. Like with the
<a href=#108 id=108 data-nosnippet>108</a>    /// [forwarding bits](crate::vm::ObjectModel::LOCAL_FORWARDING_BITS_SPEC), you can often steal the last bit in
<a href=#109 id=109 data-nosnippet>109</a>    /// the object header (due to alignment requirements) for the mark bit. Though some bindings such as the
<a href=#110 id=110 data-nosnippet>110</a>    /// OpenJDK binding prefer to have the mark bits in side metadata to allow for bulk operations.
<a href=#111 id=111 data-nosnippet>111</a>    </span><span class="kw">const </span>LOCAL_MARK_BIT_SPEC: VMLocalMarkBitSpec;
<a href=#112 id=112 data-nosnippet>112</a>
<a href=#113 id=113 data-nosnippet>113</a>    <span class="attr">#[cfg(feature = <span class="string">"object_pinning"</span>)]
<a href=#114 id=114 data-nosnippet>114</a>    </span><span class="doccomment">/// A local 1-bit metadata specification for the pinning bit, used by plans that need to pin objects. It is
<a href=#115 id=115 data-nosnippet>115</a>    /// generally in side metadata.
<a href=#116 id=116 data-nosnippet>116</a>    </span><span class="kw">const </span>LOCAL_PINNING_BIT_SPEC: VMLocalPinningBitSpec;
<a href=#117 id=117 data-nosnippet>117</a>
<a href=#118 id=118 data-nosnippet>118</a>    <span class="doccomment">/// A local 2-bit metadata used by the large object space to mark objects and set objects as "newly allocated".
<a href=#119 id=119 data-nosnippet>119</a>    /// Used by any plan with large object allocation. It is generally in the header as we can add an extra word
<a href=#120 id=120 data-nosnippet>120</a>    /// before the large object to store this metadata. This is fine as the metadata size is insignificant in
<a href=#121 id=121 data-nosnippet>121</a>    /// comparison to the object size.
<a href=#122 id=122 data-nosnippet>122</a>    </span><span class="comment">//
<a href=#123 id=123 data-nosnippet>123</a>    // TODO: Cleanup and place the LOS mark and nursery bits in the header. See here: https://github.com/mmtk/mmtk-core/issues/847
<a href=#124 id=124 data-nosnippet>124</a>    </span><span class="kw">const </span>LOCAL_LOS_MARK_NURSERY_SPEC: VMLocalLOSMarkNurserySpec;
<a href=#125 id=125 data-nosnippet>125</a>
<a href=#126 id=126 data-nosnippet>126</a>    <span class="doccomment">/// Set this to true if the VM binding requires the valid object (VO) bits to be available
<a href=#127 id=127 data-nosnippet>127</a>    /// during tracing. If this constant is set to `false`, it is undefined behavior if the binding
<a href=#128 id=128 data-nosnippet>128</a>    /// attempts to access VO bits during tracing.
<a href=#129 id=129 data-nosnippet>129</a>    ///
<a href=#130 id=130 data-nosnippet>130</a>    /// Note that the VO bits is always available during root scanning even if this flag is false,
<a href=#131 id=131 data-nosnippet>131</a>    /// which is suitable for using VO bits (and the `is_mmtk_object()` method) for conservative
<a href=#132 id=132 data-nosnippet>132</a>    /// stack scanning. However, if a binding is also conservative in finding references during
<a href=#133 id=133 data-nosnippet>133</a>    /// object scanning, they need to set this constant to `true`. See the comments of individual
<a href=#134 id=134 data-nosnippet>134</a>    /// methods in the `Scanning` trait.
<a href=#135 id=135 data-nosnippet>135</a>    ///
<a href=#136 id=136 data-nosnippet>136</a>    /// Depending on the internal implementation of mmtk-core, different strategies for handling
<a href=#137 id=137 data-nosnippet>137</a>    /// VO bits have different time/space overhead.  mmtk-core will choose the best strategy
<a href=#138 id=138 data-nosnippet>138</a>    /// according to the configuration of the VM binding, including this flag.  Currently, setting
<a href=#139 id=139 data-nosnippet>139</a>    /// this flag to true does not impose any additional overhead.
<a href=#140 id=140 data-nosnippet>140</a>    </span><span class="attr">#[cfg(feature = <span class="string">"vo_bit"</span>)]
<a href=#141 id=141 data-nosnippet>141</a>    </span><span class="kw">const </span>NEED_VO_BITS_DURING_TRACING: bool = <span class="bool-val">false</span>;
<a href=#142 id=142 data-nosnippet>142</a>
<a href=#143 id=143 data-nosnippet>143</a>    <span class="doccomment">/// A function to non-atomically load the specified per-object metadata's content.
<a href=#144 id=144 data-nosnippet>144</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#145 id=145 data-nosnippet>145</a>    /// Returns the metadata value.
<a href=#146 id=146 data-nosnippet>146</a>    ///
<a href=#147 id=147 data-nosnippet>147</a>    /// # Arguments:
<a href=#148 id=148 data-nosnippet>148</a>    ///
<a href=#149 id=149 data-nosnippet>149</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#150 id=150 data-nosnippet>150</a>    /// * `object`: is a reference to the target object.
<a href=#151 id=151 data-nosnippet>151</a>    /// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.
<a href=#152 id=152 data-nosnippet>152</a>    ///
<a href=#153 id=153 data-nosnippet>153</a>    /// # Safety
<a href=#154 id=154 data-nosnippet>154</a>    /// This is a non-atomic load, thus not thread-safe.
<a href=#155 id=155 data-nosnippet>155</a>    </span><span class="kw">unsafe fn </span>load_metadata&lt;T: MetadataValue&gt;(
<a href=#156 id=156 data-nosnippet>156</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#157 id=157 data-nosnippet>157</a>        object: ObjectReference,
<a href=#158 id=158 data-nosnippet>158</a>        mask: <span class="prelude-ty">Option</span>&lt;T&gt;,
<a href=#159 id=159 data-nosnippet>159</a>    ) -&gt; T {
<a href=#160 id=160 data-nosnippet>160</a>        metadata_spec.load::&lt;T&gt;(object.to_header::&lt;VM&gt;(), mask)
<a href=#161 id=161 data-nosnippet>161</a>    }
<a href=#162 id=162 data-nosnippet>162</a>
<a href=#163 id=163 data-nosnippet>163</a>    <span class="doccomment">/// A function to atomically load the specified per-object metadata's content.
<a href=#164 id=164 data-nosnippet>164</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#165 id=165 data-nosnippet>165</a>    /// Returns the metadata value.
<a href=#166 id=166 data-nosnippet>166</a>    ///
<a href=#167 id=167 data-nosnippet>167</a>    /// # Arguments:
<a href=#168 id=168 data-nosnippet>168</a>    ///
<a href=#169 id=169 data-nosnippet>169</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#170 id=170 data-nosnippet>170</a>    /// * `object`: is a reference to the target object.
<a href=#171 id=171 data-nosnippet>171</a>    /// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.
<a href=#172 id=172 data-nosnippet>172</a>    /// * `atomic_ordering`: is the atomic ordering for the load operation.
<a href=#173 id=173 data-nosnippet>173</a>    </span><span class="kw">fn </span>load_metadata_atomic&lt;T: MetadataValue&gt;(
<a href=#174 id=174 data-nosnippet>174</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#175 id=175 data-nosnippet>175</a>        object: ObjectReference,
<a href=#176 id=176 data-nosnippet>176</a>        mask: <span class="prelude-ty">Option</span>&lt;T&gt;,
<a href=#177 id=177 data-nosnippet>177</a>        ordering: Ordering,
<a href=#178 id=178 data-nosnippet>178</a>    ) -&gt; T {
<a href=#179 id=179 data-nosnippet>179</a>        metadata_spec.load_atomic::&lt;T&gt;(object.to_header::&lt;VM&gt;(), mask, ordering)
<a href=#180 id=180 data-nosnippet>180</a>    }
<a href=#181 id=181 data-nosnippet>181</a>
<a href=#182 id=182 data-nosnippet>182</a>    <span class="doccomment">/// A function to non-atomically store a value to the specified per-object metadata.
<a href=#183 id=183 data-nosnippet>183</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#184 id=184 data-nosnippet>184</a>    ///
<a href=#185 id=185 data-nosnippet>185</a>    /// # Arguments:
<a href=#186 id=186 data-nosnippet>186</a>    ///
<a href=#187 id=187 data-nosnippet>187</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#188 id=188 data-nosnippet>188</a>    /// * `object`: is a reference to the target object.
<a href=#189 id=189 data-nosnippet>189</a>    /// * `val`: is the new metadata value to be stored.
<a href=#190 id=190 data-nosnippet>190</a>    /// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.
<a href=#191 id=191 data-nosnippet>191</a>    ///
<a href=#192 id=192 data-nosnippet>192</a>    /// # Safety
<a href=#193 id=193 data-nosnippet>193</a>    /// This is a non-atomic store, thus not thread-safe.
<a href=#194 id=194 data-nosnippet>194</a>    </span><span class="kw">unsafe fn </span>store_metadata&lt;T: MetadataValue&gt;(
<a href=#195 id=195 data-nosnippet>195</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#196 id=196 data-nosnippet>196</a>        object: ObjectReference,
<a href=#197 id=197 data-nosnippet>197</a>        val: T,
<a href=#198 id=198 data-nosnippet>198</a>        mask: <span class="prelude-ty">Option</span>&lt;T&gt;,
<a href=#199 id=199 data-nosnippet>199</a>    ) {
<a href=#200 id=200 data-nosnippet>200</a>        metadata_spec.store::&lt;T&gt;(object.to_header::&lt;VM&gt;(), val, mask)
<a href=#201 id=201 data-nosnippet>201</a>    }
<a href=#202 id=202 data-nosnippet>202</a>
<a href=#203 id=203 data-nosnippet>203</a>    <span class="doccomment">/// A function to atomically store a value to the specified per-object metadata.
<a href=#204 id=204 data-nosnippet>204</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#205 id=205 data-nosnippet>205</a>    ///
<a href=#206 id=206 data-nosnippet>206</a>    /// # Arguments:
<a href=#207 id=207 data-nosnippet>207</a>    ///
<a href=#208 id=208 data-nosnippet>208</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#209 id=209 data-nosnippet>209</a>    /// * `object`: is a reference to the target object.
<a href=#210 id=210 data-nosnippet>210</a>    /// * `val`: is the new metadata value to be stored.
<a href=#211 id=211 data-nosnippet>211</a>    /// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.
<a href=#212 id=212 data-nosnippet>212</a>    /// * `atomic_ordering`: is the optional atomic ordering for the store operation.
<a href=#213 id=213 data-nosnippet>213</a>    </span><span class="kw">fn </span>store_metadata_atomic&lt;T: MetadataValue&gt;(
<a href=#214 id=214 data-nosnippet>214</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#215 id=215 data-nosnippet>215</a>        object: ObjectReference,
<a href=#216 id=216 data-nosnippet>216</a>        val: T,
<a href=#217 id=217 data-nosnippet>217</a>        mask: <span class="prelude-ty">Option</span>&lt;T&gt;,
<a href=#218 id=218 data-nosnippet>218</a>        ordering: Ordering,
<a href=#219 id=219 data-nosnippet>219</a>    ) {
<a href=#220 id=220 data-nosnippet>220</a>        metadata_spec.store_atomic::&lt;T&gt;(object.to_header::&lt;VM&gt;(), val, mask, ordering)
<a href=#221 id=221 data-nosnippet>221</a>    }
<a href=#222 id=222 data-nosnippet>222</a>
<a href=#223 id=223 data-nosnippet>223</a>    <span class="doccomment">/// A function to atomically compare-and-exchange the specified per-object metadata's content.
<a href=#224 id=224 data-nosnippet>224</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#225 id=225 data-nosnippet>225</a>    /// Returns `true` if the operation is successful, and `false` otherwise.
<a href=#226 id=226 data-nosnippet>226</a>    ///
<a href=#227 id=227 data-nosnippet>227</a>    /// # Arguments:
<a href=#228 id=228 data-nosnippet>228</a>    ///
<a href=#229 id=229 data-nosnippet>229</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#230 id=230 data-nosnippet>230</a>    /// * `object`: is a reference to the target object.
<a href=#231 id=231 data-nosnippet>231</a>    /// * `old_val`: is the expected current value of the metadata.
<a href=#232 id=232 data-nosnippet>232</a>    /// * `new_val`: is the new metadata value to be stored if the compare-and-exchange operation is successful.
<a href=#233 id=233 data-nosnippet>233</a>    /// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.
<a href=#234 id=234 data-nosnippet>234</a>    /// * `success_order`: is the atomic ordering used if the operation is successful.
<a href=#235 id=235 data-nosnippet>235</a>    /// * `failure_order`: is the atomic ordering used if the operation fails.
<a href=#236 id=236 data-nosnippet>236</a>    </span><span class="kw">fn </span>compare_exchange_metadata&lt;T: MetadataValue&gt;(
<a href=#237 id=237 data-nosnippet>237</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#238 id=238 data-nosnippet>238</a>        object: ObjectReference,
<a href=#239 id=239 data-nosnippet>239</a>        old_val: T,
<a href=#240 id=240 data-nosnippet>240</a>        new_val: T,
<a href=#241 id=241 data-nosnippet>241</a>        mask: <span class="prelude-ty">Option</span>&lt;T&gt;,
<a href=#242 id=242 data-nosnippet>242</a>        success_order: Ordering,
<a href=#243 id=243 data-nosnippet>243</a>        failure_order: Ordering,
<a href=#244 id=244 data-nosnippet>244</a>    ) -&gt; std::result::Result&lt;T, T&gt; {
<a href=#245 id=245 data-nosnippet>245</a>        metadata_spec.compare_exchange::&lt;T&gt;(
<a href=#246 id=246 data-nosnippet>246</a>            object.to_header::&lt;VM&gt;(),
<a href=#247 id=247 data-nosnippet>247</a>            old_val,
<a href=#248 id=248 data-nosnippet>248</a>            new_val,
<a href=#249 id=249 data-nosnippet>249</a>            mask,
<a href=#250 id=250 data-nosnippet>250</a>            success_order,
<a href=#251 id=251 data-nosnippet>251</a>            failure_order,
<a href=#252 id=252 data-nosnippet>252</a>        )
<a href=#253 id=253 data-nosnippet>253</a>    }
<a href=#254 id=254 data-nosnippet>254</a>
<a href=#255 id=255 data-nosnippet>255</a>    <span class="doccomment">/// A function to atomically perform an add operation on the specified per-object metadata's content.
<a href=#256 id=256 data-nosnippet>256</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#257 id=257 data-nosnippet>257</a>    /// This is a wrapping add.
<a href=#258 id=258 data-nosnippet>258</a>    /// # Returns the old metadata value.
<a href=#259 id=259 data-nosnippet>259</a>    ///
<a href=#260 id=260 data-nosnippet>260</a>    /// # Arguments:
<a href=#261 id=261 data-nosnippet>261</a>    ///
<a href=#262 id=262 data-nosnippet>262</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#263 id=263 data-nosnippet>263</a>    /// * `object`: is a reference to the target object.
<a href=#264 id=264 data-nosnippet>264</a>    /// * `val`: is the value to be added to the current value of the metadata.
<a href=#265 id=265 data-nosnippet>265</a>    /// * `order`: is the atomic ordering of the fetch-and-add operation.
<a href=#266 id=266 data-nosnippet>266</a>    </span><span class="kw">fn </span>fetch_add_metadata&lt;T: MetadataValue&gt;(
<a href=#267 id=267 data-nosnippet>267</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#268 id=268 data-nosnippet>268</a>        object: ObjectReference,
<a href=#269 id=269 data-nosnippet>269</a>        val: T,
<a href=#270 id=270 data-nosnippet>270</a>        order: Ordering,
<a href=#271 id=271 data-nosnippet>271</a>    ) -&gt; T {
<a href=#272 id=272 data-nosnippet>272</a>        metadata_spec.fetch_add::&lt;T&gt;(object.to_header::&lt;VM&gt;(), val, order)
<a href=#273 id=273 data-nosnippet>273</a>    }
<a href=#274 id=274 data-nosnippet>274</a>
<a href=#275 id=275 data-nosnippet>275</a>    <span class="doccomment">/// A function to atomically perform a subtract operation on the specified per-object metadata's content.
<a href=#276 id=276 data-nosnippet>276</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#277 id=277 data-nosnippet>277</a>    /// This is a wrapping sub.
<a href=#278 id=278 data-nosnippet>278</a>    /// Returns the old metadata value.
<a href=#279 id=279 data-nosnippet>279</a>    ///
<a href=#280 id=280 data-nosnippet>280</a>    /// # Arguments:
<a href=#281 id=281 data-nosnippet>281</a>    ///
<a href=#282 id=282 data-nosnippet>282</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#283 id=283 data-nosnippet>283</a>    /// * `object`: is a reference to the target object.
<a href=#284 id=284 data-nosnippet>284</a>    /// * `val`: is the value to be subtracted from the current value of the metadata.
<a href=#285 id=285 data-nosnippet>285</a>    /// * `order`: is the atomic ordering of the fetch-and-add operation.
<a href=#286 id=286 data-nosnippet>286</a>    </span><span class="kw">fn </span>fetch_sub_metadata&lt;T: MetadataValue&gt;(
<a href=#287 id=287 data-nosnippet>287</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#288 id=288 data-nosnippet>288</a>        object: ObjectReference,
<a href=#289 id=289 data-nosnippet>289</a>        val: T,
<a href=#290 id=290 data-nosnippet>290</a>        order: Ordering,
<a href=#291 id=291 data-nosnippet>291</a>    ) -&gt; T {
<a href=#292 id=292 data-nosnippet>292</a>        metadata_spec.fetch_sub::&lt;T&gt;(object.to_header::&lt;VM&gt;(), val, order)
<a href=#293 id=293 data-nosnippet>293</a>    }
<a href=#294 id=294 data-nosnippet>294</a>
<a href=#295 id=295 data-nosnippet>295</a>    <span class="doccomment">/// A function to atomically perform a bit-and operation on the specified per-object metadata's content.
<a href=#296 id=296 data-nosnippet>296</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#297 id=297 data-nosnippet>297</a>    /// Returns the old metadata value.
<a href=#298 id=298 data-nosnippet>298</a>    ///
<a href=#299 id=299 data-nosnippet>299</a>    /// # Arguments:
<a href=#300 id=300 data-nosnippet>300</a>    ///
<a href=#301 id=301 data-nosnippet>301</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#302 id=302 data-nosnippet>302</a>    /// * `object`: is a reference to the target object.
<a href=#303 id=303 data-nosnippet>303</a>    /// * `val`: is the value to bit-and with the current value of the metadata.
<a href=#304 id=304 data-nosnippet>304</a>    /// * `order`: is the atomic ordering of the fetch-and-add operation.
<a href=#305 id=305 data-nosnippet>305</a>    </span><span class="kw">fn </span>fetch_and_metadata&lt;T: MetadataValue&gt;(
<a href=#306 id=306 data-nosnippet>306</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#307 id=307 data-nosnippet>307</a>        object: ObjectReference,
<a href=#308 id=308 data-nosnippet>308</a>        val: T,
<a href=#309 id=309 data-nosnippet>309</a>        order: Ordering,
<a href=#310 id=310 data-nosnippet>310</a>    ) -&gt; T {
<a href=#311 id=311 data-nosnippet>311</a>        metadata_spec.fetch_and::&lt;T&gt;(object.to_header::&lt;VM&gt;(), val, order)
<a href=#312 id=312 data-nosnippet>312</a>    }
<a href=#313 id=313 data-nosnippet>313</a>
<a href=#314 id=314 data-nosnippet>314</a>    <span class="doccomment">/// A function to atomically perform a bit-or operation on the specified per-object metadata's content.
<a href=#315 id=315 data-nosnippet>315</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#316 id=316 data-nosnippet>316</a>    /// Returns the old metadata value.
<a href=#317 id=317 data-nosnippet>317</a>    ///
<a href=#318 id=318 data-nosnippet>318</a>    /// # Arguments:
<a href=#319 id=319 data-nosnippet>319</a>    ///
<a href=#320 id=320 data-nosnippet>320</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#321 id=321 data-nosnippet>321</a>    /// * `object`: is a reference to the target object.
<a href=#322 id=322 data-nosnippet>322</a>    /// * `val`: is the value to bit-or with the current value of the metadata.
<a href=#323 id=323 data-nosnippet>323</a>    /// * `order`: is the atomic ordering of the fetch-and-add operation.
<a href=#324 id=324 data-nosnippet>324</a>    </span><span class="kw">fn </span>fetch_or_metadata&lt;T: MetadataValue&gt;(
<a href=#325 id=325 data-nosnippet>325</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#326 id=326 data-nosnippet>326</a>        object: ObjectReference,
<a href=#327 id=327 data-nosnippet>327</a>        val: T,
<a href=#328 id=328 data-nosnippet>328</a>        order: Ordering,
<a href=#329 id=329 data-nosnippet>329</a>    ) -&gt; T {
<a href=#330 id=330 data-nosnippet>330</a>        metadata_spec.fetch_or::&lt;T&gt;(object.to_header::&lt;VM&gt;(), val, order)
<a href=#331 id=331 data-nosnippet>331</a>    }
<a href=#332 id=332 data-nosnippet>332</a>
<a href=#333 id=333 data-nosnippet>333</a>    <span class="doccomment">/// A function to atomically perform an update operation on the specified per-object metadata's content.
<a href=#334 id=334 data-nosnippet>334</a>    /// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
<a href=#335 id=335 data-nosnippet>335</a>    /// The semantics of this method are the same as the `fetch_update()` on Rust atomic types.
<a href=#336 id=336 data-nosnippet>336</a>    ///
<a href=#337 id=337 data-nosnippet>337</a>    /// # Arguments:
<a href=#338 id=338 data-nosnippet>338</a>    ///
<a href=#339 id=339 data-nosnippet>339</a>    /// * `metadata_spec`: is the header metadata spec that tries to perform the operation.
<a href=#340 id=340 data-nosnippet>340</a>    /// * `object`: is a reference to the target object.
<a href=#341 id=341 data-nosnippet>341</a>    /// * `val`: is the value to bit-and with the current value of the metadata.
<a href=#342 id=342 data-nosnippet>342</a>    /// * `order`: is the atomic ordering of the fetch-and-add operation.
<a href=#343 id=343 data-nosnippet>343</a>    ///
<a href=#344 id=344 data-nosnippet>344</a>    /// # Returns the old metadata value.
<a href=#345 id=345 data-nosnippet>345</a>    </span><span class="kw">fn </span>fetch_update_metadata&lt;T: MetadataValue, F: FnMut(T) -&gt; <span class="prelude-ty">Option</span>&lt;T&gt; + Copy&gt;(
<a href=#346 id=346 data-nosnippet>346</a>        metadata_spec: <span class="kw-2">&amp;</span>HeaderMetadataSpec,
<a href=#347 id=347 data-nosnippet>347</a>        object: ObjectReference,
<a href=#348 id=348 data-nosnippet>348</a>        set_order: Ordering,
<a href=#349 id=349 data-nosnippet>349</a>        fetch_order: Ordering,
<a href=#350 id=350 data-nosnippet>350</a>        f: F,
<a href=#351 id=351 data-nosnippet>351</a>    ) -&gt; std::result::Result&lt;T, T&gt; {
<a href=#352 id=352 data-nosnippet>352</a>        metadata_spec.fetch_update::&lt;T, F&gt;(object.to_header::&lt;VM&gt;(), set_order, fetch_order, f)
<a href=#353 id=353 data-nosnippet>353</a>    }
<a href=#354 id=354 data-nosnippet>354</a>
<a href=#355 id=355 data-nosnippet>355</a>    <span class="doccomment">/// Copy an object and return the address of the new object. Usually in the implementation of this method,
<a href=#356 id=356 data-nosnippet>356</a>    /// `alloc_copy()` and `post_copy()` from [`GCWorkerCopyContext`](util/copy/struct.GCWorkerCopyContext.html)
<a href=#357 id=357 data-nosnippet>357</a>    /// are used for copying.
<a href=#358 id=358 data-nosnippet>358</a>    ///
<a href=#359 id=359 data-nosnippet>359</a>    /// Arguments:
<a href=#360 id=360 data-nosnippet>360</a>    /// * `from`: The address of the object to be copied.
<a href=#361 id=361 data-nosnippet>361</a>    /// * `semantics`: The copy semantic to use.
<a href=#362 id=362 data-nosnippet>362</a>    /// * `copy_context`: The `GCWorkerCopyContext` for the GC thread.
<a href=#363 id=363 data-nosnippet>363</a>    </span><span class="kw">fn </span>copy(
<a href=#364 id=364 data-nosnippet>364</a>        from: ObjectReference,
<a href=#365 id=365 data-nosnippet>365</a>        semantics: CopySemantics,
<a href=#366 id=366 data-nosnippet>366</a>        copy_context: <span class="kw-2">&amp;mut </span>GCWorkerCopyContext&lt;VM&gt;,
<a href=#367 id=367 data-nosnippet>367</a>    ) -&gt; ObjectReference;
<a href=#368 id=368 data-nosnippet>368</a>
<a href=#369 id=369 data-nosnippet>369</a>    <span class="doccomment">/// Copy an object. This is required
<a href=#370 id=370 data-nosnippet>370</a>    /// for delayed-copy collectors such as compacting collectors. During the
<a href=#371 id=371 data-nosnippet>371</a>    /// collection, MMTk reserves a region in the heap for an object as per
<a href=#372 id=372 data-nosnippet>372</a>    /// requirements found from `ObjectModel` and then asks `ObjectModel` to
<a href=#373 id=373 data-nosnippet>373</a>    /// determine what the object's reference will be post-copy. Return the address
<a href=#374 id=374 data-nosnippet>374</a>    /// past the end of the copied object.
<a href=#375 id=375 data-nosnippet>375</a>    ///
<a href=#376 id=376 data-nosnippet>376</a>    /// Arguments:
<a href=#377 id=377 data-nosnippet>377</a>    /// * `from`: The address of the object to be copied.
<a href=#378 id=378 data-nosnippet>378</a>    /// * `to`: The target location.
<a href=#379 id=379 data-nosnippet>379</a>    /// * `region: The start of the region that was reserved for this object.
<a href=#380 id=380 data-nosnippet>380</a>    </span><span class="kw">fn </span>copy_to(from: ObjectReference, to: ObjectReference, region: Address) -&gt; Address;
<a href=#381 id=381 data-nosnippet>381</a>
<a href=#382 id=382 data-nosnippet>382</a>    <span class="doccomment">/// Return the reference that an object will be referred to after it is copied
<a href=#383 id=383 data-nosnippet>383</a>    /// to the specified region. Used in delayed-copy collectors such as compacting
<a href=#384 id=384 data-nosnippet>384</a>    /// collectors.
<a href=#385 id=385 data-nosnippet>385</a>    ///
<a href=#386 id=386 data-nosnippet>386</a>    /// Arguments:
<a href=#387 id=387 data-nosnippet>387</a>    /// * `from`: The object to be copied.
<a href=#388 id=388 data-nosnippet>388</a>    /// * `to`: The start of the region to be copied to.
<a href=#389 id=389 data-nosnippet>389</a>    </span><span class="kw">fn </span>get_reference_when_copied_to(from: ObjectReference, to: Address) -&gt; ObjectReference;
<a href=#390 id=390 data-nosnippet>390</a>
<a href=#391 id=391 data-nosnippet>391</a>    <span class="doccomment">/// Return the size used by an object.
<a href=#392 id=392 data-nosnippet>392</a>    ///
<a href=#393 id=393 data-nosnippet>393</a>    /// Arguments:
<a href=#394 id=394 data-nosnippet>394</a>    /// * `object`: The object to be queried.
<a href=#395 id=395 data-nosnippet>395</a>    </span><span class="kw">fn </span>get_current_size(object: ObjectReference) -&gt; usize;
<a href=#396 id=396 data-nosnippet>396</a>
<a href=#397 id=397 data-nosnippet>397</a>    <span class="doccomment">/// Return the size when an object is copied.
<a href=#398 id=398 data-nosnippet>398</a>    ///
<a href=#399 id=399 data-nosnippet>399</a>    /// Arguments:
<a href=#400 id=400 data-nosnippet>400</a>    /// * `object`: The object to be queried.
<a href=#401 id=401 data-nosnippet>401</a>    </span><span class="kw">fn </span>get_size_when_copied(object: ObjectReference) -&gt; usize;
<a href=#402 id=402 data-nosnippet>402</a>
<a href=#403 id=403 data-nosnippet>403</a>    <span class="doccomment">/// Return the alignment when an object is copied.
<a href=#404 id=404 data-nosnippet>404</a>    ///
<a href=#405 id=405 data-nosnippet>405</a>    /// Arguments:
<a href=#406 id=406 data-nosnippet>406</a>    /// * `object`: The object to be queried.
<a href=#407 id=407 data-nosnippet>407</a>    </span><span class="kw">fn </span>get_align_when_copied(object: ObjectReference) -&gt; usize;
<a href=#408 id=408 data-nosnippet>408</a>
<a href=#409 id=409 data-nosnippet>409</a>    <span class="doccomment">/// Return the alignment offset when an object is copied.
<a href=#410 id=410 data-nosnippet>410</a>    ///
<a href=#411 id=411 data-nosnippet>411</a>    /// Arguments:
<a href=#412 id=412 data-nosnippet>412</a>    /// * `object`: The object to be queried.
<a href=#413 id=413 data-nosnippet>413</a>    </span><span class="kw">fn </span>get_align_offset_when_copied(object: ObjectReference) -&gt; usize;
<a href=#414 id=414 data-nosnippet>414</a>
<a href=#415 id=415 data-nosnippet>415</a>    <span class="doccomment">/// Get the type descriptor for an object.
<a href=#416 id=416 data-nosnippet>416</a>    ///
<a href=#417 id=417 data-nosnippet>417</a>    /// FIXME: Do we need this? If so, determine lifetime, return byte[]
<a href=#418 id=418 data-nosnippet>418</a>    ///
<a href=#419 id=419 data-nosnippet>419</a>    /// Arguments:
<a href=#420 id=420 data-nosnippet>420</a>    /// * `reference`: The object to be queried.
<a href=#421 id=421 data-nosnippet>421</a>    </span><span class="kw">fn </span>get_type_descriptor(reference: ObjectReference) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">'static </span>[i8];
<a href=#422 id=422 data-nosnippet>422</a>
<a href=#423 id=423 data-nosnippet>423</a>    <span class="doccomment">/// This is the worst case expansion that can occur due to object size increasing while
<a href=#424 id=424 data-nosnippet>424</a>    /// copying. This constant is used to calculate whether a nursery has grown larger than the
<a href=#425 id=425 data-nosnippet>425</a>    /// mature space for generational plans.
<a href=#426 id=426 data-nosnippet>426</a>    </span><span class="kw">const </span>VM_WORST_CASE_COPY_EXPANSION: f64 = <span class="number">1.5</span>;
<a href=#427 id=427 data-nosnippet>427</a>
<a href=#428 id=428 data-nosnippet>428</a>    <span class="doccomment">/// If this is true, the binding guarantees that the object reference's raw address and the
<a href=#429 id=429 data-nosnippet>429</a>    /// object start are always the same address.  In other words, an object reference's raw
<a href=#430 id=430 data-nosnippet>430</a>    /// address is always equal to the return value of the `ref_to_object_start` method,
<a href=#431 id=431 data-nosnippet>431</a>    ///
<a href=#432 id=432 data-nosnippet>432</a>    /// This is a very strong guarantee, but it is also helpful for MMTk to
<a href=#433 id=433 data-nosnippet>433</a>    /// make some assumptions and optimize for this case.
<a href=#434 id=434 data-nosnippet>434</a>    /// If a binding sets this to true, and the related methods return inconsistent results, this is an undefined behavior. MMTk may panic
<a href=#435 id=435 data-nosnippet>435</a>    /// if any assertion catches this error, but may also fail silently.
<a href=#436 id=436 data-nosnippet>436</a>    </span><span class="kw">const </span>UNIFIED_OBJECT_REFERENCE_ADDRESS: bool = <span class="bool-val">false</span>;
<a href=#437 id=437 data-nosnippet>437</a>
<a href=#438 id=438 data-nosnippet>438</a>    <span class="doccomment">/// For our allocation result (object_start), the binding may have an offset between the allocation result
<a href=#439 id=439 data-nosnippet>439</a>    /// and the raw address of their object reference, i.e. object ref's raw address = object_start + offset.
<a href=#440 id=440 data-nosnippet>440</a>    /// The offset could be zero. The offset is not necessary to be
<a href=#441 id=441 data-nosnippet>441</a>    /// constant for all the objects. This constant defines the smallest possible offset.
<a href=#442 id=442 data-nosnippet>442</a>    ///
<a href=#443 id=443 data-nosnippet>443</a>    /// This is used as an indication for MMTk to predict where object references may point to in some algorithms.
<a href=#444 id=444 data-nosnippet>444</a>    ///
<a href=#445 id=445 data-nosnippet>445</a>    /// We should have the invariant:
<a href=#446 id=446 data-nosnippet>446</a>    /// * object ref &gt;= object_start + OBJECT_REF_OFFSET_LOWER_BOUND
<a href=#447 id=447 data-nosnippet>447</a>    </span><span class="kw">const </span>OBJECT_REF_OFFSET_LOWER_BOUND: isize;
<a href=#448 id=448 data-nosnippet>448</a>
<a href=#449 id=449 data-nosnippet>449</a>    <span class="doccomment">/// Return the lowest address of the storage associated with an object. This should be
<a href=#450 id=450 data-nosnippet>450</a>    /// the address that a binding gets by an allocation call ([`crate::memory_manager::alloc`]).
<a href=#451 id=451 data-nosnippet>451</a>    ///
<a href=#452 id=452 data-nosnippet>452</a>    /// Note that the return value needs to satisfy the invariant mentioned in the doc comment of
<a href=#453 id=453 data-nosnippet>453</a>    /// [`Self::OBJECT_REF_OFFSET_LOWER_BOUND`].
<a href=#454 id=454 data-nosnippet>454</a>    ///
<a href=#455 id=455 data-nosnippet>455</a>    /// Arguments:
<a href=#456 id=456 data-nosnippet>456</a>    /// * `object`: The object to be queried.
<a href=#457 id=457 data-nosnippet>457</a>    </span><span class="kw">fn </span>ref_to_object_start(object: ObjectReference) -&gt; Address;
<a href=#458 id=458 data-nosnippet>458</a>
<a href=#459 id=459 data-nosnippet>459</a>    <span class="doccomment">/// Return the header base address from an object reference. Any object header metadata
<a href=#460 id=460 data-nosnippet>460</a>    /// in the [`crate::vm::ObjectModel`] declares a piece of header metadata with an offset
<a href=#461 id=461 data-nosnippet>461</a>    /// from this address. If a binding does not use any header metadata for MMTk, this method
<a href=#462 id=462 data-nosnippet>462</a>    /// will not be called, and the binding can simply use `unreachable!()` for the method.
<a href=#463 id=463 data-nosnippet>463</a>    ///
<a href=#464 id=464 data-nosnippet>464</a>    /// Arguments:
<a href=#465 id=465 data-nosnippet>465</a>    /// * `object`: The object to be queried.
<a href=#466 id=466 data-nosnippet>466</a>    </span><span class="kw">fn </span>ref_to_header(object: ObjectReference) -&gt; Address;
<a href=#467 id=467 data-nosnippet>467</a>
<a href=#468 id=468 data-nosnippet>468</a>    <span class="doccomment">/// Dump debugging information for an object.
<a href=#469 id=469 data-nosnippet>469</a>    ///
<a href=#470 id=470 data-nosnippet>470</a>    /// Arguments:
<a href=#471 id=471 data-nosnippet>471</a>    /// * `object`: The object to be dumped.
<a href=#472 id=472 data-nosnippet>472</a>    </span><span class="kw">fn </span>dump_object(object: ObjectReference);
<a href=#473 id=473 data-nosnippet>473</a>
<a href=#474 id=474 data-nosnippet>474</a>    <span class="doccomment">/// Return if an object is valid from the runtime point of view. This is used
<a href=#475 id=475 data-nosnippet>475</a>    /// to debug MMTk.
<a href=#476 id=476 data-nosnippet>476</a>    </span><span class="kw">fn </span>is_object_sane(_object: ObjectReference) -&gt; bool {
<a href=#477 id=477 data-nosnippet>477</a>        <span class="bool-val">true
<a href=#478 id=478 data-nosnippet>478</a>    </span>}
<a href=#479 id=479 data-nosnippet>479</a>}
<a href=#480 id=480 data-nosnippet>480</a>
<a href=#481 id=481 data-nosnippet>481</a><span class="kw">pub mod </span>specs {
<a href=#482 id=482 data-nosnippet>482</a>    <span class="kw">use </span><span class="kw">crate</span>::util::constants::LOG_BITS_IN_WORD;
<a href=#483 id=483 data-nosnippet>483</a>    <span class="kw">use </span><span class="kw">crate</span>::util::constants::LOG_BYTES_IN_PAGE;
<a href=#484 id=484 data-nosnippet>484</a>    <span class="kw">use </span><span class="kw">crate</span>::util::constants::LOG_MIN_OBJECT_SIZE;
<a href=#485 id=485 data-nosnippet>485</a>    <span class="kw">use </span><span class="kw">crate</span>::util::metadata::side_metadata::<span class="kw-2">*</span>;
<a href=#486 id=486 data-nosnippet>486</a>    <span class="kw">use </span><span class="kw">crate</span>::util::metadata::{
<a href=#487 id=487 data-nosnippet>487</a>        header_metadata::HeaderMetadataSpec,
<a href=#488 id=488 data-nosnippet>488</a>        side_metadata::{SideMetadataOffset, SideMetadataSpec},
<a href=#489 id=489 data-nosnippet>489</a>        MetadataSpec,
<a href=#490 id=490 data-nosnippet>490</a>    };
<a href=#491 id=491 data-nosnippet>491</a>
<a href=#492 id=492 data-nosnippet>492</a>    <span class="comment">// This macro is invoked in define_vm_metadata_global_spec or define_vm_metadata_local_spec.
<a href=#493 id=493 data-nosnippet>493</a>    // Use those two to define a new VM metadata spec.
<a href=#494 id=494 data-nosnippet>494</a>    </span><span class="macro">macro_rules!</span> define_vm_metadata_spec {
<a href=#495 id=495 data-nosnippet>495</a>        ($(<span class="attr">#[<span class="macro-nonterminal">$outer</span>:meta]</span>)<span class="kw-2">*</span><span class="macro-nonterminal">$spec_name</span>: ident, <span class="macro-nonterminal">$is_global</span>: expr, <span class="macro-nonterminal">$log_num_bits</span>: expr, <span class="macro-nonterminal">$side_min_obj_size</span>: expr) =&gt; {
<a href=#496 id=496 data-nosnippet>496</a>            $(<span class="attr">#[<span class="macro-nonterminal">$outer</span>]</span>)*
<a href=#497 id=497 data-nosnippet>497</a>            <span class="kw">pub struct </span><span class="macro-nonterminal">$spec_name</span>(MetadataSpec);
<a href=#498 id=498 data-nosnippet>498</a>            <span class="kw">impl </span><span class="macro-nonterminal">$spec_name </span>{
<a href=#499 id=499 data-nosnippet>499</a>                <span class="doccomment">/// The number of bits (in log2) that are needed for the spec.
<a href=#500 id=500 data-nosnippet>500</a>                </span><span class="kw">pub const </span>LOG_NUM_BITS: usize = <span class="macro-nonterminal">$log_num_bits</span>;
<a href=#501 id=501 data-nosnippet>501</a>
<a href=#502 id=502 data-nosnippet>502</a>                <span class="doccomment">/// Whether this spec is global or local. For side metadata, the binding needs to make sure
<a href=#503 id=503 data-nosnippet>503</a>                /// global specs are laid out after another global spec, and local specs are laid
<a href=#504 id=504 data-nosnippet>504</a>                /// out after another local spec. Otherwise, there will be an assertion failure.
<a href=#505 id=505 data-nosnippet>505</a>                </span><span class="kw">pub const </span>IS_GLOBAL: bool = <span class="macro-nonterminal">$is_global</span>;
<a href=#506 id=506 data-nosnippet>506</a>
<a href=#507 id=507 data-nosnippet>507</a>                <span class="doccomment">/// Declare that the VM uses in-header metadata for this metadata type.
<a href=#508 id=508 data-nosnippet>508</a>                /// For the specification of the `bit_offset` argument, please refer to
<a href=#509 id=509 data-nosnippet>509</a>                /// the document of `[crate::util::metadata::header_metadata::HeaderMetadataSpec.bit_offset]`.
<a href=#510 id=510 data-nosnippet>510</a>                /// The binding needs to make sure that the bits used for a spec in the header do not conflict with
<a href=#511 id=511 data-nosnippet>511</a>                /// the bits of another spec (unless it is specified that some bits may be reused).
<a href=#512 id=512 data-nosnippet>512</a>                </span><span class="kw">pub const fn </span>in_header(bit_offset: isize) -&gt; <span class="self">Self </span>{
<a href=#513 id=513 data-nosnippet>513</a>                    <span class="self">Self</span>(MetadataSpec::InHeader(HeaderMetadataSpec {
<a href=#514 id=514 data-nosnippet>514</a>                        bit_offset,
<a href=#515 id=515 data-nosnippet>515</a>                        num_of_bits: <span class="number">1 </span>&lt;&lt; <span class="self">Self</span>::LOG_NUM_BITS,
<a href=#516 id=516 data-nosnippet>516</a>                    }))
<a href=#517 id=517 data-nosnippet>517</a>                }
<a href=#518 id=518 data-nosnippet>518</a>
<a href=#519 id=519 data-nosnippet>519</a>                <span class="doccomment">/// Declare that the VM uses side metadata for this metadata type,
<a href=#520 id=520 data-nosnippet>520</a>                /// and the side metadata is the first of its kind (global or local).
<a href=#521 id=521 data-nosnippet>521</a>                /// The first global or local side metadata should be declared with `side_first()`,
<a href=#522 id=522 data-nosnippet>522</a>                /// and the rest side metadata should be declared with `side_after()` after a defined
<a href=#523 id=523 data-nosnippet>523</a>                /// side metadata of the same kind (global or local). Logically, all the declarations
<a href=#524 id=524 data-nosnippet>524</a>                /// create two list of side metadata, one for global, and one for local.
<a href=#525 id=525 data-nosnippet>525</a>                </span><span class="kw">pub const fn </span>side_first() -&gt; <span class="self">Self </span>{
<a href=#526 id=526 data-nosnippet>526</a>                    <span class="kw">if </span><span class="self">Self</span>::IS_GLOBAL {
<a href=#527 id=527 data-nosnippet>527</a>                        <span class="self">Self</span>(MetadataSpec::OnSide(SideMetadataSpec {
<a href=#528 id=528 data-nosnippet>528</a>                            name: <span class="macro">stringify!</span>(<span class="macro-nonterminal">$spec_name</span>),
<a href=#529 id=529 data-nosnippet>529</a>                            is_global: <span class="self">Self</span>::IS_GLOBAL,
<a href=#530 id=530 data-nosnippet>530</a>                            offset: GLOBAL_SIDE_METADATA_VM_BASE_OFFSET,
<a href=#531 id=531 data-nosnippet>531</a>                            log_num_of_bits: <span class="self">Self</span>::LOG_NUM_BITS,
<a href=#532 id=532 data-nosnippet>532</a>                            log_bytes_in_region: <span class="macro-nonterminal">$side_min_obj_size </span><span class="kw">as </span>usize,
<a href=#533 id=533 data-nosnippet>533</a>                        }))
<a href=#534 id=534 data-nosnippet>534</a>                    } <span class="kw">else </span>{
<a href=#535 id=535 data-nosnippet>535</a>                        <span class="self">Self</span>(MetadataSpec::OnSide(SideMetadataSpec {
<a href=#536 id=536 data-nosnippet>536</a>                            name: <span class="macro">stringify!</span>(<span class="macro-nonterminal">$spec_name</span>),
<a href=#537 id=537 data-nosnippet>537</a>                            is_global: <span class="self">Self</span>::IS_GLOBAL,
<a href=#538 id=538 data-nosnippet>538</a>                            offset: LOCAL_SIDE_METADATA_VM_BASE_OFFSET,
<a href=#539 id=539 data-nosnippet>539</a>                            log_num_of_bits: <span class="self">Self</span>::LOG_NUM_BITS,
<a href=#540 id=540 data-nosnippet>540</a>                            log_bytes_in_region: <span class="macro-nonterminal">$side_min_obj_size </span><span class="kw">as </span>usize,
<a href=#541 id=541 data-nosnippet>541</a>                        }))
<a href=#542 id=542 data-nosnippet>542</a>                    }
<a href=#543 id=543 data-nosnippet>543</a>                }
<a href=#544 id=544 data-nosnippet>544</a>
<a href=#545 id=545 data-nosnippet>545</a>                <span class="doccomment">/// Declare that the VM uses side metadata for this metadata type,
<a href=#546 id=546 data-nosnippet>546</a>                /// and the side metadata should be laid out after the given side metadata spec.
<a href=#547 id=547 data-nosnippet>547</a>                /// The first global or local side metadata should be declared with `side_first()`,
<a href=#548 id=548 data-nosnippet>548</a>                /// and the rest side metadata should be declared with `side_after()` after a defined
<a href=#549 id=549 data-nosnippet>549</a>                /// side metadata of the same kind (global or local). Logically, all the declarations
<a href=#550 id=550 data-nosnippet>550</a>                /// create two list of side metadata, one for global, and one for local.
<a href=#551 id=551 data-nosnippet>551</a>                </span><span class="kw">pub const fn </span>side_after(spec: <span class="kw-2">&amp;</span>MetadataSpec) -&gt; <span class="self">Self </span>{
<a href=#552 id=552 data-nosnippet>552</a>                    <span class="macro">assert!</span>(spec.is_on_side());
<a href=#553 id=553 data-nosnippet>553</a>                    <span class="kw">let </span>side_spec = spec.extract_side_spec();
<a href=#554 id=554 data-nosnippet>554</a>                    <span class="macro">assert!</span>(side_spec.is_global == <span class="self">Self</span>::IS_GLOBAL);
<a href=#555 id=555 data-nosnippet>555</a>                    <span class="self">Self</span>(MetadataSpec::OnSide(SideMetadataSpec {
<a href=#556 id=556 data-nosnippet>556</a>                        name: <span class="macro">stringify!</span>(<span class="macro-nonterminal">$spec_name</span>),
<a href=#557 id=557 data-nosnippet>557</a>                        is_global: <span class="self">Self</span>::IS_GLOBAL,
<a href=#558 id=558 data-nosnippet>558</a>                        offset: SideMetadataOffset::layout_after(side_spec),
<a href=#559 id=559 data-nosnippet>559</a>                        log_num_of_bits: <span class="self">Self</span>::LOG_NUM_BITS,
<a href=#560 id=560 data-nosnippet>560</a>                        log_bytes_in_region: <span class="macro-nonterminal">$side_min_obj_size </span><span class="kw">as </span>usize,
<a href=#561 id=561 data-nosnippet>561</a>                    }))
<a href=#562 id=562 data-nosnippet>562</a>                }
<a href=#563 id=563 data-nosnippet>563</a>
<a href=#564 id=564 data-nosnippet>564</a>                <span class="doccomment">/// Return the inner `[crate::util::metadata::MetadataSpec]` for the metadata type.
<a href=#565 id=565 data-nosnippet>565</a>                </span><span class="kw">pub const fn </span>as_spec(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>MetadataSpec {
<a href=#566 id=566 data-nosnippet>566</a>                    <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="number">0
<a href=#567 id=567 data-nosnippet>567</a>                </span>}
<a href=#568 id=568 data-nosnippet>568</a>
<a href=#569 id=569 data-nosnippet>569</a>                <span class="doccomment">/// Return the number of bits for the metadata type.
<a href=#570 id=570 data-nosnippet>570</a>                </span><span class="kw">pub const fn </span>num_bits(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
<a href=#571 id=571 data-nosnippet>571</a>                    <span class="number">1 </span>&lt;&lt; <span class="macro-nonterminal">$log_num_bits
<a href=#572 id=572 data-nosnippet>572</a>                </span>}
<a href=#573 id=573 data-nosnippet>573</a>            }
<a href=#574 id=574 data-nosnippet>574</a>            <span class="kw">impl </span>std::ops::Deref <span class="kw">for </span><span class="macro-nonterminal">$spec_name </span>{
<a href=#575 id=575 data-nosnippet>575</a>                <span class="kw">type </span>Target = MetadataSpec;
<a href=#576 id=576 data-nosnippet>576</a>                <span class="kw">fn </span>deref(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="self">Self</span>::Target {
<a href=#577 id=577 data-nosnippet>577</a>                    <span class="self">self</span>.as_spec()
<a href=#578 id=578 data-nosnippet>578</a>                }
<a href=#579 id=579 data-nosnippet>579</a>            }
<a href=#580 id=580 data-nosnippet>580</a>        };
<a href=#581 id=581 data-nosnippet>581</a>    }
<a href=#582 id=582 data-nosnippet>582</a>
<a href=#583 id=583 data-nosnippet>583</a>    <span class="comment">// Log bit: 1 bit per object, global
<a href=#584 id=584 data-nosnippet>584</a>    </span><span class="macro">define_vm_metadata_spec!</span>(
<a href=#585 id=585 data-nosnippet>585</a>        <span class="doccomment">/// 1-bit global metadata to log an object.
<a href=#586 id=586 data-nosnippet>586</a>        </span>VMGlobalLogBitSpec,
<a href=#587 id=587 data-nosnippet>587</a>        <span class="bool-val">true</span>,
<a href=#588 id=588 data-nosnippet>588</a>        <span class="number">0</span>,
<a href=#589 id=589 data-nosnippet>589</a>        LOG_MIN_OBJECT_SIZE
<a href=#590 id=590 data-nosnippet>590</a>    );
<a href=#591 id=591 data-nosnippet>591</a>    <span class="comment">// Forwarding pointer: word size per object, local
<a href=#592 id=592 data-nosnippet>592</a>    </span><span class="macro">define_vm_metadata_spec!</span>(
<a href=#593 id=593 data-nosnippet>593</a>        <span class="doccomment">/// 1-word local metadata for spaces that may copy objects.
<a href=#594 id=594 data-nosnippet>594</a>        /// This metadata has to be stored in the header.
<a href=#595 id=595 data-nosnippet>595</a>        /// This metadata can be defined at a position within the object payload.
<a href=#596 id=596 data-nosnippet>596</a>        /// As a forwarding pointer is only stored in dead objects which is not
<a href=#597 id=597 data-nosnippet>597</a>        /// accessible by the language, it is okay that store a forwarding pointer overwrites object payload
<a href=#598 id=598 data-nosnippet>598</a>        </span>VMLocalForwardingPointerSpec,
<a href=#599 id=599 data-nosnippet>599</a>        <span class="bool-val">false</span>,
<a href=#600 id=600 data-nosnippet>600</a>        LOG_BITS_IN_WORD,
<a href=#601 id=601 data-nosnippet>601</a>        LOG_MIN_OBJECT_SIZE
<a href=#602 id=602 data-nosnippet>602</a>    );
<a href=#603 id=603 data-nosnippet>603</a>    <span class="comment">// Forwarding bits: 2 bits per object, local
<a href=#604 id=604 data-nosnippet>604</a>    </span><span class="macro">define_vm_metadata_spec!</span>(
<a href=#605 id=605 data-nosnippet>605</a>        <span class="doccomment">/// 2-bit local metadata for spaces that store a forwarding state for objects.
<a href=#606 id=606 data-nosnippet>606</a>        /// If this spec is defined in the header, it can be defined with a position of the lowest 2 bits in the forwarding pointer.
<a href=#607 id=607 data-nosnippet>607</a>        </span>VMLocalForwardingBitsSpec,
<a href=#608 id=608 data-nosnippet>608</a>        <span class="bool-val">false</span>,
<a href=#609 id=609 data-nosnippet>609</a>        <span class="number">1</span>,
<a href=#610 id=610 data-nosnippet>610</a>        LOG_MIN_OBJECT_SIZE
<a href=#611 id=611 data-nosnippet>611</a>    );
<a href=#612 id=612 data-nosnippet>612</a>    <span class="comment">// Mark bit: 1 bit per object, local
<a href=#613 id=613 data-nosnippet>613</a>    </span><span class="macro">define_vm_metadata_spec!</span>(
<a href=#614 id=614 data-nosnippet>614</a>        <span class="doccomment">/// 1-bit local metadata for spaces that need to mark an object.
<a href=#615 id=615 data-nosnippet>615</a>        </span>VMLocalMarkBitSpec,
<a href=#616 id=616 data-nosnippet>616</a>        <span class="bool-val">false</span>,
<a href=#617 id=617 data-nosnippet>617</a>        <span class="number">0</span>,
<a href=#618 id=618 data-nosnippet>618</a>        LOG_MIN_OBJECT_SIZE
<a href=#619 id=619 data-nosnippet>619</a>    );
<a href=#620 id=620 data-nosnippet>620</a>    <span class="comment">// Pinning bit: 1 bit per object, local
<a href=#621 id=621 data-nosnippet>621</a>    </span><span class="macro">define_vm_metadata_spec!</span>(
<a href=#622 id=622 data-nosnippet>622</a>        <span class="doccomment">/// 1-bit local metadata for spaces that support pinning.
<a href=#623 id=623 data-nosnippet>623</a>        </span>VMLocalPinningBitSpec,
<a href=#624 id=624 data-nosnippet>624</a>        <span class="bool-val">false</span>,
<a href=#625 id=625 data-nosnippet>625</a>        <span class="number">0</span>,
<a href=#626 id=626 data-nosnippet>626</a>        LOG_MIN_OBJECT_SIZE
<a href=#627 id=627 data-nosnippet>627</a>    );
<a href=#628 id=628 data-nosnippet>628</a>    <span class="comment">// Mark&amp;nursery bits for LOS: 2 bit per page, local
<a href=#629 id=629 data-nosnippet>629</a>    </span><span class="macro">define_vm_metadata_spec!</span>(
<a href=#630 id=630 data-nosnippet>630</a>        <span class="doccomment">/// 2-bits local metadata for the large object space. The two bits serve as
<a href=#631 id=631 data-nosnippet>631</a>        /// the mark bit and the nursery bit.
<a href=#632 id=632 data-nosnippet>632</a>        </span>VMLocalLOSMarkNurserySpec,
<a href=#633 id=633 data-nosnippet>633</a>        <span class="bool-val">false</span>,
<a href=#634 id=634 data-nosnippet>634</a>        <span class="number">1</span>,
<a href=#635 id=635 data-nosnippet>635</a>        LOG_BYTES_IN_PAGE
<a href=#636 id=636 data-nosnippet>636</a>    );
<a href=#637 id=637 data-nosnippet>637</a>}</code></pre></div></section></main></body></html>