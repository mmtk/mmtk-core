<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/policy/marksweepspace/native_ms/block.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>block.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../../../normalize.css"><link rel="stylesheet" href="../../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../../../ayu.css" disabled><link rel="stylesheet" href="../../../../../dark.css" disabled><link rel="stylesheet" href="../../../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../../../storage.js"></script><script defer src="../../../../../source-script.js"></script><script defer src="../../../../../source-files.js"></script><script defer src="../../../../../main.js"></script><noscript><link rel="stylesheet" href="../../../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../../../../mmtk/index.html"><img class="rust-logo" src="../../../../../rust-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
</pre><pre class="rust"><code><span class="comment">// adapted from Immix

</span><span class="kw">use </span>atomic::Ordering;

<span class="kw">use </span><span class="kw">super</span>::BlockList;
<span class="kw">use </span><span class="kw">super</span>::MarkSweepSpace;
<span class="kw">use </span><span class="kw">crate</span>::util::heap::chunk_map::<span class="kw-2">*</span>;
<span class="kw">use </span><span class="kw">crate</span>::util::linear_scan::Region;
<span class="kw">use </span><span class="kw">crate</span>::vm::ObjectModel;
<span class="kw">use crate</span>::{
    util::{
        metadata::side_metadata::SideMetadataSpec, Address, ObjectReference, OpaquePointer,
        VMThread,
    },
    vm::VMBinding,
};

<span class="kw">use </span>std::num::NonZeroUsize;

<span class="doccomment">/// A 64KB region for MiMalloc.
/// This is also known as MiMalloc page. We try to avoid getting confused with the OS 4K page. So we call it block.
/// This type always holds a non-zero address to refer to a block. The underlying `NonZeroUsize` type ensures the
/// size of `Option&lt;Block&gt;` is the same as `Block` itself.
</span><span class="comment">// TODO: If we actually use the first block, we would need to turn the type into `Block(Address)`, and use `None` and
// `Block(Address::ZERO)` to differentiate those.
</span><span class="attribute">#[derive(Clone, Copy, PartialOrd, PartialEq)]
#[repr(transparent)]
</span><span class="kw">pub struct </span>Block(NonZeroUsize);

<span class="kw">impl </span>std::fmt::Debug <span class="kw">for </span>Block {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>std::fmt::Formatter) -&gt; std::fmt::Result {
        <span class="macro">write!</span>(f, <span class="string">&quot;Block(0x{:x})&quot;</span>, <span class="self">self</span>.<span class="number">0</span>)
    }
}

<span class="kw">impl </span>Region <span class="kw">for </span>Block {
    <span class="kw">const </span>LOG_BYTES: usize = <span class="number">16</span>;

    <span class="kw">fn </span>from_aligned_address(address: Address) -&gt; <span class="self">Self </span>{
        <span class="macro">debug_assert!</span>(address.is_aligned_to(<span class="self">Self</span>::BYTES));
        <span class="macro">debug_assert!</span>(!address.is_zero());
        <span class="self">Self</span>(<span class="kw">unsafe </span>{ NonZeroUsize::new_unchecked(address.as_usize()) })
    }

    <span class="kw">fn </span>start(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Address {
        <span class="kw">unsafe </span>{ Address::from_usize(<span class="self">self</span>.<span class="number">0</span>.get()) }
    }
}

<span class="kw">impl </span>Block {
    <span class="kw">pub const </span>METADATA_SPECS: [SideMetadataSpec; <span class="number">7</span>] = [
        <span class="self">Self</span>::MARK_TABLE,
        <span class="self">Self</span>::NEXT_BLOCK_TABLE,
        <span class="self">Self</span>::PREV_BLOCK_TABLE,
        <span class="self">Self</span>::FREE_LIST_TABLE,
        <span class="self">Self</span>::SIZE_TABLE,
        <span class="self">Self</span>::BLOCK_LIST_TABLE,
        <span class="self">Self</span>::TLS_TABLE,
    ];

    <span class="doccomment">/// Block mark table (side)
    </span><span class="kw">pub const </span>MARK_TABLE: SideMetadataSpec =
        <span class="kw">crate</span>::util::metadata::side_metadata::spec_defs::MS_BLOCK_MARK;

    <span class="kw">pub const </span>NEXT_BLOCK_TABLE: SideMetadataSpec =
        <span class="kw">crate</span>::util::metadata::side_metadata::spec_defs::MS_BLOCK_NEXT;

    <span class="kw">pub const </span>PREV_BLOCK_TABLE: SideMetadataSpec =
        <span class="kw">crate</span>::util::metadata::side_metadata::spec_defs::MS_BLOCK_PREV;

    <span class="kw">pub const </span>FREE_LIST_TABLE: SideMetadataSpec =
        <span class="kw">crate</span>::util::metadata::side_metadata::spec_defs::MS_FREE;

    <span class="comment">// needed for non GC context
    </span><span class="attribute">#[cfg(feature = <span class="string">&quot;malloc_native_mimalloc&quot;</span>)]
    </span><span class="kw">pub const </span>LOCAL_FREE_LIST_TABLE: SideMetadataSpec =
        <span class="kw">crate</span>::util::metadata::side_metadata::spec_defs::MS_LOCAL_FREE;

    <span class="attribute">#[cfg(feature = <span class="string">&quot;malloc_native_mimalloc&quot;</span>)]
    </span><span class="kw">pub const </span>THREAD_FREE_LIST_TABLE: SideMetadataSpec =
        <span class="kw">crate</span>::util::metadata::side_metadata::spec_defs::MS_THREAD_FREE;

    <span class="kw">pub const </span>SIZE_TABLE: SideMetadataSpec =
        <span class="kw">crate</span>::util::metadata::side_metadata::spec_defs::MS_BLOCK_SIZE;

    <span class="kw">pub const </span>BLOCK_LIST_TABLE: SideMetadataSpec =
        <span class="kw">crate</span>::util::metadata::side_metadata::spec_defs::MS_BLOCK_LIST;

    <span class="kw">pub const </span>TLS_TABLE: SideMetadataSpec =
        <span class="kw">crate</span>::util::metadata::side_metadata::spec_defs::MS_BLOCK_TLS;

    <span class="kw">pub fn </span>load_free_list(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Address {
        <span class="kw">unsafe </span>{ Address::from_usize(Block::FREE_LIST_TABLE.load::&lt;usize&gt;(<span class="self">self</span>.start())) }
    }

    <span class="kw">pub fn </span>store_free_list(<span class="kw-2">&amp;</span><span class="self">self</span>, free_list: Address) {
        <span class="kw">unsafe </span>{ Block::FREE_LIST_TABLE.store::&lt;usize&gt;(<span class="self">self</span>.start(), free_list.as_usize()) }
    }

    <span class="attribute">#[cfg(feature = <span class="string">&quot;malloc_native_mimalloc&quot;</span>)]
    </span><span class="kw">pub fn </span>load_local_free_list(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Address {
        <span class="kw">unsafe </span>{ Address::from_usize(Block::LOCAL_FREE_LIST_TABLE.load::&lt;usize&gt;(<span class="self">self</span>.start())) }
    }

    <span class="attribute">#[cfg(feature = <span class="string">&quot;malloc_native_mimalloc&quot;</span>)]
    </span><span class="kw">pub fn </span>store_local_free_list(<span class="kw-2">&amp;</span><span class="self">self</span>, local_free: Address) {
        <span class="kw">unsafe </span>{ Block::LOCAL_FREE_LIST_TABLE.store::&lt;usize&gt;(<span class="self">self</span>.start(), local_free.as_usize()) }
    }

    <span class="attribute">#[cfg(feature = <span class="string">&quot;malloc_native_mimalloc&quot;</span>)]
    </span><span class="kw">pub fn </span>load_thread_free_list(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Address {
        <span class="kw">unsafe </span>{
            Address::from_usize(
                Block::THREAD_FREE_LIST_TABLE.load_atomic::&lt;usize&gt;(<span class="self">self</span>.start(), Ordering::SeqCst),
            )
        }
    }

    <span class="attribute">#[cfg(feature = <span class="string">&quot;malloc_native_mimalloc&quot;</span>)]
    </span><span class="kw">pub fn </span>store_thread_free_list(<span class="kw-2">&amp;</span><span class="self">self</span>, thread_free: Address) {
        <span class="kw">unsafe </span>{
            Block::THREAD_FREE_LIST_TABLE.store::&lt;usize&gt;(<span class="self">self</span>.start(), thread_free.as_usize())
        }
    }

    <span class="attribute">#[cfg(feature = <span class="string">&quot;malloc_native_mimalloc&quot;</span>)]
    </span><span class="kw">pub fn </span>cas_thread_free_list(<span class="kw-2">&amp;</span><span class="self">self</span>, old_thread_free: Address, new_thread_free: Address) -&gt; bool {
        Block::THREAD_FREE_LIST_TABLE
            .compare_exchange_atomic::&lt;usize&gt;(
                <span class="self">self</span>.start(),
                old_thread_free.as_usize(),
                new_thread_free.as_usize(),
                Ordering::SeqCst,
                Ordering::SeqCst,
            )
            .is_ok()
    }

    <span class="kw">pub fn </span>load_prev_block(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;Block&gt; {
        <span class="kw">let </span>prev = <span class="kw">unsafe </span>{ Block::PREV_BLOCK_TABLE.load::&lt;usize&gt;(<span class="self">self</span>.start()) };
        NonZeroUsize::new(prev).map(Block)
    }

    <span class="kw">pub fn </span>load_next_block(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;Block&gt; {
        <span class="kw">let </span>next = <span class="kw">unsafe </span>{ Block::NEXT_BLOCK_TABLE.load::&lt;usize&gt;(<span class="self">self</span>.start()) };
        NonZeroUsize::new(next).map(Block)
    }

    <span class="kw">pub fn </span>store_next_block(<span class="kw-2">&amp;</span><span class="self">self</span>, next: Block) {
        <span class="kw">unsafe </span>{
            Block::NEXT_BLOCK_TABLE.store::&lt;usize&gt;(<span class="self">self</span>.start(), next.start().as_usize());
        }
    }

    <span class="kw">pub fn </span>clear_next_block(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="kw">unsafe </span>{
            Block::NEXT_BLOCK_TABLE.store::&lt;usize&gt;(<span class="self">self</span>.start(), <span class="number">0</span>);
        }
    }

    <span class="kw">pub fn </span>store_prev_block(<span class="kw-2">&amp;</span><span class="self">self</span>, prev: Block) {
        <span class="kw">unsafe </span>{
            Block::PREV_BLOCK_TABLE.store::&lt;usize&gt;(<span class="self">self</span>.start(), prev.start().as_usize());
        }
    }

    <span class="kw">pub fn </span>clear_prev_block(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="kw">unsafe </span>{
            Block::PREV_BLOCK_TABLE.store::&lt;usize&gt;(<span class="self">self</span>.start(), <span class="number">0</span>);
        }
    }

    <span class="kw">pub fn </span>store_block_list(<span class="kw-2">&amp;</span><span class="self">self</span>, block_list: <span class="kw-2">&amp;</span>BlockList) {
        <span class="kw">let </span>block_list_usize: usize = block_list <span class="kw">as </span><span class="kw-2">*const </span>BlockList <span class="kw">as </span>usize;
        <span class="kw">unsafe </span>{
            Block::BLOCK_LIST_TABLE.store::&lt;usize&gt;(<span class="self">self</span>.start(), block_list_usize);
        }
    }

    <span class="kw">pub fn </span>load_block_list(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">*mut </span>BlockList {
        <span class="kw">let </span>block_list =
            Block::BLOCK_LIST_TABLE.load_atomic::&lt;usize&gt;(<span class="self">self</span>.start(), Ordering::SeqCst);
        block_list <span class="kw">as </span><span class="kw-2">*mut </span>BlockList
    }

    <span class="kw">pub fn </span>load_block_cell_size(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        Block::SIZE_TABLE.load_atomic::&lt;usize&gt;(<span class="self">self</span>.start(), Ordering::SeqCst)
    }

    <span class="kw">pub fn </span>store_block_cell_size(<span class="kw-2">&amp;</span><span class="self">self</span>, size: usize) {
        <span class="kw">unsafe </span>{ Block::SIZE_TABLE.store::&lt;usize&gt;(<span class="self">self</span>.start(), size) }
    }

    <span class="kw">pub fn </span>store_tls(<span class="kw-2">&amp;</span><span class="self">self</span>, tls: VMThread) {
        <span class="kw">let </span>tls_usize: usize = tls.<span class="number">0</span>.to_address().as_usize();
        <span class="kw">unsafe </span>{ Block::TLS_TABLE.store(<span class="self">self</span>.start(), tls_usize) }
    }

    <span class="kw">pub fn </span>load_tls(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; VMThread {
        <span class="kw">let </span>tls = Block::TLS_TABLE.load_atomic::&lt;usize&gt;(<span class="self">self</span>.start(), Ordering::SeqCst);
        VMThread(OpaquePointer::from_address(<span class="kw">unsafe </span>{
            Address::from_usize(tls)
        }))
    }

    <span class="kw">pub fn </span>has_free_cells(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        !<span class="self">self</span>.load_free_list().is_zero()
    }

    <span class="doccomment">/// Get block mark state.
    </span><span class="kw">pub fn </span>get_state(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; BlockState {
        <span class="kw">let </span>byte = <span class="self">Self</span>::MARK_TABLE.load_atomic::&lt;u8&gt;(<span class="self">self</span>.start(), Ordering::SeqCst);
        byte.into()
    }

    <span class="doccomment">/// Set block mark state.
    </span><span class="kw">pub fn </span>set_state(<span class="kw-2">&amp;</span><span class="self">self</span>, state: BlockState) {
        <span class="kw">let </span>state = u8::from(state);
        <span class="self">Self</span>::MARK_TABLE.store_atomic::&lt;u8&gt;(<span class="self">self</span>.start(), state, Ordering::SeqCst);
    }

    <span class="doccomment">/// Release this block if it is unmarked. Return true if the block is release.
    </span><span class="kw">pub fn </span>attempt_release&lt;VM: VMBinding&gt;(<span class="self">self</span>, space: <span class="kw-2">&amp;</span>MarkSweepSpace&lt;VM&gt;) -&gt; bool {
        <span class="kw">match </span><span class="self">self</span>.get_state() {
            BlockState::Unallocated =&gt; <span class="bool-val">false</span>,
            BlockState::Unmarked =&gt; {
                <span class="kw">unsafe </span>{
                    <span class="kw">let </span>block_list = <span class="kw">loop </span>{
                        <span class="kw">let </span>list = <span class="self">self</span>.load_block_list();
                        (<span class="kw-2">*</span>list).lock();
                        <span class="kw">if </span>list == <span class="self">self</span>.load_block_list() {
                            <span class="kw">break </span>list;
                        }
                        (<span class="kw-2">*</span>list).unlock();
                    };
                    (<span class="kw-2">*</span>block_list).remove(<span class="self">self</span>);
                    (<span class="kw-2">*</span>block_list).unlock();
                }
                space.release_block(<span class="self">self</span>);
                <span class="bool-val">true
            </span>}
            BlockState::Marked =&gt; {
                <span class="comment">// The block is live.
                </span><span class="bool-val">false
            </span>}
        }
    }

    <span class="doccomment">/// Sweep the block. This is done either lazily in the allocation phase, or eagerly at the end of a GC.
    </span><span class="kw">pub fn </span>sweep&lt;VM: VMBinding&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="comment">// The important point here is that we need to distinguish cell address, allocation address, and object reference.
        // We only know cell addresses here. We do not know the allocation address, and we also do not know the object reference.
        // The mark bit is set for object references, and we need to use the mark bit to decide whether a cell is live or not.

        // We haven&#39;t implemented for malloc/free cases, for which we do not have mark bit. We could use valid object bit instead.
        </span><span class="kw">if </span><span class="macro">cfg!</span>(feature = <span class="string">&quot;malloc_native_mimalloc&quot;</span>) {
            <span class="macro">unimplemented!</span>()
        }

        <span class="comment">// Check if we can treat it as the simple case: cell address === object reference.
        // If the binding does not use allocation offset, and they use the same allocation alignment which the cell size is aligned to,
        // then we have cell address === allocation address.
        // Furthermore, if the binding does not have an offset between allocation and object reference, then allocation address === cell address.
        </span><span class="kw">if </span>!VM::USE_ALLOCATION_OFFSET
            &amp;&amp; VM::MAX_ALIGNMENT == VM::MIN_ALIGNMENT
            &amp;&amp; <span class="kw">crate</span>::util::conversions::raw_is_aligned(
                <span class="self">self</span>.load_block_cell_size(),
                VM::MAX_ALIGNMENT,
            )
            &amp;&amp; VM::VMObjectModel::UNIFIED_OBJECT_REFERENCE_ADDRESS
        {
            <span class="comment">// In this case, we can use the simplest and the most efficicent sweep.
            </span><span class="self">self</span>.simple_sweep::&lt;VM&gt;()
        } <span class="kw">else </span>{
            <span class="comment">// Otherwise we fallback to a generic but slow sweep. This roughly has ~10% mutator overhead for lazy sweeping.
            </span><span class="self">self</span>.naive_brute_force_sweep::&lt;VM&gt;()
        }
    }

    <span class="doccomment">/// This implementation uses object reference and cell address interchangably. This is not correct for most cases.
    /// However, in certain cases, such as OpenJDK, this is correct, and efficient. See the sweep method for the invariants
    /// that we need to use this method correctly.
    </span><span class="kw">fn </span>simple_sweep&lt;VM: VMBinding&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="kw">let </span>cell_size = <span class="self">self</span>.load_block_cell_size();
        <span class="kw">let </span><span class="kw-2">mut </span>cell = <span class="self">self</span>.start();
        <span class="kw">let </span><span class="kw-2">mut </span>last = <span class="kw">unsafe </span>{ Address::zero() };
        <span class="kw">while </span>cell + cell_size &lt;= <span class="self">self</span>.start() + Block::BYTES {
            <span class="comment">// The invariants we checked earlier ensures that we can use cell and object reference interchangably
            // We may not really have an object in this cell, but if we do, this object reference is correct.
            </span><span class="kw">let </span>potential_object = ObjectReference::from_raw_address(cell);

            <span class="kw">if </span>!VM::VMObjectModel::LOCAL_MARK_BIT_SPEC
                .is_marked::&lt;VM&gt;(potential_object, Ordering::SeqCst)
            {
                <span class="comment">// clear VO bit if it is ever set. It is possible that the VO bit is never set for this cell (i.e. there was no object in this cell before this GC),
                // we unset the bit anyway.
                </span><span class="attribute">#[cfg(feature = <span class="string">&quot;vo_bit&quot;</span>)]
                </span><span class="kw">crate</span>::util::metadata::vo_bit::unset_vo_bit_nocheck::&lt;VM&gt;(potential_object);
                <span class="kw">unsafe </span>{
                    cell.store::&lt;Address&gt;(last);
                }
                last = cell;
            }
            cell += cell_size;
        }

        <span class="self">self</span>.store_free_list(last);
    }

    <span class="doccomment">/// This is a naive implementation that is inefficient but should be correct.
    /// In this implementation, we simply go through each possible object
    /// reference and see if it has the mark bit set. If we find mark bit, that means the cell is alive. If we didn&#39;t find
    /// the mark bit in the entire cell, it means the cell is dead.
    </span><span class="kw">fn </span>naive_brute_force_sweep&lt;VM: VMBinding&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="kw">use </span><span class="kw">crate</span>::util::constants::MIN_OBJECT_SIZE;

        <span class="comment">// Cell size for this block.
        </span><span class="kw">let </span>cell_size = <span class="self">self</span>.load_block_cell_size();
        <span class="comment">// Current cell
        </span><span class="kw">let </span><span class="kw-2">mut </span>cell = <span class="self">self</span>.start();
        <span class="comment">// Last free cell in the free list
        </span><span class="kw">let </span><span class="kw-2">mut </span>last = Address::ZERO;
        <span class="comment">// Current cursor
        </span><span class="kw">let </span><span class="kw-2">mut </span>cursor = cell;

        <span class="macro">debug!</span>(<span class="string">&quot;Sweep block {:?}, cell size {}&quot;</span>, <span class="self">self</span>, cell_size);

        <span class="kw">while </span>cell + cell_size &lt;= <span class="self">self</span>.end() {
            <span class="comment">// possible object ref
            </span><span class="kw">let </span>potential_object_ref = ObjectReference::from_raw_address(
                cursor + VM::VMObjectModel::OBJECT_REF_OFFSET_LOWER_BOUND,
            );
            <span class="macro">trace!</span>(
                <span class="string">&quot;{:?}: cell = {}, last cell in free list = {}, cursor = {}, potential object = {}&quot;</span>,
                <span class="self">self</span>,
                cell,
                last,
                cursor,
                potential_object_ref
            );

            <span class="kw">if </span>VM::VMObjectModel::LOCAL_MARK_BIT_SPEC
                .is_marked::&lt;VM&gt;(potential_object_ref, Ordering::SeqCst)
            {
                <span class="macro">debug!</span>(<span class="string">&quot;{:?} Live cell: {}&quot;</span>, <span class="self">self</span>, cell);
                <span class="comment">// If the mark bit is set, the cell is alive.
                // We directly jump to the end of the cell.
                </span>cell += cell_size;
                cursor = cell;
            } <span class="kw">else </span>{
                <span class="comment">// If the mark bit is not set, we don&#39;t know if the cell is alive or not. We keep search for the mark bit.
                </span>cursor += MIN_OBJECT_SIZE;

                <span class="kw">if </span>cursor &gt;= cell + cell_size {
                    <span class="comment">// We now stepped to the next cell. This means we did not find mark bit in the current cell, and we can add this cell to free list.
                    </span><span class="macro">debug!</span>(
                        <span class="string">&quot;{:?} Free cell: {}, last cell in freelist is {}&quot;</span>,
                        <span class="self">self</span>, cell, last
                    );

                    <span class="comment">// Clear VO bit: we don&#39;t know where the object reference actually is, so we bulk zero the cell.
                    </span><span class="attribute">#[cfg(feature = <span class="string">&quot;vo_bit&quot;</span>)]
                    </span><span class="kw">crate</span>::util::metadata::vo_bit::bzero_vo_bit(cell, cell_size);

                    <span class="comment">// store the previous cell to make the free list
                    </span><span class="macro">debug_assert!</span>(last.is_zero() || (last &gt;= <span class="self">self</span>.start() &amp;&amp; last &lt; <span class="self">self</span>.end()));
                    <span class="kw">unsafe </span>{
                        cell.store::&lt;Address&gt;(last);
                    }
                    last = cell;
                    cell += cell_size;
                    <span class="macro">debug_assert_eq!</span>(cursor, cell);
                }
            }
        }

        <span class="self">self</span>.store_free_list(last);
    }

    <span class="doccomment">/// Get the chunk containing the block.
    </span><span class="kw">pub fn </span>chunk(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Chunk {
        Chunk::from_unaligned_address(<span class="self">self</span>.start())
    }

    <span class="doccomment">/// Initialize a clean block after acquired from page-resource.
    </span><span class="kw">pub fn </span>init(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="self">self</span>.set_state(BlockState::Unmarked);
    }

    <span class="doccomment">/// Deinitalize a block before releasing.
    </span><span class="kw">pub fn </span>deinit(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="self">self</span>.set_state(BlockState::Unallocated);
    }
}

<span class="doccomment">/// The block allocation state.
</span><span class="attribute">#[derive(Debug, PartialEq, Clone, Copy)]
</span><span class="kw">pub enum </span>BlockState {
    <span class="doccomment">/// the block is not allocated.
    </span>Unallocated,
    <span class="doccomment">/// the block is allocated but not marked.
    </span>Unmarked,
    <span class="doccomment">/// the block is allocated and marked.
    </span>Marked,
}

<span class="kw">impl </span>BlockState {
    <span class="doccomment">/// Private constant
    </span><span class="kw">const </span>MARK_UNALLOCATED: u8 = <span class="number">0</span>;
    <span class="doccomment">/// Private constant
    </span><span class="kw">const </span>MARK_UNMARKED: u8 = u8::MAX;
    <span class="doccomment">/// Private constant
    </span><span class="kw">const </span>MARK_MARKED: u8 = u8::MAX - <span class="number">1</span>;
}

<span class="kw">impl </span>From&lt;u8&gt; <span class="kw">for </span>BlockState {
    <span class="kw">fn </span>from(state: u8) -&gt; <span class="self">Self </span>{
        <span class="kw">match </span>state {
            <span class="self">Self</span>::MARK_UNALLOCATED =&gt; BlockState::Unallocated,
            <span class="self">Self</span>::MARK_UNMARKED =&gt; BlockState::Unmarked,
            <span class="self">Self</span>::MARK_MARKED =&gt; BlockState::Marked,
            <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(),
        }
    }
}

<span class="kw">impl </span>From&lt;BlockState&gt; <span class="kw">for </span>u8 {
    <span class="kw">fn </span>from(state: BlockState) -&gt; <span class="self">Self </span>{
        <span class="kw">match </span>state {
            BlockState::Unallocated =&gt; BlockState::MARK_UNALLOCATED,
            BlockState::Unmarked =&gt; BlockState::MARK_UNMARKED,
            BlockState::Marked =&gt; BlockState::MARK_MARKED,
        }
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../../../" data-current-crate="mmtk" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>