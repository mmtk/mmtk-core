<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-specific methods for garbage collection."><title>Collection in mmtk::vm::collection - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0 (90b35a623 2024-11-26)" data-channel="1.83.0" data-search-js="search-f0d225181b97f9a4.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../../../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../mmtk/index.html">mmtk</a><span class="version">0.31.0-a1484548b16c459cd247cfcb159a5fb0ee82fe0e</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Collection</a></h2><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.block_for_gc" title="block_for_gc">block_for_gc</a></li><li><a href="#tymethod.resume_mutators" title="resume_mutators">resume_mutators</a></li><li><a href="#tymethod.spawn_gc_thread" title="spawn_gc_thread">spawn_gc_thread</a></li><li><a href="#tymethod.stop_all_mutators" title="stop_all_mutators">stop_all_mutators</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.create_gc_trigger" title="create_gc_trigger">create_gc_trigger</a></li><li><a href="#method.is_collection_enabled" title="is_collection_enabled">is_collection_enabled</a></li><li><a href="#method.out_of_memory" title="out_of_memory">out_of_memory</a></li><li><a href="#method.post_forwarding" title="post_forwarding">post_forwarding</a></li><li><a href="#method.schedule_finalization" title="schedule_finalization">schedule_finalization</a></li><li><a href="#method.vm_live_bytes" title="vm_live_bytes">vm_live_bytes</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In mmtk::<wbr>vm::<wbr>collection</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">mmtk</a>::<wbr><a href="../index.html">vm</a>::<wbr><a href="index.html">collection</a></span><h1>Trait <span class="trait">Collection</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/mmtk/vm/collection.rs.html#15-165">source</a> </span></div><pre class="rust item-decl"><code>pub trait Collection&lt;VM: <a class="trait" href="../trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    // Required methods
    fn <a href="#tymethod.stop_all_mutators" class="fn">stop_all_mutators</a>&lt;F&gt;(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, mutator_visitor: F)
       <span class="where">where F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;'static mut <a class="struct" href="../../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;)</span>;
<span class="item-spacer"></span>    fn <a href="#tymethod.resume_mutators" class="fn">resume_mutators</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>);
<span class="item-spacer"></span>    fn <a href="#tymethod.block_for_gc" class="fn">block_for_gc</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>);
<span class="item-spacer"></span>    fn <a href="#tymethod.spawn_gc_thread" class="fn">spawn_gc_thread</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, ctx: <a class="enum" href="enum.GCThreadContext.html" title="enum mmtk::vm::collection::GCThreadContext">GCThreadContext</a>&lt;VM&gt;);

    // Provided methods
    fn <a href="#method.out_of_memory" class="fn">out_of_memory</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, err_kind: <a class="enum" href="../../util/alloc/allocator/enum.AllocationError.html" title="enum mmtk::util::alloc::allocator::AllocationError">AllocationError</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.schedule_finalization" class="fn">schedule_finalization</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.post_forwarding" class="fn">post_forwarding</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.vm_live_bytes" class="fn">vm_live_bytes</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_collection_enabled" class="fn">is_collection_enabled</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.create_gc_trigger" class="fn">create_gc_trigger</a>() -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../../util/heap/gc_trigger/trait.GCTriggerPolicy.html" title="trait mmtk::util::heap::gc_trigger::GCTriggerPolicy">GCTriggerPolicy</a>&lt;VM&gt;&gt; { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-specific methods for garbage collection.</p>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">ยง</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.stop_all_mutators" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#25-27">source</a><h4 class="code-header">fn <a href="#tymethod.stop_all_mutators" class="fn">stop_all_mutators</a>&lt;F&gt;(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, mutator_visitor: F)<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;'static mut <a class="struct" href="../../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;),</div></h4></section></summary><div class="docblock"><p>Stop all the mutator threads. MMTk calls this method when it requires all the mutator to yield for a GC.
This method should not return until all the threads are yielded.
The actual thread synchronization mechanism is up to the VM, and MMTk does not make assumptions on that.
MMTk provides a callback function and expects the binding to use the callback for each mutator when it
is ready for stack scanning. Usually a stack can be scanned as soon as the thread stops in the yieldpoint.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC worker.</li>
<li><code>mutator_visitor</code>: A callback.  Call it with a mutator as argument to notify MMTk that the mutator is ready to be scanned.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.resume_mutators" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#35">source</a><h4 class="code-header">fn <a href="#tymethod.resume_mutators" class="fn">resume_mutators</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>Resume all the mutator threads, the opposite of the above. When a GC is finished, MMTk calls this method.</p>
<p>This method may not be called by the same GC thread that called <code>stop_all_mutators</code>.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC worker.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.block_for_gc" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#44">source</a><h4 class="code-header">fn <a href="#tymethod.block_for_gc" class="fn">block_for_gc</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>)</h4></section></summary><div class="docblock"><p>Block the current thread for GC. This is called when an allocation request cannot be fulfilled and a GC
is needed. MMTk calls this method to inform the VM that the current thread needs to be blocked as a GC
is going to happen. Then MMTk starts a GC. For a stop-the-world GC, MMTk will then call <code>stop_all_mutators()</code>
before the GC, and call <code>resume_mutators()</code> after the GC.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The current thread pointer that should be blocked. The VM can optionally check if the current thread matches <code>tls</code>.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.spawn_gc_thread" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#59">source</a><h4 class="code-header">fn <a href="#tymethod.spawn_gc_thread" class="fn">spawn_gc_thread</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, ctx: <a class="enum" href="enum.GCThreadContext.html" title="enum mmtk::vm::collection::GCThreadContext">GCThreadContext</a>&lt;VM&gt;)</h4></section></summary><div class="docblock"><p>Ask the VM to spawn a GC thread for MMTk. A GC thread may later call into the VM through these VM traits. Some VMs
have assumptions that those calls needs to be within VM internal threads.
As a result, MMTk does not spawn GC threads itself to avoid breaking this kind of assumptions.
MMTk calls this method to spawn GC threads during <a href="../../mmtk/struct.MMTK.html#method.initialize_collection" title="method mmtk::mmtk::MMTK::initialize_collection"><code>crate::mmtk::MMTK::initialize_collection</code></a>
and <a href="../../mmtk/struct.MMTK.html#method.after_fork" title="method mmtk::mmtk::MMTK::after_fork"><code>crate::mmtk::MMTK::after_fork</code></a>.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the parent thread that we spawn new threads from. This is the same <code>tls</code> when the VM
calls <code>initialize_collection()</code> and passes as an argument.</li>
<li><code>ctx</code>: The context for the GC thread.
<ul>
<li>If <a href="enum.GCThreadContext.html#variant.Worker" title="variant mmtk::vm::collection::GCThreadContext::Worker"><code>GCThreadContext::Worker</code></a> is passed, it means spawning a thread to run as a GC worker.
The spawned thread shall call the entry point function <code>GCWorker::run</code>.
Currently <code>Worker</code> is the only kind of thread which mmtk-core will create.</li>
</ul>
</li>
</ul>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">ยง</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.out_of_memory" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#74-76">source</a><h4 class="code-header">fn <a href="#method.out_of_memory" class="fn">out_of_memory</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, err_kind: <a class="enum" href="../../util/alloc/allocator/enum.AllocationError.html" title="enum mmtk::util::alloc::allocator::AllocationError">AllocationError</a>)</h4></section></summary><div class="docblock"><p>Inform the VM of an out-of-memory error. The binding should hook into the VMโs error
routine for OOM. Note that there are two different categories of OOM:</p>
<ul>
<li>Critical OOM: This is the case where the OS is unable to mmap or acquire more memory.
MMTk expects the VM to abort immediately if such an error is thrown.</li>
<li>Heap OOM: This is the case where the specified heap size is insufficient to execute the
application. MMTk expects the binding to notify the VM about this OOM. MMTk makes no
assumptions about whether the VM will continue executing or abort immediately.</li>
</ul>
<p>See <a href="../../util/alloc/allocator/enum.AllocationError.html" title="enum mmtk::util::alloc::allocator::AllocationError"><code>AllocationError</code></a> for more information.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the mutator which failed the allocation and triggered the OOM.</li>
<li><code>err_kind</code>: The type of OOM error that was encountered.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.schedule_finalization" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#82">source</a><h4 class="code-header">fn <a href="#method.schedule_finalization" class="fn">schedule_finalization</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>Inform the VM to schedule finalization threads.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the current GC thread.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.post_forwarding" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#105">source</a><h4 class="code-header">fn <a href="#method.post_forwarding" class="fn">post_forwarding</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>A hook for the VM to do work after forwarding objects.</p>
<p>This function is called after all of the following have finished:</p>
<ul>
<li>The life and death of objects are determined.  Objects determined to be live will not
be reclaimed in this GC.</li>
<li>Live objects have been moved to their destinations. (copying GC only)</li>
<li>References in objects have been updated to point to new addresses. (copying GC only)</li>
</ul>
<p>And this function may run concurrently with the release work of GC, i.e. freeing the space
occupied by dead objects.</p>
<p>It is safe for the VM to read and write object fields at this time, although GC has not
finished yet.  GC will be reclaiming spaces of dead objects, but will not damage live
objects.  However, the VM cannot allocate new objects at this time.</p>
<p>One possible use of this hook is enqueuing <code>{Soft,Weak,Phantom}Reference</code> instances to
reference queues (for Java).  VMs (including JVM implementations) do not have to handle
weak references this way, but mmtk-core provides this opportunity.</p>
<p>Arguments:</p>
<ul>
<li><code>tls_worker</code>: The thread pointer for the worker thread performing this call.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.vm_live_bytes" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#136-139">source</a><h4 class="code-header">fn <a href="#method.vm_live_bytes" class="fn">vm_live_bytes</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the amount of memory (in bytes) which the VM allocated outside the MMTk heap but
wants to include into the current MMTk heap size.  MMTk core will consider the reported
memory as part of MMTk heap for the purpose of heap size accounting.</p>
<p>This amount should include memory that is kept alive by heap objects and can be released by
executing finalizers (or other language-specific cleaning-up routines) that are executed
when the heap objects are dead.  For example, if a language implementation allocates array
headers in the MMTk heap, but allocates their underlying buffers that hold the actual
elements using <code>malloc</code>, then those buffers should be included in this amount.  When the GC
finds such an array dead, its finalizer shall <code>free</code> the buffer and reduce this amount.</p>
<p>If possible, the VM should account off-heap memory in pages.  That is, count the number of
pages occupied by off-heap objects, and report the number of bytes of those whole pages
instead of individual objects.  Because the underlying operating system manages memory at
page granularity, the occupied pages (instead of individual objects) determine the memory
footprint of a process, and how much memory MMTk spaces can obtain from the OS.</p>
<p>However, if the VM is incapable of accounting off-heap memory in pages (for example, if the
VM uses <code>malloc</code> and the implementation of <code>malloc</code> is opaque to the VM), the VM binding
can simply return the total number of bytes of those off-heap objects as an approximation.</p>
<h5 id="performance-note"><a class="doc-anchor" href="#performance-note">ยง</a>Performance note</h5>
<p>This function will be called when MMTk polls for GC.  It happens every time the MMTk
allocators have allocated a certain amount of memory, usually one or a few blocks.  Because
this function is called very frequently, its implementation must be efficient.  If it is
too expensive to compute the exact amount, an approximate value should be sufficient for
MMTk to trigger GC promptly in order to release off-heap memory, and keep the memory
footprint under control.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_collection_enabled" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#153-158">source</a><h4 class="code-header">fn <a href="#method.is_collection_enabled" class="fn">is_collection_enabled</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Callback function to ask the VM whether GC is enabled or disabled, allowing or disallowing MMTk
to trigger garbage collection. When collection is disabled, you can still allocate through MMTk,
but MMTk will not trigger a GC even if the heap is full. In such a case, the allocation will
exceed MMTkโs heap size (the soft heap limit). However, there is no guarantee that the physical
allocation will succeed, and if it succeeds, there is no guarantee that further allocation will
keep succeeding. So if a VM disables collection, it needs to allocate with careful consideration
to make sure that the physical memory allows the amount of allocation. We highly recommend
to have GC always enabled (i.e. that this method always returns true). However, we support
this to accomodate some VMs that require this behavior. Note that
<code>handle_user_collection_request()</code> calls this function, too.  If this function returns
false, <code>handle_user_collection_request()</code> will not trigger GC, either. Note also that any synchronization
involving enabling and disabling collections by mutator threads should be implemented by the VM.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.create_gc_trigger" class="method"><a class="src rightside" href="../../../src/mmtk/vm/collection.rs.html#162-164">source</a><h4 class="code-header">fn <a href="#method.create_gc_trigger" class="fn">create_gc_trigger</a>() -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../../util/heap/gc_trigger/trait.GCTriggerPolicy.html" title="trait mmtk::util::heap::gc_trigger::GCTriggerPolicy">GCTriggerPolicy</a>&lt;VM&gt;&gt;</h4></section></summary><div class="docblock"><p>Ask the binding to create a <a href="../../util/heap/gc_trigger/trait.GCTriggerPolicy.html" title="trait mmtk::util::heap::gc_trigger::GCTriggerPolicy"><code>GCTriggerPolicy</code></a> if the option <code>gc_trigger</code> is set to
<code>crate::util::options::GCTriggerSelector::Delegated</code>.</p>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">ยง</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.83.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">ยง</a></h2><div id="implementors-list"></div><script src="../../../trait.impl/mmtk/vm/collection/trait.Collection.js" async></script></section></div></main></body></html>