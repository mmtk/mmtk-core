<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-specific methods for object model."><title>ObjectModel in mmtk::vm::object_model - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0 (90b35a623 2024-11-26)" data-channel="1.83.0" data-search-js="search-f0d225181b97f9a4.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../../../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../mmtk/index.html">mmtk</a><span class="version">0.30.0-4e06434f965306507005bd67ae5852ba9640d974</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Object<wbr>Model</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#side-specs-layout" title="Side Specs Layout">Side Specs Layout</a><ul><li><a href="#short-version" title="Short version">Short version</a></li><li><a href="#detailed-explanation" title="Detailed explanation">Detailed explanation</a></li></ul></li><li><a href="#object-layout-addresses" title="Object Layout Addresses">Object Layout Addresses</a><ul><li><a href="#raw-object-reference" title="(Raw) Object Reference">(Raw) Object Reference</a></li><li><a href="#object-start-address" title="Object Start Address">Object Start Address</a></li><li><a href="#object-header-address" title="Object header address">Object header address</a></li></ul></li></ul><h3><a href="#required-associated-consts">Required Associated Constants</a></h3><ul class="block"><li><a href="#associatedconstant.GLOBAL_LOG_BIT_SPEC" title="GLOBAL_LOG_BIT_SPEC">GLOBAL_LOG_BIT_SPEC</a></li><li><a href="#associatedconstant.LOCAL_FORWARDING_BITS_SPEC" title="LOCAL_FORWARDING_BITS_SPEC">LOCAL_FORWARDING_BITS_SPEC</a></li><li><a href="#associatedconstant.LOCAL_FORWARDING_POINTER_SPEC" title="LOCAL_FORWARDING_POINTER_SPEC">LOCAL_FORWARDING_POINTER_SPEC</a></li><li><a href="#associatedconstant.LOCAL_LOS_MARK_NURSERY_SPEC" title="LOCAL_LOS_MARK_NURSERY_SPEC">LOCAL_LOS_MARK_NURSERY_SPEC</a></li><li><a href="#associatedconstant.LOCAL_MARK_BIT_SPEC" title="LOCAL_MARK_BIT_SPEC">LOCAL_MARK_BIT_SPEC</a></li><li><a href="#associatedconstant.LOCAL_PINNING_BIT_SPEC" title="LOCAL_PINNING_BIT_SPEC">LOCAL_PINNING_BIT_SPEC</a></li><li><a href="#associatedconstant.OBJECT_REF_OFFSET_LOWER_BOUND" title="OBJECT_REF_OFFSET_LOWER_BOUND">OBJECT_REF_OFFSET_LOWER_BOUND</a></li></ul><h3><a href="#provided-associated-consts">Provided Associated Constants</a></h3><ul class="block"><li><a href="#associatedconstant.NEED_VO_BITS_DURING_TRACING" title="NEED_VO_BITS_DURING_TRACING">NEED_VO_BITS_DURING_TRACING</a></li><li><a href="#associatedconstant.UNIFIED_OBJECT_REFERENCE_ADDRESS" title="UNIFIED_OBJECT_REFERENCE_ADDRESS">UNIFIED_OBJECT_REFERENCE_ADDRESS</a></li><li><a href="#associatedconstant.VM_WORST_CASE_COPY_EXPANSION" title="VM_WORST_CASE_COPY_EXPANSION">VM_WORST_CASE_COPY_EXPANSION</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.copy" title="copy">copy</a></li><li><a href="#tymethod.copy_to" title="copy_to">copy_to</a></li><li><a href="#tymethod.dump_object" title="dump_object">dump_object</a></li><li><a href="#tymethod.get_align_offset_when_copied" title="get_align_offset_when_copied">get_align_offset_when_copied</a></li><li><a href="#tymethod.get_align_when_copied" title="get_align_when_copied">get_align_when_copied</a></li><li><a href="#tymethod.get_current_size" title="get_current_size">get_current_size</a></li><li><a href="#tymethod.get_reference_when_copied_to" title="get_reference_when_copied_to">get_reference_when_copied_to</a></li><li><a href="#tymethod.get_size_when_copied" title="get_size_when_copied">get_size_when_copied</a></li><li><a href="#tymethod.get_type_descriptor" title="get_type_descriptor">get_type_descriptor</a></li><li><a href="#tymethod.ref_to_header" title="ref_to_header">ref_to_header</a></li><li><a href="#tymethod.ref_to_object_start" title="ref_to_object_start">ref_to_object_start</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.compare_exchange_metadata" title="compare_exchange_metadata">compare_exchange_metadata</a></li><li><a href="#method.fetch_add_metadata" title="fetch_add_metadata">fetch_add_metadata</a></li><li><a href="#method.fetch_and_metadata" title="fetch_and_metadata">fetch_and_metadata</a></li><li><a href="#method.fetch_or_metadata" title="fetch_or_metadata">fetch_or_metadata</a></li><li><a href="#method.fetch_sub_metadata" title="fetch_sub_metadata">fetch_sub_metadata</a></li><li><a href="#method.fetch_update_metadata" title="fetch_update_metadata">fetch_update_metadata</a></li><li><a href="#method.is_object_sane" title="is_object_sane">is_object_sane</a></li><li><a href="#method.load_metadata" title="load_metadata">load_metadata</a></li><li><a href="#method.load_metadata_atomic" title="load_metadata_atomic">load_metadata_atomic</a></li><li><a href="#method.store_metadata" title="store_metadata">store_metadata</a></li><li><a href="#method.store_metadata_atomic" title="store_metadata_atomic">store_metadata_atomic</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In mmtk::<wbr>vm::<wbr>object_<wbr>model</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">mmtk</a>::<wbr><a href="../index.html">vm</a>::<wbr><a href="index.html">object_model</a></span><h1>Trait <span class="trait">ObjectModel</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/mmtk/vm/object_model.rs.html#83-479">source</a> </span></div><pre class="rust item-decl"><code>pub trait ObjectModel&lt;VM: <a class="trait" href="../trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    const <a href="#associatedconstant.GLOBAL_LOG_BIT_SPEC" class="constant">GLOBAL_LOG_BIT_SPEC</a>: <a class="struct" href="specs/struct.VMGlobalLogBitSpec.html" title="struct mmtk::vm::object_model::specs::VMGlobalLogBitSpec">VMGlobalLogBitSpec</a>;
    const <a href="#associatedconstant.LOCAL_FORWARDING_POINTER_SPEC" class="constant">LOCAL_FORWARDING_POINTER_SPEC</a>: <a class="struct" href="specs/struct.VMLocalForwardingPointerSpec.html" title="struct mmtk::vm::object_model::specs::VMLocalForwardingPointerSpec">VMLocalForwardingPointerSpec</a>;
    const <a href="#associatedconstant.LOCAL_FORWARDING_BITS_SPEC" class="constant">LOCAL_FORWARDING_BITS_SPEC</a>: <a class="struct" href="specs/struct.VMLocalForwardingBitsSpec.html" title="struct mmtk::vm::object_model::specs::VMLocalForwardingBitsSpec">VMLocalForwardingBitsSpec</a>;
    const <a href="#associatedconstant.LOCAL_MARK_BIT_SPEC" class="constant">LOCAL_MARK_BIT_SPEC</a>: <a class="struct" href="specs/struct.VMLocalMarkBitSpec.html" title="struct mmtk::vm::object_model::specs::VMLocalMarkBitSpec">VMLocalMarkBitSpec</a>;
    const <a href="#associatedconstant.LOCAL_PINNING_BIT_SPEC" class="constant">LOCAL_PINNING_BIT_SPEC</a>: <a class="struct" href="specs/struct.VMLocalPinningBitSpec.html" title="struct mmtk::vm::object_model::specs::VMLocalPinningBitSpec">VMLocalPinningBitSpec</a>;
    const <a href="#associatedconstant.LOCAL_LOS_MARK_NURSERY_SPEC" class="constant">LOCAL_LOS_MARK_NURSERY_SPEC</a>: <a class="struct" href="specs/struct.VMLocalLOSMarkNurserySpec.html" title="struct mmtk::vm::object_model::specs::VMLocalLOSMarkNurserySpec">VMLocalLOSMarkNurserySpec</a>;
    const <a href="#associatedconstant.OBJECT_REF_OFFSET_LOWER_BOUND" class="constant">OBJECT_REF_OFFSET_LOWER_BOUND</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.isize.html">isize</a>;
    const <a href="#associatedconstant.NEED_VO_BITS_DURING_TRACING" class="constant">NEED_VO_BITS_DURING_TRACING</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> = false;
    const <a href="#associatedconstant.VM_WORST_CASE_COPY_EXPANSION" class="constant">VM_WORST_CASE_COPY_EXPANSION</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.f64.html">f64</a> = 1.5f64;
    const <a href="#associatedconstant.UNIFIED_OBJECT_REFERENCE_ADDRESS" class="constant">UNIFIED_OBJECT_REFERENCE_ADDRESS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> = false;
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 22 methods</span></summary>
    // Required methods
    fn <a href="#tymethod.copy" class="fn">copy</a>(
        from: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        semantics: <a class="enum" href="../../util/copy/enum.CopySemantics.html" title="enum mmtk::util::copy::CopySemantics">CopySemantics</a>,
        copy_context: &amp;mut <a class="struct" href="../../util/copy/struct.GCWorkerCopyContext.html" title="struct mmtk::util::copy::GCWorkerCopyContext">GCWorkerCopyContext</a>&lt;VM&gt;,
    ) -&gt; <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.copy_to" class="fn">copy_to</a>(
        from: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        to: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        region: <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a>,
    ) -&gt; <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.get_reference_when_copied_to" class="fn">get_reference_when_copied_to</a>(
        from: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        to: <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a>,
    ) -&gt; <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.get_current_size" class="fn">get_current_size</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.get_size_when_copied" class="fn">get_size_when_copied</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.get_align_when_copied" class="fn">get_align_when_copied</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.get_align_offset_when_copied" class="fn">get_align_offset_when_copied</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.get_type_descriptor" class="fn">get_type_descriptor</a>(reference: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; &amp;'static [<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.i8.html">i8</a>];
<span class="item-spacer"></span>    fn <a href="#tymethod.ref_to_object_start" class="fn">ref_to_object_start</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.ref_to_header" class="fn">ref_to_header</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.dump_object" class="fn">dump_object</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>);

    // Provided methods
    unsafe fn <a href="#method.load_metadata" class="fn">load_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
    ) -&gt; T { ... }
<span class="item-spacer"></span>    fn <a href="#method.load_metadata_atomic" class="fn">load_metadata_atomic</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
        ordering: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    ) -&gt; T { ... }
<span class="item-spacer"></span>    unsafe fn <a href="#method.store_metadata" class="fn">store_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        val: T,
        mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
    ) { ... }
<span class="item-spacer"></span>    fn <a href="#method.store_metadata_atomic" class="fn">store_metadata_atomic</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        val: T,
        mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
        ordering: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    ) { ... }
<span class="item-spacer"></span>    fn <a href="#method.compare_exchange_metadata" class="fn">compare_exchange_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        old_val: T,
        new_val: T,
        mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
        success_order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
        failure_order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, T&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.fetch_add_metadata" class="fn">fetch_add_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        val: T,
        order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    ) -&gt; T { ... }
<span class="item-spacer"></span>    fn <a href="#method.fetch_sub_metadata" class="fn">fetch_sub_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        val: T,
        order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    ) -&gt; T { ... }
<span class="item-spacer"></span>    fn <a href="#method.fetch_and_metadata" class="fn">fetch_and_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        val: T,
        order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    ) -&gt; T { ... }
<span class="item-spacer"></span>    fn <a href="#method.fetch_or_metadata" class="fn">fetch_or_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        val: T,
        order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    ) -&gt; T { ... }
<span class="item-spacer"></span>    fn <a href="#method.fetch_update_metadata" class="fn">fetch_update_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>, F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(T) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>&gt;(
        metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        set_order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
        fetch_order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
        f: F,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, T&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_object_sane" class="fn">is_object_sane</a>(_object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-specific methods for object model.</p>
<p>This trait includes 3 parts:</p>
<ol>
<li>Specifications for per object metadata: a binding needs to specify the location for each per object metadata spec.
A binding can choose between <code>in_header()</code> or <code>side()</code>, e.g. <code>VMGlobalLogBitSpec::side()</code>.
<ul>
<li>in_header: a binding needs to specify the bit offset to an object reference that can be used for the per object metadata spec.
The actual number of bits required for a spec can be obtained from the <code>num_bits()</code> method of the spec type.</li>
<li>side: a binding does not need to provide any specific storage for metadata in the header. Instead, MMTk
will use side tables to store the metadata. The following section Side Specs Layout will discuss how to correctly create
side metadata specs.</li>
</ul>
</li>
<li>In header metadata access: A binding
need to further define the functions with suffix _metadata about how to access the bits in the header. We provide default implementations
for those methods, assuming the bits in the spec are always available to MMTk. A binding could implement their
own routines to access the bits if VM specific treatment is needed (e.g. some bits are not always available to MMTk).</li>
<li>VM-specific object info needed by MMTk: MMTk does not know object info as it is VM specific. However, MMTk needs
some object information for GC. A binding needs to implement them correctly.</li>
</ol>
<p>Note that depending on the selected GC plan, only a subset of the methods provided here will be used.</p>
<h2 id="side-specs-layout"><a class="doc-anchor" href="#side-specs-layout">§</a>Side Specs Layout</h2><h3 id="short-version"><a class="doc-anchor" href="#short-version">§</a>Short version</h3>
<ul>
<li>For <em>global</em> side metadata:
<ul>
<li>The first spec: VMGlobalXXXSpec::side_first()</li>
<li>The following specs: VMGlobalXXXSpec::side_after(FIRST_GLOAL.as_spec())</li>
</ul>
</li>
<li>For <em>local</em> side metadata:
<ul>
<li>The first spec: VMLocalXXXSpec::side_first()</li>
<li>The following specs: VMLocalXXXSpec::side_after(FIRST_LOCAL.as_spec())</li>
</ul>
</li>
</ul>
<h3 id="detailed-explanation"><a class="doc-anchor" href="#detailed-explanation">§</a>Detailed explanation</h3>
<p>There are two types of side metadata layout in MMTk:</p>
<ol>
<li>Contiguous layout: is the layout in which the whole metadata space for a SideMetadataSpec is contiguous.</li>
<li>Chunked layout: is the layout in which the whole metadata memory space, that is shared between MMTk policies, is divided into metadata-chunks. Each metadata-chunk stores all of the metadata for all <code>SideMetadataSpec</code>s which apply to a source-data chunk.</li>
</ol>
<p>In 64-bits targets, both Global and PolicySpecific side metadata are contiguous.
Also, in 32-bits targets, the Global side metadata is contiguous.
This means if the starting address (variable named <code>offset</code>) of the metadata space for a SideMetadataSpec (<code>SPEC1</code>) is <code>BASE1</code>, the starting address (<code>offset</code>) of the next SideMetadataSpec (<code>SPEC2</code>) will be <code>BASE1 + total_metadata_space_size(SPEC1)</code>, which is located immediately after the end of the whole metadata space of <code>SPEC1</code>.
Now, if we add a third SideMetadataSpec (<code>SPEC3</code>), its starting address (<code>offset</code>) will be <code>BASE2 + total_metadata_space_size(SPEC2)</code>, which is located immediately after the end of the whole metadata space of <code>SPEC2</code>.</p>
<p>In 32-bits targets, the PolicySpecific side metadata is chunked.
This means for each chunk (2^22 Bytes) of data, which, by definition, is managed by exactly one MMTk policy, there is a metadata chunk (2^22 * some_fixed_ratio Bytes) that contains all of its PolicySpecific metadata.
This means if a policy has one SideMetadataSpec (<code>LS1</code>), the <code>offset</code> of that spec will be <code>0</code> (= at the start of a metadata chunk).
If there is a second SideMetadataSpec (<code>LS2</code>) for this specific policy, the <code>offset</code> for that spec will be <code>0 + required_metadata_space_per_chunk(LS1)</code>,
and for a third SideMetadataSpec (<code>LS3</code>), the <code>offset</code> will be <code>BASE(LS2) + required_metadata_space_per_chunk(LS2)</code>.</p>
<p>For all other policies, the <code>offset</code> starts from zero. This is safe because no two policies ever manage one chunk, so there will be no overlap.</p>
<h2 id="object-layout-addresses"><a class="doc-anchor" href="#object-layout-addresses">§</a>Object Layout Addresses</h2>
<p>MMTk tries to be general to cope with different language implementations and different object models. Thus it does not assume the internal of the object model.
Instead, MMTk only uses the following addresses for an object. If you find the MMTk’s approach does not work for your language in practice, you are welcome to submit an issue
or engage with MMTk team on Zulip to disucss further.</p>
<h3 id="raw-object-reference"><a class="doc-anchor" href="#raw-object-reference">§</a>(Raw) Object Reference</h3>
<p>See <a href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference"><code>crate::util::address::ObjectReference</code></a>. This is a special address that represents the
object. MMTk refers to an object by its object reference. An object reference cannot be NULL,
must be inside the address range of the object, and must be word aligned
(<a href="../../util/address/struct.ObjectReference.html#associatedconstant.ALIGNMENT" title="associated constant mmtk::util::address::ObjectReference::ALIGNMENT"><code>crate::util::address::ObjectReference::ALIGNMENT</code></a>).</p>
<h3 id="object-start-address"><a class="doc-anchor" href="#object-start-address">§</a>Object Start Address</h3>
<p>This address is returned by an allocation call <a href="../../memory_manager/fn.alloc.html" title="fn mmtk::memory_manager::alloc"><code>crate::memory_manager::alloc</code></a>. This is the start of the address range of the allocation.
<a href="trait.ObjectModel.html#tymethod.ref_to_object_start" title="associated function mmtk::vm::object_model::ObjectModel::ref_to_object_start"><code>ObjectModel::ref_to_object_start</code></a> should return this address for a given object.</p>
<h3 id="object-header-address"><a class="doc-anchor" href="#object-header-address">§</a>Object header address</h3>
<p>If a binding allows MMTk to use its header bits for object metadata, it needs to supply an object header
address (<a href="trait.ObjectModel.html#tymethod.ref_to_header" title="associated function mmtk::vm::object_model::ObjectModel::ref_to_header"><code>ObjectModel::ref_to_header</code></a>). MMTk will access header bits using this address.</p>
</div></details><h2 id="required-associated-consts" class="section-header">Required Associated Constants<a href="#required-associated-consts" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedconstant.GLOBAL_LOG_BIT_SPEC" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#95">source</a><h4 class="code-header">const <a href="#associatedconstant.GLOBAL_LOG_BIT_SPEC" class="constant">GLOBAL_LOG_BIT_SPEC</a>: <a class="struct" href="specs/struct.VMGlobalLogBitSpec.html" title="struct mmtk::vm::object_model::specs::VMGlobalLogBitSpec">VMGlobalLogBitSpec</a></h4></section></summary><div class="docblock"><p>A global 1-bit metadata used by generational plans to track cross-generational pointers. It is generally
located in side metadata.</p>
<p>Note that for this bit, 0 represents logged (default), and 1 represents unlogged.
This bit is also referred to as unlogged bit in Java MMTk for this reason.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.LOCAL_FORWARDING_POINTER_SPEC" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#99">source</a><h4 class="code-header">const <a href="#associatedconstant.LOCAL_FORWARDING_POINTER_SPEC" class="constant">LOCAL_FORWARDING_POINTER_SPEC</a>: <a class="struct" href="specs/struct.VMLocalForwardingPointerSpec.html" title="struct mmtk::vm::object_model::specs::VMLocalForwardingPointerSpec">VMLocalForwardingPointerSpec</a></h4></section></summary><div class="docblock"><p>A local word-size metadata for the forwarding pointer, used by copying plans. It is almost always
located in the object header as it is fine to destroy an object header in order to copy it.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.LOCAL_FORWARDING_BITS_SPEC" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#105">source</a><h4 class="code-header">const <a href="#associatedconstant.LOCAL_FORWARDING_BITS_SPEC" class="constant">LOCAL_FORWARDING_BITS_SPEC</a>: <a class="struct" href="specs/struct.VMLocalForwardingBitsSpec.html" title="struct mmtk::vm::object_model::specs::VMLocalForwardingBitsSpec">VMLocalForwardingBitsSpec</a></h4></section></summary><div class="docblock"><p>A local 2-bit metadata for the forwarding status bits, used by copying plans. If your runtime requires
word-aligned addresses (i.e. 4- or 8-bytes), you can use the last two bits in the object header to store
the forwarding bits. Note that you must be careful if you place this in the header as the runtime may
be using those bits for some other reason.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.LOCAL_MARK_BIT_SPEC" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#111">source</a><h4 class="code-header">const <a href="#associatedconstant.LOCAL_MARK_BIT_SPEC" class="constant">LOCAL_MARK_BIT_SPEC</a>: <a class="struct" href="specs/struct.VMLocalMarkBitSpec.html" title="struct mmtk::vm::object_model::specs::VMLocalMarkBitSpec">VMLocalMarkBitSpec</a></h4></section></summary><div class="docblock"><p>A local 1-bit metadata for the mark bit, used by most plans that need to mark live objects. Like with the
<a href="trait.ObjectModel.html#associatedconstant.LOCAL_FORWARDING_BITS_SPEC" title="associated constant mmtk::vm::object_model::ObjectModel::LOCAL_FORWARDING_BITS_SPEC">forwarding bits</a>, you can often steal the last bit in
the object header (due to alignment requirements) for the mark bit. Though some bindings such as the
OpenJDK binding prefer to have the mark bits in side metadata to allow for bulk operations.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.LOCAL_PINNING_BIT_SPEC" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#116">source</a><h4 class="code-header">const <a href="#associatedconstant.LOCAL_PINNING_BIT_SPEC" class="constant">LOCAL_PINNING_BIT_SPEC</a>: <a class="struct" href="specs/struct.VMLocalPinningBitSpec.html" title="struct mmtk::vm::object_model::specs::VMLocalPinningBitSpec">VMLocalPinningBitSpec</a></h4></section></summary><div class="docblock"><p>A local 1-bit metadata specification for the pinning bit, used by plans that need to pin objects. It is
generally in side metadata.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.LOCAL_LOS_MARK_NURSERY_SPEC" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#124">source</a><h4 class="code-header">const <a href="#associatedconstant.LOCAL_LOS_MARK_NURSERY_SPEC" class="constant">LOCAL_LOS_MARK_NURSERY_SPEC</a>: <a class="struct" href="specs/struct.VMLocalLOSMarkNurserySpec.html" title="struct mmtk::vm::object_model::specs::VMLocalLOSMarkNurserySpec">VMLocalLOSMarkNurserySpec</a></h4></section></summary><div class="docblock"><p>A local 2-bit metadata used by the large object space to mark objects and set objects as “newly allocated”.
Used by any plan with large object allocation. It is generally in the header as we can add an extra word
before the large object to store this metadata. This is fine as the metadata size is insignificant in
comparison to the object size.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.OBJECT_REF_OFFSET_LOWER_BOUND" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#447">source</a><h4 class="code-header">const <a href="#associatedconstant.OBJECT_REF_OFFSET_LOWER_BOUND" class="constant">OBJECT_REF_OFFSET_LOWER_BOUND</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.isize.html">isize</a></h4></section></summary><div class="docblock"><p>For our allocation result (object_start), the binding may have an offset between the allocation result
and the raw address of their object reference, i.e. object ref’s raw address = object_start + offset.
The offset could be zero. The offset is not necessary to be
constant for all the objects. This constant defines the smallest possible offset.</p>
<p>This is used as an indication for MMTk to predict where object references may point to in some algorithms.</p>
<p>We should have the invariant:</p>
<ul>
<li>object ref &gt;= object_start + OBJECT_REF_OFFSET_LOWER_BOUND</li>
</ul>
</div></details></div><h2 id="provided-associated-consts" class="section-header">Provided Associated Constants<a href="#provided-associated-consts" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedconstant.NEED_VO_BITS_DURING_TRACING" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#141">source</a><h4 class="code-header">const <a href="#associatedconstant.NEED_VO_BITS_DURING_TRACING" class="constant">NEED_VO_BITS_DURING_TRACING</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> = false</h4></section></summary><div class="docblock"><p>Set this to true if the VM binding requires the valid object (VO) bits to be available
during tracing. If this constant is set to <code>false</code>, it is undefined behavior if the binding
attempts to access VO bits during tracing.</p>
<p>Note that the VO bits is always available during root scanning even if this flag is false,
which is suitable for using VO bits (and the <code>is_mmtk_object()</code> method) for conservative
stack scanning. However, if a binding is also conservative in finding references during
object scanning, they need to set this constant to <code>true</code>. See the comments of individual
methods in the <code>Scanning</code> trait.</p>
<p>Depending on the internal implementation of mmtk-core, different strategies for handling
VO bits have different time/space overhead.  mmtk-core will choose the best strategy
according to the configuration of the VM binding, including this flag.  Currently, setting
this flag to true does not impose any additional overhead.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.VM_WORST_CASE_COPY_EXPANSION" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#426">source</a><h4 class="code-header">const <a href="#associatedconstant.VM_WORST_CASE_COPY_EXPANSION" class="constant">VM_WORST_CASE_COPY_EXPANSION</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.f64.html">f64</a> = 1.5f64</h4></section></summary><div class="docblock"><p>This is the worst case expansion that can occur due to object size increasing while
copying. This constant is used to calculate whether a nursery has grown larger than the
mature space for generational plans.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.UNIFIED_OBJECT_REFERENCE_ADDRESS" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#436">source</a><h4 class="code-header">const <a href="#associatedconstant.UNIFIED_OBJECT_REFERENCE_ADDRESS" class="constant">UNIFIED_OBJECT_REFERENCE_ADDRESS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> = false</h4></section></summary><div class="docblock"><p>If this is true, the binding guarantees that the object reference’s raw address and the
object start are always the same address.  In other words, an object reference’s raw
address is always equal to the return value of the <code>ref_to_object_start</code> method,</p>
<p>This is a very strong guarantee, but it is also helpful for MMTk to
make some assumptions and optimize for this case.
If a binding sets this to true, and the related methods return inconsistent results, this is an undefined behavior. MMTk may panic
if any assertion catches this error, but may also fail silently.</p>
</div></details></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.copy" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#363-367">source</a><h4 class="code-header">fn <a href="#tymethod.copy" class="fn">copy</a>(
    from: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    semantics: <a class="enum" href="../../util/copy/enum.CopySemantics.html" title="enum mmtk::util::copy::CopySemantics">CopySemantics</a>,
    copy_context: &amp;mut <a class="struct" href="../../util/copy/struct.GCWorkerCopyContext.html" title="struct mmtk::util::copy::GCWorkerCopyContext">GCWorkerCopyContext</a>&lt;VM&gt;,
) -&gt; <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a></h4></section></summary><div class="docblock"><p>Copy an object and return the address of the new object. Usually in the implementation of this method,
<code>alloc_copy()</code> and <code>post_copy()</code> from <a href="util/copy/struct.GCWorkerCopyContext.html"><code>GCWorkerCopyContext</code></a>
are used for copying.</p>
<p>Arguments:</p>
<ul>
<li><code>from</code>: The address of the object to be copied.</li>
<li><code>semantics</code>: The copy semantic to use.</li>
<li><code>copy_context</code>: The <code>GCWorkerCopyContext</code> for the GC thread.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.copy_to" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#380">source</a><h4 class="code-header">fn <a href="#tymethod.copy_to" class="fn">copy_to</a>(
    from: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    to: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    region: <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a>,
) -&gt; <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a></h4></section></summary><div class="docblock"><p>Copy an object. This is required
for delayed-copy collectors such as compacting collectors. During the
collection, MMTk reserves a region in the heap for an object as per
requirements found from <code>ObjectModel</code> and then asks <code>ObjectModel</code> to
determine what the object’s reference will be post-copy. Return the address
past the end of the copied object.</p>
<p>Arguments:</p>
<ul>
<li><code>from</code>: The address of the object to be copied.</li>
<li><code>to</code>: The target location.</li>
<li>`region: The start of the region that was reserved for this object.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.get_reference_when_copied_to" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#389">source</a><h4 class="code-header">fn <a href="#tymethod.get_reference_when_copied_to" class="fn">get_reference_when_copied_to</a>(
    from: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    to: <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a>,
) -&gt; <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a></h4></section></summary><div class="docblock"><p>Return the reference that an object will be referred to after it is copied
to the specified region. Used in delayed-copy collectors such as compacting
collectors.</p>
<p>Arguments:</p>
<ul>
<li><code>from</code>: The object to be copied.</li>
<li><code>to</code>: The start of the region to be copied to.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.get_current_size" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#395">source</a><h4 class="code-header">fn <a href="#tymethod.get_current_size" class="fn">get_current_size</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the size used by an object.</p>
<p>Arguments:</p>
<ul>
<li><code>object</code>: The object to be queried.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.get_size_when_copied" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#401">source</a><h4 class="code-header">fn <a href="#tymethod.get_size_when_copied" class="fn">get_size_when_copied</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the size when an object is copied.</p>
<p>Arguments:</p>
<ul>
<li><code>object</code>: The object to be queried.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.get_align_when_copied" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#407">source</a><h4 class="code-header">fn <a href="#tymethod.get_align_when_copied" class="fn">get_align_when_copied</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the alignment when an object is copied.</p>
<p>Arguments:</p>
<ul>
<li><code>object</code>: The object to be queried.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.get_align_offset_when_copied" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#413">source</a><h4 class="code-header">fn <a href="#tymethod.get_align_offset_when_copied" class="fn">get_align_offset_when_copied</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the alignment offset when an object is copied.</p>
<p>Arguments:</p>
<ul>
<li><code>object</code>: The object to be queried.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.get_type_descriptor" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#421">source</a><h4 class="code-header">fn <a href="#tymethod.get_type_descriptor" class="fn">get_type_descriptor</a>(reference: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; &amp;'static [<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.i8.html">i8</a>]</h4></section></summary><div class="docblock"><p>Get the type descriptor for an object.</p>
<p>FIXME: Do we need this? If so, determine lifetime, return byte[]</p>
<p>Arguments:</p>
<ul>
<li><code>reference</code>: The object to be queried.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.ref_to_object_start" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#457">source</a><h4 class="code-header">fn <a href="#tymethod.ref_to_object_start" class="fn">ref_to_object_start</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a></h4></section></summary><div class="docblock"><p>Return the lowest address of the storage associated with an object. This should be
the address that a binding gets by an allocation call (<a href="../../memory_manager/fn.alloc.html" title="fn mmtk::memory_manager::alloc"><code>crate::memory_manager::alloc</code></a>).</p>
<p>Note that the return value needs to satisfy the invariant mentioned in the doc comment of
<a href="trait.ObjectModel.html#associatedconstant.OBJECT_REF_OFFSET_LOWER_BOUND"><code>Self::OBJECT_REF_OFFSET_LOWER_BOUND</code></a>.</p>
<p>Arguments:</p>
<ul>
<li><code>object</code>: The object to be queried.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.ref_to_header" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#466">source</a><h4 class="code-header">fn <a href="#tymethod.ref_to_header" class="fn">ref_to_header</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a></h4></section></summary><div class="docblock"><p>Return the header base address from an object reference. Any object header metadata
in the <a href="trait.ObjectModel.html" title="trait mmtk::vm::object_model::ObjectModel"><code>crate::vm::ObjectModel</code></a> declares a piece of header metadata with an offset
from this address. If a binding does not use any header metadata for MMTk, this method
will not be called, and the binding can simply use <code>unreachable!()</code> for the method.</p>
<p>Arguments:</p>
<ul>
<li><code>object</code>: The object to be queried.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.dump_object" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#472">source</a><h4 class="code-header">fn <a href="#tymethod.dump_object" class="fn">dump_object</a>(object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>)</h4></section></summary><div class="docblock"><p>Dump debugging information for an object.</p>
<p>Arguments:</p>
<ul>
<li><code>object</code>: The object to be dumped.</li>
</ul>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.load_metadata" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#155-161">source</a><h4 class="code-header">unsafe fn <a href="#method.load_metadata" class="fn">load_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
) -&gt; T</h4></section></summary><div class="docblock"><p>A function to non-atomically load the specified per-object metadata’s content.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
Returns the metadata value.</p>
<h5 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>mask</code>: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</li>
</ul>
<h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>This is a non-atomic load, thus not thread-safe.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.load_metadata_atomic" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#173-180">source</a><h4 class="code-header">fn <a href="#method.load_metadata_atomic" class="fn">load_metadata_atomic</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
    ordering: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
) -&gt; T</h4></section></summary><div class="docblock"><p>A function to atomically load the specified per-object metadata’s content.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
Returns the metadata value.</p>
<h5 id="arguments-1"><a class="doc-anchor" href="#arguments-1">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>mask</code>: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</li>
<li><code>atomic_ordering</code>: is the atomic ordering for the load operation.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.store_metadata" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#194-201">source</a><h4 class="code-header">unsafe fn <a href="#method.store_metadata" class="fn">store_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    val: T,
    mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
)</h4></section></summary><div class="docblock"><p>A function to non-atomically store a value to the specified per-object metadata.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</p>
<h5 id="arguments-2"><a class="doc-anchor" href="#arguments-2">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>val</code>: is the new metadata value to be stored.</li>
<li><code>mask</code>: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</li>
</ul>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h5>
<p>This is a non-atomic store, thus not thread-safe.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.store_metadata_atomic" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#213-221">source</a><h4 class="code-header">fn <a href="#method.store_metadata_atomic" class="fn">store_metadata_atomic</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    val: T,
    mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
    ordering: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
)</h4></section></summary><div class="docblock"><p>A function to atomically store a value to the specified per-object metadata.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</p>
<h5 id="arguments-3"><a class="doc-anchor" href="#arguments-3">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>val</code>: is the new metadata value to be stored.</li>
<li><code>mask</code>: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</li>
<li><code>atomic_ordering</code>: is the optional atomic ordering for the store operation.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compare_exchange_metadata" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#236-253">source</a><h4 class="code-header">fn <a href="#method.compare_exchange_metadata" class="fn">compare_exchange_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    old_val: T,
    new_val: T,
    mask: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;,
    success_order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    failure_order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, T&gt;</h4></section></summary><div class="docblock"><p>A function to atomically compare-and-exchange the specified per-object metadata’s content.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
Returns <code>true</code> if the operation is successful, and <code>false</code> otherwise.</p>
<h5 id="arguments-4"><a class="doc-anchor" href="#arguments-4">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>old_val</code>: is the expected current value of the metadata.</li>
<li><code>new_val</code>: is the new metadata value to be stored if the compare-and-exchange operation is successful.</li>
<li><code>mask</code>: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</li>
<li><code>success_order</code>: is the atomic ordering used if the operation is successful.</li>
<li><code>failure_order</code>: is the atomic ordering used if the operation fails.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fetch_add_metadata" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#266-273">source</a><h4 class="code-header">fn <a href="#method.fetch_add_metadata" class="fn">fetch_add_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    val: T,
    order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
) -&gt; T</h4></section></summary><div class="docblock"><p>A function to atomically perform an add operation on the specified per-object metadata’s content.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
This is a wrapping add.</p>
<h5 id="returns-the-old-metadata-value"><a class="doc-anchor" href="#returns-the-old-metadata-value">§</a>Returns the old metadata value.</h5><h5 id="arguments-5"><a class="doc-anchor" href="#arguments-5">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>val</code>: is the value to be added to the current value of the metadata.</li>
<li><code>order</code>: is the atomic ordering of the fetch-and-add operation.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fetch_sub_metadata" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#286-293">source</a><h4 class="code-header">fn <a href="#method.fetch_sub_metadata" class="fn">fetch_sub_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    val: T,
    order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
) -&gt; T</h4></section></summary><div class="docblock"><p>A function to atomically perform a subtract operation on the specified per-object metadata’s content.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
This is a wrapping sub.
Returns the old metadata value.</p>
<h5 id="arguments-6"><a class="doc-anchor" href="#arguments-6">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>val</code>: is the value to be subtracted from the current value of the metadata.</li>
<li><code>order</code>: is the atomic ordering of the fetch-and-add operation.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fetch_and_metadata" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#305-312">source</a><h4 class="code-header">fn <a href="#method.fetch_and_metadata" class="fn">fetch_and_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    val: T,
    order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
) -&gt; T</h4></section></summary><div class="docblock"><p>A function to atomically perform a bit-and operation on the specified per-object metadata’s content.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
Returns the old metadata value.</p>
<h5 id="arguments-7"><a class="doc-anchor" href="#arguments-7">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>val</code>: is the value to bit-and with the current value of the metadata.</li>
<li><code>order</code>: is the atomic ordering of the fetch-and-add operation.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fetch_or_metadata" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#324-331">source</a><h4 class="code-header">fn <a href="#method.fetch_or_metadata" class="fn">fetch_or_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    val: T,
    order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
) -&gt; T</h4></section></summary><div class="docblock"><p>A function to atomically perform a bit-or operation on the specified per-object metadata’s content.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
Returns the old metadata value.</p>
<h5 id="arguments-8"><a class="doc-anchor" href="#arguments-8">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>val</code>: is the value to bit-or with the current value of the metadata.</li>
<li><code>order</code>: is the atomic ordering of the fetch-and-add operation.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fetch_update_metadata" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#345-353">source</a><h4 class="code-header">fn <a href="#method.fetch_update_metadata" class="fn">fetch_update_metadata</a>&lt;T: <a class="trait" href="../../util/metadata/metadata_val_traits/trait.MetadataValue.html" title="trait mmtk::util::metadata::metadata_val_traits::MetadataValue">MetadataValue</a>, F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(T) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>&gt;(
    metadata_spec: &amp;<a class="struct" href="../../util/metadata/header_metadata/struct.HeaderMetadataSpec.html" title="struct mmtk::util::metadata::header_metadata::HeaderMetadataSpec">HeaderMetadataSpec</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    set_order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    fetch_order: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/sync/atomic/enum.Ordering.html" title="enum core::sync::atomic::Ordering">Ordering</a>,
    f: F,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, T&gt;</h4></section></summary><div class="docblock"><p>A function to atomically perform an update operation on the specified per-object metadata’s content.
The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.
The semantics of this method are the same as the <code>fetch_update()</code> on Rust atomic types.</p>
<h5 id="arguments-9"><a class="doc-anchor" href="#arguments-9">§</a>Arguments:</h5>
<ul>
<li><code>metadata_spec</code>: is the header metadata spec that tries to perform the operation.</li>
<li><code>object</code>: is a reference to the target object.</li>
<li><code>val</code>: is the value to bit-and with the current value of the metadata.</li>
<li><code>order</code>: is the atomic ordering of the fetch-and-add operation.</li>
</ul>
<h5 id="returns-the-old-metadata-value-1"><a class="doc-anchor" href="#returns-the-old-metadata-value-1">§</a>Returns the old metadata value.</h5></div></details><details class="toggle method-toggle" open><summary><section id="method.is_object_sane" class="method"><a class="src rightside" href="../../../src/mmtk/vm/object_model.rs.html#476-478">source</a><h4 class="code-header">fn <a href="#method.is_object_sane" class="fn">is_object_sane</a>(_object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return if an object is valid from the runtime point of view. This is used
to debug MMTk.</p>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.83.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../../trait.impl/mmtk/vm/object_model/trait.ObjectModel.js" async></script></section></div></main></body></html>