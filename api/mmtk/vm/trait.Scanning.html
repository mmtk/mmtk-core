<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-specific methods for scanning roots/objects."><title>Scanning in mmtk::vm - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0 (90b35a623 2024-11-26)" data-channel="1.83.0" data-search-js="search-f0d225181b97f9a4.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../mmtk/index.html">mmtk</a><span class="version">0.31.0-2569dcdaf6300fe5af155252fd8476a57b431fdd</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Scanning</a></h2><h3><a href="#provided-associated-consts">Provided Associated Constants</a></h3><ul class="block"><li><a href="#associatedconstant.UNIQUE_OBJECT_ENQUEUING" title="UNIQUE_OBJECT_ENQUEUING">UNIQUE_OBJECT_ENQUEUING</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.notify_initial_thread_scan_complete" title="notify_initial_thread_scan_complete">notify_initial_thread_scan_complete</a></li><li><a href="#tymethod.prepare_for_roots_re_scanning" title="prepare_for_roots_re_scanning">prepare_for_roots_re_scanning</a></li><li><a href="#tymethod.scan_object" title="scan_object">scan_object</a></li><li><a href="#tymethod.scan_roots_in_mutator_thread" title="scan_roots_in_mutator_thread">scan_roots_in_mutator_thread</a></li><li><a href="#tymethod.scan_vm_specific_roots" title="scan_vm_specific_roots">scan_vm_specific_roots</a></li><li><a href="#tymethod.supports_return_barrier" title="supports_return_barrier">supports_return_barrier</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.forward_weak_refs" title="forward_weak_refs">forward_weak_refs</a></li><li><a href="#method.process_weak_refs" title="process_weak_refs">process_weak_refs</a></li><li><a href="#method.scan_object_and_trace_edges" title="scan_object_and_trace_edges">scan_object_and_trace_edges</a></li><li><a href="#method.support_slot_enqueuing" title="support_slot_enqueuing">support_slot_enqueuing</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In mmtk::<wbr>vm</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">mmtk</a>::<wbr><a href="index.html">vm</a></span><h1>Trait <span class="trait">Scanning</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/mmtk/vm/scanning.rs.html#142-396">source</a> </span></div><pre class="rust item-decl"><code>pub trait Scanning&lt;VM: <a class="trait" href="trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    const <a href="#associatedconstant.UNIQUE_OBJECT_ENQUEUING" class="constant">UNIQUE_OBJECT_ENQUEUING</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> = false;

    // Required methods
    fn <a href="#tymethod.scan_object" class="fn">scan_object</a>&lt;SV: <a class="trait" href="scanning/trait.SlotVisitor.html" title="trait mmtk::vm::scanning::SlotVisitor">SlotVisitor</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;&gt;(
        tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        slot_visitor: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut SV</a>,
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.notify_initial_thread_scan_complete" class="fn">notify_initial_thread_scan_complete</a>(
        partial_scan: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,
        tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.scan_roots_in_mutator_thread" class="fn">scan_roots_in_mutator_thread</a>(
        tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        mutator: &amp;'static mut <a class="struct" href="../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;,
        factory: impl <a class="trait" href="scanning/trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;,
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.scan_vm_specific_roots" class="fn">scan_vm_specific_roots</a>(
        tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        factory: impl <a class="trait" href="scanning/trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;,
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.supports_return_barrier" class="fn">supports_return_barrier</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.prepare_for_roots_re_scanning" class="fn">prepare_for_roots_re_scanning</a>();

    // Provided methods
    fn <a href="#method.support_slot_enqueuing" class="fn">support_slot_enqueuing</a>(
        _tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        _object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    ) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.scan_object_and_trace_edges" class="fn">scan_object_and_trace_edges</a>&lt;OT: <a class="trait" href="scanning/trait.ObjectTracer.html" title="trait mmtk::vm::scanning::ObjectTracer">ObjectTracer</a>&gt;(
        _tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        _object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        _object_tracer: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut OT</a>,
    ) { ... }
<span class="item-spacer"></span>    fn <a href="#method.process_weak_refs" class="fn">process_weak_refs</a>(
        _worker: &amp;mut <a class="struct" href="../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
        _tracer_context: impl <a class="trait" href="scanning/trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;,
    ) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.forward_weak_refs" class="fn">forward_weak_refs</a>(
        _worker: &amp;mut <a class="struct" href="../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
        _tracer_context: impl <a class="trait" href="scanning/trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;,
    ) { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-specific methods for scanning roots/objects.</p>
</div></details><h2 id="provided-associated-consts" class="section-header">Provided Associated Constants<a href="#provided-associated-consts" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedconstant.UNIQUE_OBJECT_ENQUEUING" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#156">source</a><h4 class="code-header">const <a href="#associatedconstant.UNIQUE_OBJECT_ENQUEUING" class="constant">UNIQUE_OBJECT_ENQUEUING</a>: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a> = false</h4></section></summary><div class="docblock"><p>When set to <code>true</code>, all plans will guarantee that during each GC, each live object is
enqueued at most once, and therefore scanned (by either <a href="scanning/trait.Scanning.html#tymethod.scan_object" title="associated function mmtk::vm::scanning::Scanning::scan_object"><code>Scanning::scan_object</code></a> or
<a href="scanning/trait.Scanning.html#method.scan_object_and_trace_edges" title="associated function mmtk::vm::scanning::Scanning::scan_object_and_trace_edges"><code>Scanning::scan_object_and_trace_edges</code></a>) at most once.</p>
<p>When set to <code>false</code>, MMTk may enqueue an object multiple times due to optimizations, such as
using non-atomic operatios to mark objects.  Consequently, an object may be scanned multiple
times during a GC.</p>
<p>The default value is <code>false</code> because duplicated object-enqueuing is benign for most VMs, and
related optimizations, such as non-atomic marking, can improve GC speed. VM bindings can
override this if they need.  For example, some VMs piggyback on object-scanning to visit
objects during a GC, but may have data race if multiple GC workers visit the same object at
the same time.  Such VMs can set this constant to <code>true</code> to workaround this problem.</p>
</div></details></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.scan_object" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#193-197">source</a><h4 class="code-header">fn <a href="#tymethod.scan_object" class="fn">scan_object</a>&lt;SV: <a class="trait" href="scanning/trait.SlotVisitor.html" title="trait mmtk::vm::scanning::SlotVisitor">SlotVisitor</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;&gt;(
    tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    slot_visitor: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut SV</a>,
)</h4></section></summary><div class="docblock"><p>Delegated scanning of a object, visiting each reference field encountered.</p>
<p>The VM shall call <code>slot_visitor.visit_slot</code> on each reference field.  This effectively
visits all outgoing edges from the current object in the form of slots.</p>
<p>The VM may skip a reference field if it is not holding an object reference (e.g. if the
field is holding a null reference, or a tagged non-reference value such as small integer).
Even if not skipped, <a href="slot/trait.Slot.html#tymethod.load" title="method mmtk::vm::slot::Slot::load"><code>Slot::load</code></a> will still return <code>None</code> if the slot is not holding an
object reference.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
<li><code>slot_visitor</code>: Called back for each field.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.notify_initial_thread_scan_complete" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#233">source</a><h4 class="code-header">fn <a href="#tymethod.notify_initial_thread_scan_complete" class="fn">notify_initial_thread_scan_complete</a>(partial_scan: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>, tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>MMTk calls this method at the first time during a collection that thread’s stacks
have been scanned. This can be used (for example) to clean up
obsolete compiled methods that are no longer being executed.</p>
<p>Arguments:</p>
<ul>
<li><code>partial_scan</code>: Whether the scan was partial or full-heap.</li>
<li><code>tls</code>: The GC thread that is performing the thread scan.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.scan_roots_in_mutator_thread" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#253-257">source</a><h4 class="code-header">fn <a href="#tymethod.scan_roots_in_mutator_thread" class="fn">scan_roots_in_mutator_thread</a>(
    tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    mutator: &amp;'static mut <a class="struct" href="../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;,
    factory: impl <a class="trait" href="scanning/trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;,
)</h4></section></summary><div class="docblock"><p>Scan one mutator for stack roots.</p>
<p>Some VM bindings may not be able to implement this method.
For example, the VM binding may only be able to enumerate all threads and
scan them while enumerating, but cannot scan stacks individually when given
the references of threads.
In that case, it can leave this method empty, and deal with stack
roots in <a href="scanning/trait.Scanning.html#tymethod.scan_vm_specific_roots" title="associated function mmtk::vm::scanning::Scanning::scan_vm_specific_roots"><code>Scanning::scan_vm_specific_roots</code></a>. However, in that case, MMTk
does not know those roots are stack roots, and cannot perform any possible
optimization for the stack roots.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The GC thread that is performing this scanning.</li>
<li><code>mutator</code>: The reference to the mutator whose roots will be scanned.</li>
<li><code>factory</code>: The VM uses it to create work packets for scanning roots.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.scan_vm_specific_roots" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#268">source</a><h4 class="code-header">fn <a href="#tymethod.scan_vm_specific_roots" class="fn">scan_vm_specific_roots</a>(
    tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    factory: impl <a class="trait" href="scanning/trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;,
)</h4></section></summary><div class="docblock"><p>Scan VM-specific roots. The creation of all root scan tasks (except thread scanning)
goes here.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The GC thread that is performing this scanning.</li>
<li><code>factory</code>: The VM uses it to create work packets for scanning roots.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.supports_return_barrier" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#271">source</a><h4 class="code-header">fn <a href="#tymethod.supports_return_barrier" class="fn">supports_return_barrier</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return whether the VM supports return barriers. This is unused at the moment.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.prepare_for_roots_re_scanning" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#281">source</a><h4 class="code-header">fn <a href="#tymethod.prepare_for_roots_re_scanning" class="fn">prepare_for_roots_re_scanning</a>()</h4></section></summary><div class="docblock"><p>Prepare for another round of root scanning in the same GC. Some GC algorithms
need multiple transitive closures, and each transitive closure starts from
root scanning. We expect the binding to provide the same root set for every
round of root scanning in the same GC. Bindings can use this call to get
ready for another round of root scanning to make sure that the same root
set will be returned in the upcoming calls of root scanning methods,
such as <a href="scanning/trait.Scanning.html#tymethod.scan_roots_in_mutator_thread" title="associated function mmtk::vm::scanning::Scanning::scan_roots_in_mutator_thread"><code>crate::vm::Scanning::scan_roots_in_mutator_thread</code></a> and
<a href="scanning/trait.Scanning.html#tymethod.scan_vm_specific_roots" title="associated function mmtk::vm::scanning::Scanning::scan_vm_specific_roots"><code>crate::vm::Scanning::scan_vm_specific_roots</code></a>.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.support_slot_enqueuing" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#171-173">source</a><h4 class="code-header">fn <a href="#method.support_slot_enqueuing" class="fn">support_slot_enqueuing</a>(
    _tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    _object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if the given object supports slot enqueuing.</p>
<ul>
<li>If this returns true, MMTk core will call <code>scan_object</code> on the object.</li>
<li>Otherwise, MMTk core will call <code>scan_object_and_trace_edges</code> on the object.</li>
</ul>
<p>For maximum performance, the VM should support slot-enqueuing for as many objects as
practical.  Also note that this method is called for every object to be scanned, so it
must be fast.  The VM binding should avoid expensive checks and keep it as efficient as
possible.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.scan_object_and_trace_edges" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#218-224">source</a><h4 class="code-header">fn <a href="#method.scan_object_and_trace_edges" class="fn">scan_object_and_trace_edges</a>&lt;OT: <a class="trait" href="scanning/trait.ObjectTracer.html" title="trait mmtk::vm::scanning::ObjectTracer">ObjectTracer</a>&gt;(
    _tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    _object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    _object_tracer: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut OT</a>,
)</h4></section></summary><div class="docblock"><p>Delegated scanning of a object, visiting each reference field encountered, and tracing the
objects pointed by each field.</p>
<p>The VM shall call <code>object_tracer.trace_object</code> with the argument being the object reference
held in each reference field.  If the GC moves the object, the VM shall update the field so
that it refers to the object using the object reference returned from <code>trace_object</code>.  This
effectively traces through all outgoing edges from the current object directly.</p>
<p>The VM must skip reference fields that are not holding object references (e.g. if the
field is holding a null reference, or a tagged non-reference value such as small integer).</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
<li><code>object_tracer</code>: Called back for the object reference held in each field.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.process_weak_refs" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#374-379">source</a><h4 class="code-header">fn <a href="#method.process_weak_refs" class="fn">process_weak_refs</a>(
    _worker: &amp;mut <a class="struct" href="../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
    _tracer_context: impl <a class="trait" href="scanning/trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Process weak references.</p>
<p>This function is called in a GC after the transitive closure from roots is computed, that
is, all reachable objects from roots are reached.  This function gives the VM binding an
opportunitiy to process finalizers and weak references.</p>
<p>MMTk core enables the VM binding to do the following in this function:</p>
<ol>
<li>Query if an object is already reached.
<ul>
<li>by calling <code>ObjectReference::is_reachable()</code></li>
</ul>
</li>
<li>Get the new address of an object if it is already reached.
<ul>
<li>by calling <code>ObjectReference::get_forwarded_object()</code></li>
</ul>
</li>
<li>Keep an object and its descendents alive if not yet reached.
<ul>
<li>using <code>tracer_context</code></li>
</ul>
</li>
<li>Request this function to be called again after transitive closure is finished again.
<ul>
<li>by returning <code>true</code></li>
</ul>
</li>
</ol>
<p>The <code>tracer_context</code> parameter provides the VM binding the mechanism for retaining
unreachable objects (i.e. keeping them alive in this GC).  The following snippet shows a
typical use case of handling finalizable objects for a Java-like language.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>finalizable_objects: Vec&lt;ObjectReference&gt; = my_vm::get_finalizable_object();
<span class="kw">let </span><span class="kw-2">mut </span>new_finalizable_objects = <span class="macro">vec!</span>[];

tracer_context.with_tracer(worker, |tracer| {
    <span class="kw">for </span>object <span class="kw">in </span>finalizable_objects {
        <span class="kw">if </span>object.is_reachable() {
            <span class="comment">// `object` is still reachable.
            // It may have been moved if it is a copying GC.
            </span><span class="kw">let </span>new_object = object.get_forwarded_object().unwrap_or(object);
            new_finalizable_objects.push(new_object);
        } <span class="kw">else </span>{
            <span class="comment">// `object` is unreachable.
            // Retain it, and enqueue it for postponed finalization.
            </span><span class="kw">let </span>new_object = tracer.trace_object(object);
            my_vm::enqueue_finalizable_object_to_be_executed_later(new_object);
        }
    }
});</code></pre></div>
<p>Within the closure <code>|tracer| { ... }</code>, the VM binding can call <code>tracer.trace_object(object)</code>
to retain <code>object</code> and get its new address if moved.  After <code>with_tracer</code> returns, it will
create work packets in the <code>VMRefClosure</code> work bucket to compute the transitive closure from
the objects retained in the closure.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>worker</code>: The current GC worker.</li>
<li><code>tracer_context</code>: Use this to get access an <code>ObjectTracer</code> and use it to retain and update
weak references.</li>
</ul>
<p>If <code>process_weak_refs</code> returns <code>true</code>, then <code>process_weak_refs</code> will be called again after
all work packets in the <code>VMRefClosure</code> work bucket has been executed, by which time all
objects reachable from the objects retained in this function will have been reached.</p>
<h5 id="performance-notes"><a class="doc-anchor" href="#performance-notes">§</a>Performance notes</h5>
<p><strong>Retain as many objects as needed in one invocation of <code>tracer_context.with_tracer</code>, and
avoid calling <code>with_tracer</code> again and again</strong> for each object.  The <code>tracer</code> provided by
<code>ObjectTracerFactory::with_tracer</code> enqueues retained objects in an internal list specific to
this invocation of <code>with_tracer</code>, and will create reasonably sized work packets to compute
the transitive closure.  This means the invocation of <code>with_tracer</code> has a non-trivial
overhead, but each invocation of <code>tracer.trace_object</code> is cheap.</p>
<p><em>Don’t do this</em>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>object <span class="kw">in </span>objects {
    tracer_context.with_tracer(worker, |tracer| { <span class="comment">// This is expensive! DON'T DO THIS!
        </span>tracer.trace_object(object);
    });
}</code></pre></div>
<p><strong>Use <code>ObjectReference::get_forwarded_object()</code> to get the forwarded address of reachable
objects.  Only use <code>tracer.trace_object</code> for retaining unreachable objects.</strong> If
<code>trace_object</code> is called on an already reached object, it will also return its new address
if moved. However, <code>tracer_context.with_tracer</code> has a cost, and the VM binding may
accidentally “resurrect” dead objects if failed to check <code>object.is_reachable()</code> first. If
the VM binding does not intend to retain any objects, it should completely avoid touching
<code>tracer_context</code>.</p>
<p><strong>Clone the <code>tracer_context</code> for parallelism.</strong>  The <code>ObjectTracerContext</code> has <code>Clone</code> as
its supertrait.  The VM binding can clone it and distribute each clone into a work packet.
By doing so, the VM binding can parallelize the processing of finalizers and weak references
by creating multiple work packets.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.forward_weak_refs" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#391-395">source</a><h4 class="code-header">fn <a href="#method.forward_weak_refs" class="fn">forward_weak_refs</a>(
    _worker: &amp;mut <a class="struct" href="../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
    _tracer_context: impl <a class="trait" href="scanning/trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;,
)</h4></section></summary><div class="docblock"><p>Forward weak references.</p>
<p>This function will only be called in the forwarding stage when using the mark-compact GC
algorithm.  Mark-compact computes transive closure twice during each GC.  It marks objects
in the first transitive closure, and forward references in the second transitive closure.</p>
<p>Arguments:</p>
<ul>
<li><code>worker</code>: The current GC worker.</li>
<li><code>tracer_context</code>: Use this to get access an <code>ObjectTracer</code> and use it to update weak
references.</li>
</ul>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.83.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../trait.impl/mmtk/vm/scanning/trait.Scanning.js" async></script></section></div></main></body></html>