<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-specific methods for scanning roots/objects."><title>Scanning in mmtk::vm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../mmtk/index.html">mmtk</a><span class="version">0.29.0-a75309373cd301acad473bbb8ea04670facd6e2a</span></h2></div><h2 class="location"><a href="#">Scanning</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.notify_initial_thread_scan_complete">notify_initial_thread_scan_complete</a></li><li><a href="#tymethod.prepare_for_roots_re_scanning">prepare_for_roots_re_scanning</a></li><li><a href="#tymethod.scan_object">scan_object</a></li><li><a href="#tymethod.scan_roots_in_mutator_thread">scan_roots_in_mutator_thread</a></li><li><a href="#tymethod.scan_vm_specific_roots">scan_vm_specific_roots</a></li><li><a href="#tymethod.supports_return_barrier">supports_return_barrier</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.forward_weak_refs">forward_weak_refs</a></li><li><a href="#method.process_weak_refs">process_weak_refs</a></li><li><a href="#method.scan_object_and_trace_edges">scan_object_and_trace_edges</a></li><li><a href="#method.support_slot_enqueuing">support_slot_enqueuing</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In mmtk::vm</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../mmtk/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../index.html">mmtk</a>::<wbr><a href="index.html">vm</a>::<wbr><a class="trait" href="#">Scanning</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/mmtk/vm/scanning.rs.html#142-350">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait Scanning&lt;VM: <a class="trait" href="trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    // Required methods
    fn <a href="#tymethod.scan_object" class="fn">scan_object</a>&lt;SV: <a class="trait" href="scanning/trait.SlotVisitor.html" title="trait mmtk::vm::scanning::SlotVisitor">SlotVisitor</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;&gt;(
        tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        slot_visitor: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut SV</a>
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.notify_initial_thread_scan_complete" class="fn">notify_initial_thread_scan_complete</a>(
        partial_scan: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a>,
        tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.scan_roots_in_mutator_thread" class="fn">scan_roots_in_mutator_thread</a>(
        tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        mutator: &amp;'static mut <a class="struct" href="../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;,
        factory: impl <a class="trait" href="scanning/trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.scan_vm_specific_roots" class="fn">scan_vm_specific_roots</a>(
        tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        factory: impl <a class="trait" href="scanning/trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.supports_return_barrier" class="fn">supports_return_barrier</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.prepare_for_roots_re_scanning" class="fn">prepare_for_roots_re_scanning</a>();

    // Provided methods
    fn <a href="#method.support_slot_enqueuing" class="fn">support_slot_enqueuing</a>(
        _tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        _object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>
    ) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.scan_object_and_trace_edges" class="fn">scan_object_and_trace_edges</a>&lt;OT: <a class="trait" href="scanning/trait.ObjectTracer.html" title="trait mmtk::vm::scanning::ObjectTracer">ObjectTracer</a>&gt;(
        _tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        _object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        _object_tracer: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut OT</a>
    ) { ... }
<span class="item-spacer"></span>    fn <a href="#method.process_weak_refs" class="fn">process_weak_refs</a>(
        _worker: &amp;mut <a class="struct" href="../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
        _tracer_context: impl <a class="trait" href="scanning/trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;
    ) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.forward_weak_refs" class="fn">forward_weak_refs</a>(
        _worker: &amp;mut <a class="struct" href="../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
        _tracer_context: impl <a class="trait" href="scanning/trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;
    ) { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-specific methods for scanning roots/objects.</p>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.scan_object" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#178-182">source</a><h4 class="code-header">fn <a href="#tymethod.scan_object" class="fn">scan_object</a>&lt;SV: <a class="trait" href="scanning/trait.SlotVisitor.html" title="trait mmtk::vm::scanning::SlotVisitor">SlotVisitor</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;&gt;(
    tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    slot_visitor: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut SV</a>
)</h4></section></summary><div class="docblock"><p>Delegated scanning of a object, visiting each reference field encountered.</p>
<p>The VM shall call <code>slot_visitor.visit_slot</code> on each reference field.  This effectively
visits all outgoing edges from the current object in the form of slots.</p>
<p>The VM may skip a reference field if it is not holding an object reference (e.g. if the
field is holding a null reference, or a tagged non-reference value such as small integer).
Even if not skipped, <a href="slot/trait.Slot.html#tymethod.load" title="method mmtk::vm::slot::Slot::load"><code>Slot::load</code></a> will still return <code>None</code> if the slot is not holding an
object reference.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
<li><code>slot_visitor</code>: Called back for each field.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.notify_initial_thread_scan_complete" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#218">source</a><h4 class="code-header">fn <a href="#tymethod.notify_initial_thread_scan_complete" class="fn">notify_initial_thread_scan_complete</a>(partial_scan: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a>, tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>MMTk calls this method at the first time during a collection that thread’s stacks
have been scanned. This can be used (for example) to clean up
obsolete compiled methods that are no longer being executed.</p>
<p>Arguments:</p>
<ul>
<li><code>partial_scan</code>: Whether the scan was partial or full-heap.</li>
<li><code>tls</code>: The GC thread that is performing the thread scan.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.scan_roots_in_mutator_thread" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#238-242">source</a><h4 class="code-header">fn <a href="#tymethod.scan_roots_in_mutator_thread" class="fn">scan_roots_in_mutator_thread</a>(
    tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    mutator: &amp;'static mut <a class="struct" href="../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;,
    factory: impl <a class="trait" href="scanning/trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;
)</h4></section></summary><div class="docblock"><p>Scan one mutator for stack roots.</p>
<p>Some VM bindings may not be able to implement this method.
For example, the VM binding may only be able to enumerate all threads and
scan them while enumerating, but cannot scan stacks individually when given
the references of threads.
In that case, it can leave this method empty, and deal with stack
roots in <a href="scanning/trait.Scanning.html#tymethod.scan_vm_specific_roots" title="associated function mmtk::vm::scanning::Scanning::scan_vm_specific_roots"><code>Scanning::scan_vm_specific_roots</code></a>. However, in that case, MMTk
does not know those roots are stack roots, and cannot perform any possible
optimization for the stack roots.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The GC thread that is performing this scanning.</li>
<li><code>mutator</code>: The reference to the mutator whose roots will be scanned.</li>
<li><code>factory</code>: The VM uses it to create work packets for scanning roots.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.scan_vm_specific_roots" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#253">source</a><h4 class="code-header">fn <a href="#tymethod.scan_vm_specific_roots" class="fn">scan_vm_specific_roots</a>(
    tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    factory: impl <a class="trait" href="scanning/trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="trait.VMBinding.html#associatedtype.VMSlot" title="type mmtk::vm::VMBinding::VMSlot">VMSlot</a>&gt;
)</h4></section></summary><div class="docblock"><p>Scan VM-specific roots. The creation of all root scan tasks (except thread scanning)
goes here.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The GC thread that is performing this scanning.</li>
<li><code>factory</code>: The VM uses it to create work packets for scanning roots.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.supports_return_barrier" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#256">source</a><h4 class="code-header">fn <a href="#tymethod.supports_return_barrier" class="fn">supports_return_barrier</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return whether the VM supports return barriers. This is unused at the moment.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.prepare_for_roots_re_scanning" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#266">source</a><h4 class="code-header">fn <a href="#tymethod.prepare_for_roots_re_scanning" class="fn">prepare_for_roots_re_scanning</a>()</h4></section></summary><div class="docblock"><p>Prepare for another round of root scanning in the same GC. Some GC algorithms
need multiple transitive closures, and each transitive closure starts from
root scanning. We expect the binding to provide the same root set for every
round of root scanning in the same GC. Bindings can use this call to get
ready for another round of root scanning to make sure that the same root
set will be returned in the upcoming calls of root scanning methods,
such as <a href="scanning/trait.Scanning.html#tymethod.scan_roots_in_mutator_thread" title="associated function mmtk::vm::scanning::Scanning::scan_roots_in_mutator_thread"><code>crate::vm::Scanning::scan_roots_in_mutator_thread</code></a> and
<a href="scanning/trait.Scanning.html#tymethod.scan_vm_specific_roots" title="associated function mmtk::vm::scanning::Scanning::scan_vm_specific_roots"><code>crate::vm::Scanning::scan_vm_specific_roots</code></a>.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.support_slot_enqueuing" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#156-158">source</a><h4 class="code-header">fn <a href="#method.support_slot_enqueuing" class="fn">support_slot_enqueuing</a>(
    _tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    _object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if the given object supports slot enqueuing.</p>
<ul>
<li>If this returns true, MMTk core will call <code>scan_object</code> on the object.</li>
<li>Otherwise, MMTk core will call <code>scan_object_and_trace_edges</code> on the object.</li>
</ul>
<p>For maximum performance, the VM should support slot-enqueuing for as many objects as
practical.  Also note that this method is called for every object to be scanned, so it
must be fast.  The VM binding should avoid expensive checks and keep it as efficient as
possible.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.scan_object_and_trace_edges" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#203-209">source</a><h4 class="code-header">fn <a href="#method.scan_object_and_trace_edges" class="fn">scan_object_and_trace_edges</a>&lt;OT: <a class="trait" href="scanning/trait.ObjectTracer.html" title="trait mmtk::vm::scanning::ObjectTracer">ObjectTracer</a>&gt;(
    _tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    _object: <a class="struct" href="../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    _object_tracer: <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.reference.html">&amp;mut OT</a>
)</h4></section></summary><div class="docblock"><p>Delegated scanning of a object, visiting each reference field encountered, and tracing the
objects pointed by each field.</p>
<p>The VM shall call <code>object_tracer.trace_object</code> with the argument being the object reference
held in each reference field.  If the GC moves the object, the VM shall update the field so
that it refers to the object using the object reference returned from <code>trace_object</code>.  This
effectively traces through all outgoing edges from the current object directly.</p>
<p>The VM must skip reference fields that are not holding object references (e.g. if the
field is holding a null reference, or a tagged non-reference value such as small integer).</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
<li><code>object_tracer</code>: Called back for the object reference held in each field.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.process_weak_refs" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#328-333">source</a><h4 class="code-header">fn <a href="#method.process_weak_refs" class="fn">process_weak_refs</a>(
    _worker: &amp;mut <a class="struct" href="../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
    _tracer_context: impl <a class="trait" href="scanning/trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.77.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Process weak references.</p>
<p>This function is called after a transitive closure is completed.</p>
<p>MMTk core enables the VM binding to do the following in this function:</p>
<ol>
<li>Query if an object is already reached in this transitive closure.</li>
<li>Get the new address of an object if it is already reached.</li>
<li>Keep an object and its descendents alive if not yet reached.</li>
<li>Request this function to be called again after transitive closure is finished again.</li>
</ol>
<p>The VM binding can query if an object is currently reached by calling
<code>ObjectReference::is_reachable()</code>.</p>
<p>If an object is already reached, the VM binding can get its new address by calling
<code>ObjectReference::get_forwarded_object()</code> as the object may have been moved.</p>
<p>If an object is not yet reached, the VM binding can keep that object and its descendents
alive.  To do this, the VM binding should use <code>tracer_context.with_tracer</code> to get access to
an <code>ObjectTracer</code>, and then call its <code>trace_object(object)</code> method.  The <code>trace_object</code>
method will return the new address of the <code>object</code> if it moved the object, or its original
address if not moved.  Implementation-wise, the <code>ObjectTracer</code> may contain an internal
queue for newly traced objects, and will flush the queue when <code>tracer_context.with_tracer</code>
returns. Therefore, it is recommended to reuse the <code>ObjectTracer</code> instance to trace
multiple objects.</p>
<p><em>Note that if <code>trace_object</code> is called on an already reached object, the behavior will be
equivalent to <code>ObjectReference::get_forwarded_object()</code>.  It will return the new address if
the GC already moved the object when tracing that object, or the original address if the GC
did not move the object when tracing it.  In theory, the VM binding can use <code>trace_object</code>
wherever <code>ObjectReference::get_forwarded_object()</code> is needed.  However, if a VM never
resurrects objects, it should completely avoid touching <code>tracer_context</code>, and exclusively
use <code>ObjectReference::get_forwarded_object()</code> to get new addresses of objects.  By doing
so, the VM binding can avoid accidentally resurrecting objects.</em></p>
<p>The VM binding can return <code>true</code> from <code>process_weak_refs</code> to request <code>process_weak_refs</code>
to be called again after the MMTk core finishes transitive closure again from the objects
newly visited by <code>ObjectTracer::trace_object</code>.  This is useful if a VM supports multiple
levels of reachabilities (such as Java) or ephemerons.</p>
<p>Implementation-wise, this function is called as the “sentinel” of the <code>VMRefClosure</code> work
bucket, which means it is called when all work packets in that bucket have finished.  The
<code>tracer_context</code> expands the transitive closure by adding more work packets in the same
bucket.  This means if <code>process_weak_refs</code> returns true, those work packets will have
finished (completing the transitive closure) by the time <code>process_weak_refs</code> is called
again.  The VM binding can make use of this by adding custom work packets into the
<code>VMRefClosure</code> bucket.  The bucket will be <code>VMRefForwarding</code>, instead, when forwarding.
See below.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>worker</code>: The current GC worker.</li>
<li><code>tracer_context</code>: Use this to get access an <code>ObjectTracer</code> and use it to retain and
update weak references.</li>
</ul>
<p>This function shall return true if this function needs to be called again after the GC
finishes expanding the transitive closure from the objects kept alive.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.forward_weak_refs" class="method"><a class="src rightside" href="../../src/mmtk/vm/scanning.rs.html#345-349">source</a><h4 class="code-header">fn <a href="#method.forward_weak_refs" class="fn">forward_weak_refs</a>(
    _worker: &amp;mut <a class="struct" href="../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
    _tracer_context: impl <a class="trait" href="scanning/trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;
)</h4></section></summary><div class="docblock"><p>Forward weak references.</p>
<p>This function will only be called in the forwarding stage when using the mark-compact GC
algorithm.  Mark-compact computes transive closure twice during each GC.  It marks objects
in the first transitive closure, and forward references in the second transitive closure.</p>
<p>Arguments:</p>
<ul>
<li><code>worker</code>: The current GC worker.</li>
<li><code>tracer_context</code>: Use this to get access an <code>ObjectTracer</code> and use it to update weak
references.</li>
</ul>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.77.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../trait.impl/mmtk/vm/scanning/trait.Scanning.js" async></script></section></div></main></body></html>