<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Metadata (OnSide or InHeader) implementation. This is a generic module to work with metadata including side metadata and in-object metadata."><title>mmtk::util::metadata - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../mmtk/index.html">mmtk</a><span class="version">0.30.0-c0f97884234b51b13c8ba5d1563a8e0f592d11c2</span></h2></div><h2 class="location"><a href="#">Module metadata</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section><h2><a href="../index.html">In mmtk::util</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../mmtk/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">mmtk</a>::<wbr><a href="../index.html">util</a>::<wbr><a class="mod" href="#">metadata</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/mmtk/util/metadata/mod.rs.html#1-232">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Metadata (OnSide or InHeader) implementation.
This is a generic module to work with metadata including side metadata and in-object metadata.</p>
<p>This module is designed to enable the implementation of a wide range of GC algorithms for VMs with various combinations of in-object and on-side space for GC-specific metadata (e.g. forwarding bits, marking bit, logging bit, etc.).</p>
<p>The new metadata design differentiates per-object metadata (e.g. forwarding-bits and marking-bit) from other types of metadata including per-address (e.g. VO bit) and per-X (where X != object size), because the per-object metadata can optionally be kept in the object headers.</p>
<p>MMTk acknowledges the VM-dependant nature of the in-object metadata, and asks the VM bindings to contribute by implementing the related parts in the <a href="../../vm/object_model/trait.ObjectModel.html" title="trait mmtk::vm::object_model::ObjectModel">‘ObjectModel’</a>.</p>
<h2 id="side-metadata"><a class="doc-anchor" href="#side-metadata">§</a>Side Metadata</h2><h3 id="design"><a class="doc-anchor" href="#design">§</a>Design</h3>
<p>MMTk side metadata is designed to be <strong>generic</strong>, and <strong>space-</strong> and <strong>time-</strong> efficient.</p>
<p>It aims to support two categories of metadata:</p>
<ol>
<li><strong>Global</strong> metadata bits which are plan-specific but common to all policies, and</li>
<li><strong>Policy-specific</strong> bits which are only used exclusively by certain policies.</li>
</ol>
<p>To support these categories, MMTk metadata provides the following features:</p>
<ol>
<li>The granularity of the source data (minimum data size) is configurable to $2^n$ bytes, where $n &gt;= 0$.</li>
<li>The number of metadata bits per source data unit is configurable to $2^m$ bits, where $m &gt;= 0$.</li>
<li>The total number of metadata bit-sets is constrained by the worst-case ratio of global and policy-specific metadata.</li>
<li>Metadata space is only allocated on demand.</li>
<li>Bulk-zeroing of metadata bits should be possible. For this, the memory space for each metadata bit-set is contiguous per chunk.</li>
</ol>
<h4 id="64-bits-targets"><a class="doc-anchor" href="#64-bits-targets">§</a>64-bits targets</h4>
<p>‌ In 64-bits targets, each MMTk side metadata bit-set is organized as a contiguous space.
The base address for both the global and the local side metadata are constants (e.g. <code>GLOBAL_SIDE_METADATA_BASE_ADDRESS</code> and <code>LOCAL_SIDE_METADATA_BASE_ADDRESS</code>).</p>
<p>In this case, a schematic of the local and global side metadata looks like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> _______________________________ &lt;= global-<span class="number">1 </span>= GLOBAL_SIDE_METADATA_BASE_ADDRESS
 |                             |
 |        Global-<span class="number">1             </span>|
 |_____________________________| &lt;= global-<span class="number">2 </span>= global-<span class="number">1 </span>+
 |                             |                 metadata_address_range_size(global-<span class="number">1</span>)
 |        Global-<span class="number">2             </span>|
 |                             |
 |_____________________________| &lt;= global-<span class="number">3 </span>= global-<span class="number">2 </span>+
 |                             |                 metadata_address_range_size(global-<span class="number">2</span>)
 |        Not Mapped           |
 |                             |
 |_____________________________| &lt;= global-end = GLOBAL_SIDE_METADATA_BASE_ADDRESS +
 |                             |         MAX_HEAP_SIZE * Global_WCR
 |                             |
 |                             |
 |_____________________________| &lt;= local-<span class="number">1 </span>= LOCAL_SIDE_METADATA_BASE_ADDRESS
 |                             |
 |      PolicySpecific-<span class="number">1       </span>|
 |                             |
 |_____________________________| &lt;= local-<span class="number">2 </span>= local-<span class="number">1 </span>+ metadata_address_range_size(local-<span class="number">1</span>)
 |                             |
 |      PolicySpecific-<span class="number">2       </span>|
 |                             |
 |_____________________________| &lt;= local-<span class="number">3 </span>= local-<span class="number">2 </span>+ metadata_address_range_size(local-<span class="number">2</span>)
 |                             |
 |         Not Mapped          |
 |                             |
 |                             |
 |_____________________________| &lt;= local-end = LOCAL_SIDE_METADATA_BASE_ADDRESS +
                                         MAX_HEAP_SIZE * PolicySpecific_WCR</code></pre></div>
<p>‌
‌ ### 32-bits targets</p>
<p>In 32-bits targets, the global side metadata is organized the same way as 64-bits, but the policy-specific side metadata is organized per chunk of data (each chunk is managed exclusively by one policy).
This means, when a new chunk is mapped, the policy-specific side metadata for the whole chunk is also mapped.</p>
<p>In this case, a schematic of the local and global side metadata looks like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> _______________________________ &lt;= global-<span class="number">1 </span>= GLOBAL_SIDE_METADATA_BASE_ADDRESS(e.g. <span class="number">0x1000_0000</span>)
 |                             |
 |        Global-<span class="number">1             </span>|
 |_____________________________| &lt;= global-<span class="number">2 </span>= global-<span class="number">1 </span>+
 |                             |                 metadata_address_range_size(global-<span class="number">1</span>)
 |        Global-<span class="number">2             </span>|
 |                             |
 |_____________________________| &lt;= global-<span class="number">3 </span>= global-<span class="number">2 </span>+
 |                             |                 metadata_address_range_size(global-<span class="number">2</span>)
 |        Not Mapped           |
 |                             |
 |_____________________________| &lt;= global-end = GLOBAL_SIDE_METADATA_BASE_ADDRESS +
 |                             |         MAX_HEAP_SIZE * Global_WCR
 |                             |
 |                             |
 |_____________________________| &lt;= LOCAL_SIDE_METADATA_BASE_ADDRESS
 |                             |
 |      PolicySpecific         |
 |                             |
 |                             |
 |                             |
 |_____________________________| &lt;= local-end = LOCAL_SIDE_METADATA_BASE_ADDRESS +
                                         MAX_HEAP_SIZE * PolicySpecific_WCR</code></pre></div>
<p>‌ And inside the PolicySpecific space, each per chunk policy-specific side metadata looks like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> _______________________________     &lt;= offset-<span class="number">1 </span>= <span class="number">0x0
 </span>|                             |
 |        Local-<span class="number">1              </span>|
 |_____________________________|     &lt;= offset-<span class="number">2 </span>= metadata_bytes_per_chunk(Local-<span class="number">1</span>)
 |                             |
 |        Local-<span class="number">2              </span>|
 |                             |
 |_____________________________|     &lt;= offset-g3 = offset-g2 + metadata_bytes_per_chunk(Local-<span class="number">2</span>)
 |                             |
 |        Not Mapped           |
 |                             |
 |_____________________________|     &lt;= <span class="number">4MB </span>* PolicySpecific_WCR</code></pre></div>
<h2 id="how-to-use"><a class="doc-anchor" href="#how-to-use">§</a>How to Use</h2><h3 id="declare-metadata-specs"><a class="doc-anchor" href="#declare-metadata-specs">§</a>Declare metadata specs</h3>
<p>For each global metadata bit-set, a constant instance of the <code>MetadataSpec</code> struct should be created.</p>
<p>If the metadata is per-object and may possibly reside in objects, the constant instance should be created in the VM’s ObjectModel.
For instance, the forwarding-bits metadata spec should be assigned to <code>LOCAL_FORWARDING_BITS_SPEC</code> in <a href="../../vm/object_model/trait.ObjectModel.html" title="trait mmtk::vm::object_model::ObjectModel"><code>ObjectModel</code></a>.
The VM binding decides whether to put these metadata bit-sets in-objects or on-side.</p>
<p>For other metadata bit-sets, constant <code>MetadataSpec</code> instances, created inside MMTk by plans/policies, are used in conjunction with the access functions from the current module.</p>
<p>Example:</p>
<p>For the first global side metadata bit-set:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>GLOBAL_META_1: MetadataSpec = MetadataSpec {
   is_side_metadata: <span class="bool-val">true</span>,
   is_global: <span class="bool-val">true</span>,
   offset: GLOBAL_SIDE_METADATA_BASE_ADDRESS,
   log_num_of_bits: b1,
   log_bytes_in_region: s1,
};</code></pre></div>
<p>Here, the number of bits per data is $2^b1$, and the minimum object size is $2^s1$.
The <code>offset</code> is actually the base address for a global side metadata bit-set.
For the first bit-set, <code>offset</code> is <code>GLOBAL_SIDE_METADATA_BASE_ADDRESS</code>.</p>
<p>Now, to add a second side metadata bit-set, offset needs to be calculated based-on the first global bit-set:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>GLOBAL_META_2: MetadataSpec = MetadataSpec {
   is_side_metadata: <span class="bool-val">true</span>,
    is_global: <span class="bool-val">true</span>,
   offset: GLOBAL_META_1.offset + metadata_address_range_size(GLOBAL_META_1)
   log_num_of_bits: b2,
   log_bytes_in_region: s2,
};</code></pre></div>
<p>where <code>metadata_address_range_size</code> is a const function which calculates the total metadata space size of a contiguous side metadata bit-set based-on <code>s</code> and <code>b</code>.</p>
<p>The policy-specific side metadata for 64-bits targets, and the global side metadata for 32-bits targets are used on the same way, except that their base addresses are different.</p>
<p>Policy-specific side metadata for 32-bits target is slightly different, because it is chunk-based.</p>
<p>For the first local side metadata bit-set:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>LOCAL_META_1: MetadataSpec = MetadataSpec {
   is_side_metadata: <span class="bool-val">true</span>,
   is_global: <span class="bool-val">false</span>,
   offset: <span class="number">0</span>,
   log_num_of_bits: b1,
   log_bytes_in_region: s1,
};</code></pre></div>
<p>Here, the <code>offset</code> is actually the inter-chunk offset of the side metadata from the start of the current side metadata chunk.</p>
<p>Now, to add a second side metadata bit-set, offset needs to be calculated based-on the first global bit-set:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>LOCAL_META_2: MetadataSpec = MetadataSpec {
   is_side_metadata: <span class="bool-val">true</span>,
   is_global: <span class="bool-val">false</span>,
   offset: LOCAL_META_1.offset + metadata_bytes_per_chunk(LOCAL_META_1)
   log_num_of_bits: b2,
   log_bytes_in_region: s2,
};</code></pre></div>
<p>So far, we declared each metadata specs.
We can now use the in-object metadata through the access functions in the VM bindings ObjectModel.
For side metadata, the next step is to allocate metadata space.</p>
<h3 id="create-and-allocate-side-metadata-for-spaces"><a class="doc-anchor" href="#create-and-allocate-side-metadata-for-spaces">§</a>Create and allocate side metadata for spaces</h3>
<p>A space needs to know all global metadata specs and its own policy-specific/local metadata specs in order to calculate and allocate metadata space.
When a space is created by a plan (e.g. SemiSpace::new), the plan can create its global specs by <code>MetadataContext::new_global_specs(&amp;[GLOBAL_META_1, GLOBAL_META_2])</code>. Then,
the global specs are passed to each space that the plan creates.</p>
<p>Each space will then combine the global specs and its own local specs to create a SideMetadataContext.
Allocating side metadata space and accounting its memory usage is done by <code>SideMetadata</code>. If a space uses <code>CommonSpace</code>, <code>CommonSpace</code> will create <code>SideMetadata</code> and manage
reserving and allocating metadata space when necessary. If a space does not use <code>CommonSpace</code>, it should create <code>SideMetadata</code> itself and manage allocating metadata space
as its own responsibility.</p>
<h3 id="access-side-metadata"><a class="doc-anchor" href="#access-side-metadata">§</a>Access side metadata</h3>
<p>After mapping the metadata space, the following operations can be performed with a specific metadata spec:</p>
<ol>
<li>atomic load</li>
<li>atomic store</li>
<li>atomic compare-and-exchange</li>
<li>atomic fetch-and-add</li>
<li>atomic fetch-and-sub</li>
<li>load (non-atomic)</li>
<li>store (non-atomic)</li>
<li>bulk zeroing</li>
</ol>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="global/index.html" title="mod mmtk::util::metadata::global">global</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="header_metadata/index.html" title="mod mmtk::util::metadata::header_metadata">header_metadata</a></div><div class="desc docblock-short">This module provides a default implementation of the access functions for in-header metadata.</div></li><li><div class="item-name"><a class="mod" href="log_bit/index.html" title="mod mmtk::util::metadata::log_bit">log_bit</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="mark_bit/index.html" title="mod mmtk::util::metadata::mark_bit">mark_bit</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="metadata_val_traits/index.html" title="mod mmtk::util::metadata::metadata_val_traits">metadata_val_traits</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="pin_bit/index.html" title="mod mmtk::util::metadata::pin_bit">pin_bit</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="side_metadata/index.html" title="mod mmtk::util::metadata::side_metadata">side_metadata</a></div><div class="desc docblock-short">This module provides an implementation of side table metadata.</div></li><li><div class="item-name"><a class="mod" href="vo_bit/index.html" title="mod mmtk::util::metadata::vo_bit">vo_bit</a></div><div class="desc docblock-short">Valid object bit (VO bit)</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.MetadataSpec.html" title="enum mmtk::util::metadata::MetadataSpec">MetadataSpec</a></div><div class="desc docblock-short">This struct stores the specification of a metadata bit-set.
It is used as an input to the (inline) functions provided by the side metadata module.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Bits.html" title="trait mmtk::util::metadata::Bits">Bits</a></div><div class="desc docblock-short">Describes bits and log2 bits for the numbers.
If num_traits has this, we do not need our own implementation: <a href="https://github.com/rust-num/num-traits/issues/247">https://github.com/rust-num/num-traits/issues/247</a></div></li><li><div class="item-name"><a class="trait" href="trait.BitwiseOps.html" title="trait mmtk::util::metadata::BitwiseOps">BitwiseOps</a></div><div class="desc docblock-short">Describes bitwise operations.
If num_traits has this, we do not need our own implementation: <a href="https://github.com/rust-num/num-traits/issues/232">https://github.com/rust-num/num-traits/issues/232</a></div></li><li><div class="item-name"><a class="trait" href="trait.MetadataValue.html" title="trait mmtk::util::metadata::MetadataValue">MetadataValue</a></div><div class="desc docblock-short">The number type for accessing metadata.
It requires a few traits from num-traits and a few traits we defined above.
The methods in this trait are mostly about atomically accessing such types.</div></li></ul></section></div></main></body></html>