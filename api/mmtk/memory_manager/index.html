<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-to-MMTk interface: safe Rust APIs."><title>mmtk::memory_manager - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../mmtk/index.html">mmtk</a><span class="version">0.29.0-cd2fe83dc84a264da17df81875517b7406ec7617</span></h2></div><h2 class="location"><a href="#">Module memory_manager</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate mmtk</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../mmtk/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">mmtk</a>::<wbr><a class="mod" href="#">memory_manager</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/mmtk/memory_manager.rs.html#1-910">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-to-MMTk interface: safe Rust APIs.</p>
<p>This module provides a safe Rust API for mmtk-core.
We expect the VM binding to inherit and extend this API by:</p>
<ol>
<li>adding their VM-specific functions</li>
<li>exposing the functions to native if necessary. And the VM binding needs to manage the unsafety
for exposing this safe API to FFI.</li>
</ol>
<p>For example, for mutators, this API provides a <code>Box&lt;Mutator&gt;</code>, and requires a <code>&amp;mut Mutator</code> for allocation.
A VM binding can borrow a mutable reference directly from <code>Box&lt;Mutator&gt;</code>, and call <code>alloc()</code>. Alternatively,
it can turn the <code>Box</code> pointer to a native pointer (<code>*mut Mutator</code>), and forge a mut reference from the native
pointer. Either way, the VM binding code needs to guarantee the safety.</p>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.add_finalizer.html" title="fn mmtk::memory_manager::add_finalizer">add_finalizer</a></div><div class="desc docblock-short">Register a finalizable object. MMTk will retain the liveness of
the object even if it is not reachable from the program.
Note that finalization upon exit is not supported.</div></li><li><div class="item-name"><a class="fn" href="fn.add_phantom_candidate.html" title="fn mmtk::memory_manager::add_phantom_candidate">add_phantom_candidate</a></div><div class="desc docblock-short">Add a reference to the list of phantom references. A binding may
call this either when a weak reference is created, or when a weak reference is traced during GC.</div></li><li><div class="item-name"><a class="fn" href="fn.add_soft_candidate.html" title="fn mmtk::memory_manager::add_soft_candidate">add_soft_candidate</a></div><div class="desc docblock-short">Add a reference to the list of soft references. A binding may
call this either when a weak reference is created, or when a weak reference is traced during GC.</div></li><li><div class="item-name"><a class="fn" href="fn.add_weak_candidate.html" title="fn mmtk::memory_manager::add_weak_candidate">add_weak_candidate</a></div><div class="desc docblock-short">Add a reference to the list of weak references. A binding may
call this either when a weak reference is created, or when a weak reference is traced during GC.</div></li><li><div class="item-name"><a class="fn" href="fn.add_work_packet.html" title="fn mmtk::memory_manager::add_work_packet">add_work_packet</a></div><div class="desc docblock-short">Add a work packet to the given work bucket. Note that this simply adds the work packet to the given
work bucket, and the scheduler will decide when to execute the work packet.</div></li><li><div class="item-name"><a class="fn" href="fn.add_work_packets.html" title="fn mmtk::memory_manager::add_work_packets">add_work_packets</a></div><div class="desc docblock-short">Bulk add a number of work packets to the given work bucket. Note that this simply adds the work packets
to the given work bucket, and the scheduler will decide when to execute the work packets.</div></li><li><div class="item-name"><a class="fn" href="fn.alloc.html" title="fn mmtk::memory_manager::alloc">alloc</a></div><div class="desc docblock-short">Allocate memory for an object. For performance reasons, a VM should
implement the allocation fast-path on their side rather than just calling this function.</div></li><li><div class="item-name"><a class="fn" href="fn.alloc_slow.html" title="fn mmtk::memory_manager::alloc_slow">alloc_slow</a></div><div class="desc docblock-short">Invoke the allocation slow path. This is only intended for use when a binding implements the fastpath on
the binding side. When the binding handles fast path allocation and the fast path fails, it can use this
method for slow path allocation. Calling before exhausting fast path allocaiton buffer will lead to bad
performance.</div></li><li><div class="item-name"><a class="fn" href="fn.bind_mutator.html" title="fn mmtk::memory_manager::bind_mutator">bind_mutator</a></div><div class="desc docblock-short">Request MMTk to create a mutator for the given thread. The ownership
of returned boxed mutator is transferred to the binding, and the binding needs to take care of its
lifetime. For performance reasons, A VM should store the returned mutator in a thread local storage
that can be accessed efficiently. A VM may also copy and embed the mutator stucture to a thread-local data
structure, and use that as a reference to the mutator (it is okay to drop the box once the content is copied –
Note that <code>Mutator</code> may contain pointers so a binding may drop the box only if they perform a deep copy).</div></li><li><div class="item-name"><a class="fn" href="fn.calloc.html" title="fn mmtk::memory_manager::calloc">calloc</a></div><div class="desc docblock-short">The standard calloc.</div></li><li><div class="item-name"><a class="fn" href="fn.counted_calloc.html" title="fn mmtk::memory_manager::counted_calloc">counted_calloc</a></div><div class="desc docblock-short">The standard calloc except that with the feature <code>malloc_counted_size</code>, MMTk will count the allocated memory into its heap size.
Thus the method requires a reference to an MMTk instance.</div></li><li><div class="item-name"><a class="fn" href="fn.counted_malloc.html" title="fn mmtk::memory_manager::counted_malloc">counted_malloc</a></div><div class="desc docblock-short">The standard malloc except that with the feature <code>malloc_counted_size</code>, MMTk will count the allocated memory into its heap size.
Thus the method requires a reference to an MMTk instance. MMTk either uses its own allocator, or forward the call to a
library malloc.</div></li><li><div class="item-name"><a class="fn" href="fn.destroy_mutator.html" title="fn mmtk::memory_manager::destroy_mutator">destroy_mutator</a></div><div class="desc docblock-short">Report to MMTk that a mutator is no longer needed. All mutator state is flushed before it is
destroyed. A binding should not attempt to use the mutator after this call. MMTk will not
attempt to reclaim the memory for the mutator, so a binding should properly reclaim the memory
for the mutator after this call.</div></li><li><div class="item-name"><a class="fn" href="fn.find_object_from_internal_pointer.html" title="fn mmtk::memory_manager::find_object_from_internal_pointer">find_object_from_internal_pointer</a></div><div class="desc docblock-short">Find if there is an object with VO bit set for the given address range.
This should be used instead of <a href="fn.is_mmtk_object.html" title="fn mmtk::memory_manager::is_mmtk_object"><code>crate::memory_manager::is_mmtk_object</code></a> for conservative stack scanning if
the binding may have internal pointers on the stack.</div></li><li><div class="item-name"><a class="fn" href="fn.flush_mutator.html" title="fn mmtk::memory_manager::flush_mutator">flush_mutator</a></div><div class="desc docblock-short">Flush the mutator’s local states.</div></li><li><div class="item-name"><a class="fn" href="fn.free.html" title="fn mmtk::memory_manager::free">free</a></div><div class="desc docblock-short">The standard free.
The <code>addr</code> in the arguments must be an address that is earlier returned from MMTk’s <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.free_bytes.html" title="fn mmtk::memory_manager::free_bytes">free_bytes</a></div><div class="desc docblock-short">Return free memory in bytes. MMTk accounts for memory in pages, thus this method always returns a value in
page granularity.</div></li><li><div class="item-name"><a class="fn" href="fn.free_with_size.html" title="fn mmtk::memory_manager::free_with_size">free_with_size</a></div><div class="desc docblock-short">The standard free except that with the feature <code>malloc_counted_size</code>, MMTk will count the allocated memory into its heap size.
Thus the method requires a reference to an MMTk instance, and the size of the memory to free.
The <code>addr</code> in the arguments must be an address that is earlier returned from MMTk’s <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.gc_poll.html" title="fn mmtk::memory_manager::gc_poll">gc_poll</a></div><div class="desc docblock-short">Poll for GC. MMTk will decide if a GC is needed. If so, this call will block
the current thread, and trigger a GC. Otherwise, it will simply return.
Usually a binding does not need to call this function. MMTk will poll for GC during its allocation.
However, if a binding uses counted malloc (which won’t poll for GC), they may want to poll for GC manually.
This function should only be used by mutator threads.</div></li><li><div class="item-name"><a class="fn" href="fn.get_all_finalizers.html" title="fn mmtk::memory_manager::get_all_finalizers">get_all_finalizers</a></div><div class="desc docblock-short">Pop all the finalizers that were registered for finalization. The returned objects may or may not be ready for
finalization. After this call, MMTk’s finalizer processor should have no registered finalizer any more.</div></li><li><div class="item-name"><a class="fn" href="fn.get_allocator_mapping.html" title="fn mmtk::memory_manager::get_allocator_mapping">get_allocator_mapping</a></div><div class="desc docblock-short">Return an AllocatorSelector for the given allocation semantic. This method is provided
so that VM compilers may call it to help generate allocation fast-path.</div></li><li><div class="item-name"><a class="fn" href="fn.get_finalized_object.html" title="fn mmtk::memory_manager::get_finalized_object">get_finalized_object</a></div><div class="desc docblock-short">Get an object that is ready for finalization. After each GC, if any registered object is not
alive, this call will return one of the objects. MMTk will retain the liveness of those objects
until they are popped through this call. Once an object is popped, it is the responsibility of
the VM to make sure they are properly finalized before reclaimed by the GC. This call is non-blocking,
and will return None if no object is ready for finalization.</div></li><li><div class="item-name"><a class="fn" href="fn.get_finalizers_for.html" title="fn mmtk::memory_manager::get_finalizers_for">get_finalizers_for</a></div><div class="desc docblock-short">Pop finalizers that were registered and associated with a certain object. The returned objects may or may not be ready for finalization.
This is useful for some VMs that may manually execute finalize method for an object.</div></li><li><div class="item-name"><a class="fn" href="fn.get_malloc_bytes.html" title="fn mmtk::memory_manager::get_malloc_bytes">get_malloc_bytes</a></div><div class="desc docblock-short">Get the current active malloc’d bytes. Here MMTk only accounts for bytes that are done through those ‘counted malloc’ functions.</div></li><li><div class="item-name"><a class="fn" href="fn.handle_user_collection_request.html" title="fn mmtk::memory_manager::handle_user_collection_request">handle_user_collection_request</a></div><div class="desc docblock-short">The application code has requested a collection. This is just a GC hint, and
we may ignore it.</div></li><li><div class="item-name"><a class="fn" href="fn.harness_begin.html" title="fn mmtk::memory_manager::harness_begin">harness_begin</a></div><div class="desc docblock-short">Generic hook to allow benchmarks to be harnessed. We do a full heap
GC, and then start recording statistics for MMTk.</div></li><li><div class="item-name"><a class="fn" href="fn.harness_end.html" title="fn mmtk::memory_manager::harness_end">harness_end</a></div><div class="desc docblock-short">Generic hook to allow benchmarks to be harnessed. We stop collecting
statistics, and print stats values.</div></li><li><div class="item-name"><a class="fn" href="fn.initialize_collection.html" title="fn mmtk::memory_manager::initialize_collection">initialize_collection</a></div><div class="desc docblock-short">Wrapper for <a href="../mmtk/struct.MMTK.html#method.initialize_collection" title="method mmtk::mmtk::MMTK::initialize_collection"><code>crate::mmtk::MMTK::initialize_collection</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.is_in_mmtk_spaces.html" title="fn mmtk::memory_manager::is_in_mmtk_spaces">is_in_mmtk_spaces</a></div><div class="desc docblock-short">Return true if the <code>object</code> lies in a region of memory where</div></li><li><div class="item-name"><a class="fn" href="fn.is_live_object.html" title="fn mmtk::memory_manager::is_live_object">is_live_object</a></div><div class="desc docblock-short">Is the object alive?</div></li><li><div class="item-name"><a class="fn" href="fn.is_mapped_address.html" title="fn mmtk::memory_manager::is_mapped_address">is_mapped_address</a></div><div class="desc docblock-short">Is the address in the mapped memory? The runtime can use this function to check
if an address is mapped by MMTk. Note that this is different than is_in_mmtk_spaces().
For malloc spaces, MMTk does not map those addresses (malloc does the mmap), so
this function will return false, but is_in_mmtk_spaces will return true if the address
is actually a valid object in malloc spaces. To check if an object is in our heap,
the runtime should always use is_in_mmtk_spaces(). This function is_mapped_address()
may get removed at some point.</div></li><li><div class="item-name"><a class="fn" href="fn.is_mmtk_object.html" title="fn mmtk::memory_manager::is_mmtk_object">is_mmtk_object</a></div><div class="desc docblock-short">Check if <code>addr</code> is the raw address of an object reference to an MMTk object.</div></li><li><div class="item-name"><a class="fn" href="fn.is_pinned.html" title="fn mmtk::memory_manager::is_pinned">is_pinned</a></div><div class="desc docblock-short">Check whether an object is currently pinned</div></li><li><div class="item-name"><a class="fn" href="fn.last_heap_address.html" title="fn mmtk::memory_manager::last_heap_address">last_heap_address</a></div><div class="desc docblock-short">Return the ending address of the heap. <em>Note that currently MMTk uses
a fixed address range as heap.</em></div></li><li><div class="item-name"><a class="fn" href="fn.live_bytes_in_last_gc.html" title="fn mmtk::memory_manager::live_bytes_in_last_gc">live_bytes_in_last_gc</a></div><div class="desc docblock-short">Return the size of all the live objects in bytes in the last GC. MMTk usually accounts for memory in pages.
This is a special method that we count the size of every live object in a GC, and sum up the total bytes.
We provide this method so users can compare with <code>used_bytes</code> (which does page accounting), and know if
the heap is fragmented.
The value returned by this method is only updated when we finish tracing in a GC. A recommended timing
to call this method is at the end of a GC (e.g. when the runtime is about to resume threads).</div></li><li><div class="item-name"><a class="fn" href="fn.malloc.html" title="fn mmtk::memory_manager::malloc">malloc</a></div><div class="desc docblock-short">The standard malloc. MMTk either uses its own allocator, or forward the call to a
library malloc.</div></li><li><div class="item-name"><a class="fn" href="fn.memory_region_copy.html" title="fn mmtk::memory_manager::memory_region_copy">memory_region_copy</a></div><div class="desc docblock-short">The <em>subsuming</em> memory region copy barrier by MMTk.
This is called when the VM tries to copy a piece of heap memory to another.
The data within the slice does not necessarily to be all valid pointers,
but the VM binding will be able to filter out non-reference values on slot iteration.</div></li><li><div class="item-name"><a class="fn" href="fn.memory_region_copy_post.html" title="fn mmtk::memory_manager::memory_region_copy_post">memory_region_copy_post</a></div><div class="desc docblock-short">The <em>generic</em> memory region copy <em>post</em> barrier by MMTk, which we expect a binding to call
<em>after</em> it performs memory copy.
This is called when the VM tries to copy a piece of heap memory to another.
The data within the slice does not necessarily to be all valid pointers,
but the VM binding will be able to filter out non-reference values on slot iteration.</div></li><li><div class="item-name"><a class="fn" href="fn.memory_region_copy_pre.html" title="fn mmtk::memory_manager::memory_region_copy_pre">memory_region_copy_pre</a></div><div class="desc docblock-short">The <em>generic</em> memory region copy <em>pre</em> barrier by MMTk, which we expect a binding to call
<em>before</em> it performs memory copy.
This is called when the VM tries to copy a piece of heap memory to another.
The data within the slice does not necessarily to be all valid pointers,
but the VM binding will be able to filter out non-reference values on slot iteration.</div></li><li><div class="item-name"><a class="fn" href="fn.mmtk_init.html" title="fn mmtk::memory_manager::mmtk_init">mmtk_init</a></div><div class="desc docblock-short">Initialize an MMTk instance. A VM should call this method after creating an <a href="../mmtk/struct.MMTK.html" title="struct mmtk::mmtk::MMTK"><code>crate::MMTK</code></a>
instance but before using any of the methods provided in MMTk (except <code>process()</code> and <code>process_bulk()</code>).</div></li><li><div class="item-name"><a class="fn" href="fn.num_of_workers.html" title="fn mmtk::memory_manager::num_of_workers">num_of_workers</a></div><div class="desc docblock-short">Get the number of workers. MMTk spawns worker threads for the ‘threads’ defined in the options.
So the number of workers is derived from the threads option. Note the feature single_worker overwrites
the threads option, and force one worker thread.</div></li><li><div class="item-name"><a class="fn" href="fn.object_reference_write.html" title="fn mmtk::memory_manager::object_reference_write">object_reference_write</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">The <em>subsuming</em> write barrier by MMTk. For performance reasons, a VM should implement the write barrier
fast-path on their side rather than just calling this function.</div></li><li><div class="item-name"><a class="fn" href="fn.object_reference_write_post.html" title="fn mmtk::memory_manager::object_reference_write_post">object_reference_write_post</a></div><div class="desc docblock-short">The write barrier by MMTk. This is a <em>post</em> write barrier, which we expect a binding to call
<em>after</em> it modifies an object. For performance reasons, a VM should implement the write barrier
fast-path on their side rather than just calling this function.</div></li><li><div class="item-name"><a class="fn" href="fn.object_reference_write_pre.html" title="fn mmtk::memory_manager::object_reference_write_pre">object_reference_write_pre</a></div><div class="desc docblock-short">The write barrier by MMTk. This is a <em>pre</em> write barrier, which we expect a binding to call
<em>before</em> it modifies an object. For performance reasons, a VM should implement the write barrier
fast-path on their side rather than just calling this function.</div></li><li><div class="item-name"><a class="fn" href="fn.pin_object.html" title="fn mmtk::memory_manager::pin_object">pin_object</a></div><div class="desc docblock-short">Pin an object. MMTk will make sure that the object does not move
during GC. Note that action cannot happen in some plans, eg, semispace.
It returns true if the pinning operation has been performed, i.e.,
the object status changed from non-pinned to pinned</div></li><li><div class="item-name"><a class="fn" href="fn.post_alloc.html" title="fn mmtk::memory_manager::post_alloc">post_alloc</a></div><div class="desc docblock-short">Perform post-allocation actions, usually initializing object metadata. For many allocators none are
required. For performance reasons, a VM should implement the post alloc fast-path on their side
rather than just calling this function.</div></li><li><div class="item-name"><a class="fn" href="fn.process.html" title="fn mmtk::memory_manager::process">process</a></div><div class="desc docblock-short">Process MMTk run-time options. Returns true if the option is processed successfully.</div></li><li><div class="item-name"><a class="fn" href="fn.process_bulk.html" title="fn mmtk::memory_manager::process_bulk">process_bulk</a></div><div class="desc docblock-short">Process multiple MMTk run-time options. Returns true if all the options are processed successfully.</div></li><li><div class="item-name"><a class="fn" href="fn.realloc.html" title="fn mmtk::memory_manager::realloc">realloc</a></div><div class="desc docblock-short">The standard realloc.</div></li><li><div class="item-name"><a class="fn" href="fn.realloc_with_old_size.html" title="fn mmtk::memory_manager::realloc_with_old_size">realloc_with_old_size</a></div><div class="desc docblock-short">The standard realloc except that with the feature <code>malloc_counted_size</code>, MMTk will count the allocated memory into its heap size.
Thus the method requires a reference to an MMTk instance, and the size of the existing memory that will be reallocated.
The <code>addr</code> in the arguments must be an address that is earlier returned from MMTk’s <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.set_vm_space.html" title="fn mmtk::memory_manager::set_vm_space">set_vm_space</a></div><div class="desc docblock-short">Add an externally mmapped region to the VM space. A VM space can be set through MMTk options (<code>vm_space_start</code> and <code>vm_space_size</code>),
and can also be set through this function call. A VM space can be discontiguous. This function can be called multiple times,
and all the address ranges passed as arguments in the function will be considered as part of the VM space.
Currently we do not allow removing regions from VM space.</div></li><li><div class="item-name"><a class="fn" href="fn.start_worker.html" title="fn mmtk::memory_manager::start_worker">start_worker</a></div><div class="desc docblock-short">Wrapper for <a href="../scheduler/worker/struct.GCWorker.html#method.run" title="method mmtk::scheduler::worker::GCWorker::run"><code>crate::scheduler::GCWorker::run</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.starting_heap_address.html" title="fn mmtk::memory_manager::starting_heap_address">starting_heap_address</a></div><div class="desc docblock-short">Return the starting address of the heap. <em>Note that currently MMTk uses
a fixed address range as heap.</em></div></li><li><div class="item-name"><a class="fn" href="fn.total_bytes.html" title="fn mmtk::memory_manager::total_bytes">total_bytes</a></div><div class="desc docblock-short">Return the total memory in bytes.</div></li><li><div class="item-name"><a class="fn" href="fn.unpin_object.html" title="fn mmtk::memory_manager::unpin_object">unpin_object</a></div><div class="desc docblock-short">Unpin an object.
Returns true if the unpinning operation has been performed, i.e.,
the object status changed from pinned to non-pinned</div></li><li><div class="item-name"><a class="fn" href="fn.used_bytes.html" title="fn mmtk::memory_manager::used_bytes">used_bytes</a></div><div class="desc docblock-short">Return used memory in bytes. MMTk accounts for memory in pages, thus this method always returns a value in
page granularity.</div></li></ul></section></div></main></body></html>