<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `gc_work` mod in crate `mmtk`."><title>mmtk::scheduler::gc_work - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module gc_work</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../mmtk/index.html">mmtk</a><span class="version">0.31.0-56adff4da608196dbd3da25f812ae64617aa1c1e</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module gc_work</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In mmtk::<wbr>scheduler</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">mmtk</a>::<wbr><a href="../index.html">scheduler</a></div><h1>Module <span>gc_work</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/mmtk/scheduler/gc_work.rs.html#1-1224">Source</a> </span></div><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.PlanProcessEdges.html" title="struct mmtk::scheduler::gc_work::PlanProcessEdges">Plan<wbr>Process<wbr>Edges</a></dt><dd>This provides an implementation of <a href="../trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::ProcessEdgesWork"><code>crate::scheduler::gc_work::ProcessEdgesWork</code></a>. A plan that implements
<code>PlanTraceObject</code> can use this work packet for tracing objects.</dd><dt><a class="struct" href="struct.PlanScanObjects.html" title="struct mmtk::scheduler::gc_work::PlanScanObjects">Plan<wbr>Scan<wbr>Objects</a></dt><dd>This is an alternative to <code>ScanObjects</code> that calls the <code>post_scan_object</code> of the policy
selected by the plan.  It is applicable to plans that derive <code>PlanTraceObject</code>.</dd><dt><a class="struct" href="struct.Prepare.html" title="struct mmtk::scheduler::gc_work::Prepare">Prepare</a></dt><dd>The global GC Preparation Work
This work packet invokes prepare() for the plan (which will invoke prepare() for each space), and
pushes work packets for preparing mutators and collectors.
We should only have one such work packet per GC, before any actual GC work starts.
We assume this work packet is the only running work packet that accesses plan, and there should
be no other concurrent work packet that accesses plan (read or write). Otherwise, there may
be a race condition.</dd><dt><a class="struct" href="struct.PrepareCollector.html" title="struct mmtk::scheduler::gc_work::PrepareCollector">Prepare<wbr>Collector</a></dt><dd>The collector GC Preparation Work</dd><dt><a class="struct" href="struct.PrepareMutator.html" title="struct mmtk::scheduler::gc_work::PrepareMutator">Prepare<wbr>Mutator</a></dt><dd>The mutator GC Preparation Work</dd><dt><a class="struct" href="struct.ProcessEdgesBase.html" title="struct mmtk::scheduler::gc_work::ProcessEdgesBase">Process<wbr>Edges<wbr>Base</a></dt><dt><a class="struct" href="struct.ProcessEdgesWorkRootsWorkFactory.html" title="struct mmtk::scheduler::gc_work::ProcessEdgesWorkRootsWorkFactory">Process<wbr>Edges<wbr>Work<wbr>Roots<wbr>Work<wbr>Factory</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>An implementation of <code>RootsWorkFactory</code> that creates work packets based on <code>ProcessEdgesWork</code>
for handling roots.  The <code>DPE</code> and the <code>PPE</code> type parameters correspond to the
<code>DefaultProcessEdge</code> and the <code>PinningProcessEdges</code> type members of the <a href="../work/trait.GCWorkContext.html" title="trait mmtk::scheduler::work::GCWorkContext"><code>GCWorkContext</code></a> trait.</dd><dt><a class="struct" href="struct.ProcessEdgesWorkTracer.html" title="struct mmtk::scheduler::gc_work::ProcessEdgesWorkTracer">Process<wbr>Edges<wbr>Work<wbr>Tracer</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>This implements <code>ObjectTracer</code> by forwarding the <code>trace_object</code> calls to the wrapped
<code>ProcessEdgesWork</code> instance.</dd><dt><a class="struct" href="struct.ProcessEdgesWorkTracerContext.html" title="struct mmtk::scheduler::gc_work::ProcessEdgesWorkTracerContext">Process<wbr>Edges<wbr>Work<wbr>Tracer<wbr>Context</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>This type implements <code>ObjectTracerContext</code> by creating a temporary <code>ProcessEdgesWork</code> during
the call to <code>with_tracer</code>, making use of its <code>trace_object</code> method.  It then creates work
packets using the methods of the <code>ProcessEdgesWork</code> and add the work packet into the given
<code>stage</code>.</dd><dt><a class="struct" href="struct.ProcessRootNodes.html" title="struct mmtk::scheduler::gc_work::ProcessRootNodes">Process<wbr>Root<wbr>Nodes</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>This work packet processes pinning roots.</dd><dt><a class="struct" href="struct.Release.html" title="struct mmtk::scheduler::gc_work::Release">Release</a></dt><dd>The global GC release Work
This work packet invokes release() for the plan (which will invoke release() for each space), and
pushes work packets for releasing mutators and collectors.
We should only have one such work packet per GC, after all actual GC work ends.
We assume this work packet is the only running work packet that accesses plan, and there should
be no other concurrent work packet that accesses plan (read or write). Otherwise, there may
be a race condition.</dd><dt><a class="struct" href="struct.ReleaseCollector.html" title="struct mmtk::scheduler::gc_work::ReleaseCollector">Release<wbr>Collector</a></dt><dd>The collector release Work</dd><dt><a class="struct" href="struct.ReleaseMutator.html" title="struct mmtk::scheduler::gc_work::ReleaseMutator">Release<wbr>Mutator</a></dt><dd>The mutator release Work</dd><dt><a class="struct" href="struct.SFTProcessEdges.html" title="struct mmtk::scheduler::gc_work::SFTProcessEdges">SFTProcess<wbr>Edges</a></dt><dd>A general implementation of <a href="../trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::ProcessEdgesWork"><code>ProcessEdgesWork</code></a> using SFT. A plan can always implement their
own <a href="../trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::ProcessEdgesWork"><code>ProcessEdgesWork</code></a> instances. However, most plans can use this work packet for tracing amd
they do not need to provide a plan-specific trace object work packet. If they choose to use this
type, they need to provide a correct implementation for some related methods (such as
<code>Space.set_copy_for_sft_trace()</code>, <code>SFT.sft_trace_object()</code>). Some plans are not using this type,
mostly due to more complex tracing. Either it is impossible to use this type, or there is
performance overheads for using this general trace type. In such cases, they implement their
specific <a href="../trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::ProcessEdgesWork"><code>ProcessEdgesWork</code></a> instances.</dd><dt><a class="struct" href="struct.ScanMutatorRoots.html" title="struct mmtk::scheduler::gc_work::ScanMutatorRoots">Scan<wbr>Mutator<wbr>Roots</a></dt><dt><a class="struct" href="struct.ScanObjects.html" title="struct mmtk::scheduler::gc_work::ScanObjects">Scan<wbr>Objects</a></dt><dd>Scan objects and enqueue the slots of the objects.  For objects that do not support
slot-enqueuing, this work packet also traces their outgoing edges directly.</dd><dt><a class="struct" href="struct.ScanVMSpecificRoots.html" title="struct mmtk::scheduler::gc_work::ScanVMSpecificRoots">ScanVM<wbr>Specific<wbr>Roots</a></dt><dt><a class="struct" href="struct.ScheduleCollection.html" title="struct mmtk::scheduler::gc_work::ScheduleCollection">Schedule<wbr>Collection</a></dt><dt><a class="struct" href="struct.StopMutators.html" title="struct mmtk::scheduler::gc_work::StopMutators">Stop<wbr>Mutators</a></dt><dd>Stop all mutators</dd><dt><a class="struct" href="struct.UnsupportedProcessEdges.html" title="struct mmtk::scheduler::gc_work::UnsupportedProcessEdges">Unsupported<wbr>Process<wbr>Edges</a></dt><dd>A <code>ProcessEdgesWork</code> type that panics when any of its method is used.
This is currently used for plans that do not support transitively pinning.</dd><dt><a class="struct" href="struct.VMForwardWeakRefs.html" title="struct mmtk::scheduler::gc_work::VMForwardWeakRefs">VMForward<wbr>Weak<wbr>Refs</a></dt><dd>Delegate to the VM binding for forwarding weak references.</dd><dt><a class="struct" href="struct.VMPostForwarding.html" title="struct mmtk::scheduler::gc_work::VMPostForwarding">VMPost<wbr>Forwarding</a></dt><dd>This work packet calls <code>Collection::post_forwarding</code>.</dd><dt><a class="struct" href="struct.VMProcessWeakRefs.html" title="struct mmtk::scheduler::gc_work::VMProcessWeakRefs">VMProcess<wbr>Weak<wbr>Refs</a></dt><dd>Delegate to the VM binding for weak reference processing.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.RootsKind.html" title="enum mmtk::scheduler::gc_work::RootsKind">Roots<wbr>Kind</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>For USDT tracepoints for roots.
Keep in sync with <code>tools/tracing/timeline/visualize.py</code>.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::gc_work::ProcessEdgesWork">Process<wbr>Edges<wbr>Work</a></dt><dd>An abstract trait for work packets that process object graph edges.  Its method
<a href="../trait.ProcessEdgesWork.html#tymethod.trace_object" title="method mmtk::scheduler::ProcessEdgesWork::trace_object"><code>ProcessEdgesWork::trace_object</code></a> traces an object and, upon first visit, enqueues it into an
internal queue inside the <code>ProcessEdgesWork</code> instance.  Each implementation of this trait
implement <code>trace_object</code> differently.  During <a href="../../plan/trait.Plan.html#tymethod.schedule_collection" title="method mmtk::plan::Plan::schedule_collection"><code>Plan::schedule_collection</code></a>, plans select
(usually via <code>GCWorkContext</code>) specialized implementations of this trait to be used during each
trace according the nature of each trace, such as whether it is a nursery collection, whether it
is a defrag collection, whether it pins objects, etc.</dd><dt><a class="trait" href="trait.ScanObjectsWork.html" title="trait mmtk::scheduler::gc_work::ScanObjectsWork">Scan<wbr>Objects<wbr>Work</a></dt><dd>Trait for a work packet that scans objects</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.SlotOf.html" title="type mmtk::scheduler::gc_work::SlotOf">SlotOf</a></dt><dd>A short-hand for <code>&lt;E::VM as VMBinding&gt;::VMSlot</code>.</dd></dl></section></div></main></body></html>