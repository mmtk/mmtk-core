<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MMTk Tutorial</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="prefix.html">MMTk Tutorial</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/what_is_mmtk.html"><strong aria-hidden="true">1.1.</strong> What is MMTk?</a></li><li class="chapter-item expanded "><a href="intro/what_will_this_tutorial_cover.html"><strong aria-hidden="true">1.2.</strong> What will this tutorial cover?</a></li><li class="chapter-item expanded "><a href="intro/glossary.html"><strong aria-hidden="true">1.3.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Preliminaries</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="preliminaries/set_up.html"><strong aria-hidden="true">2.1.</strong> Set up MMTk and OpenJDK</a></li><li class="chapter-item expanded "><a href="preliminaries/test.html"><strong aria-hidden="true">2.2.</strong> Test the build</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> MyGC</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="mygc/create.html"><strong aria-hidden="true">3.1.</strong> Create MyGC</a></li><li class="chapter-item expanded "><a href="mygc/ss/prefix.html"><strong aria-hidden="true">3.2.</strong> Building a semispace GC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mygc/ss/alloc.html"><strong aria-hidden="true">3.2.1.</strong> Allocation</a></li><li class="chapter-item expanded "><a href="mygc/ss/collection.html"><strong aria-hidden="true">3.2.2.</strong> Collection</a></li><li class="chapter-item expanded "><a href="mygc/ss/exercise.html"><strong aria-hidden="true">3.2.3.</strong> Exercise</a></li><li class="chapter-item expanded "><a href="mygc/ss/exercise_solution.html"><strong aria-hidden="true">3.2.4.</strong> Exercise solution</a></li></ol></li><li class="chapter-item expanded "><a href="mygc/gencopy.html"><strong aria-hidden="true">3.3.</strong> Building a generational copying GC</a></li></ol></li><li class="chapter-item expanded "><a href="further_reading.html"><strong aria-hidden="true">4.</strong> Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">MMTk Tutorial</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mmtk-tutorial"><a class="header" href="#mmtk-tutorial">MMTk Tutorial</a></h1>
<p>In this tutorial, you will build multiple garbage collectors from 
scratch using MMTk. 
You will start with an incredibly simple 'collector' called NoGC, 
and through a series of additions and refinements end up with a 
generational copying garbage collector. </p>
<p>This tutorial is aimed at GC implementors who would like to implement 
new GC algorithms/plans with MMTk. If you are a language implementor 
interested in <em>porting</em> your runtime to MMTk, you should refer to the 
<a href="https://www.mmtk.io/mmtk-core/portingguide/">porting guide</a> instead.</p>
<p>This tutorial is a work in progress. Some sections may be rough, and others may 
be missing information (especially about import statements). If something is 
missing or inaccurate, refer to the relevant completed garbage collector if
possible. Please also raise an issue, or create a pull request addressing 
the problem. </p>
<h1 id="what-is-mmtk"><a class="header" href="#what-is-mmtk">What <em>is</em> MMTk?</a></h1>
<p>The Memory Management Toolkit (MMTk) is a framework for designing and 
implementing memory managers. It has a runtime-neutral core (mmtk-core) 
written in Rust, and bindings that allow it to work with OpenJDK, V8, 
and JikesRVM, with more bindings currently in development. 
MMTk was originally written in Java as part of the JikesRVM Java runtime.
The current version is similar in its purpose, but was made to be 
very flexible with runtime and able to be ported to many different VMs.</p>
<p>The principal idea of MMTk is that it can be used as a 
toolkit, allowing new GC algorithms to be rapidly developed using 
common components. It also allows different GC algorithms to be 
compared on an apples-to-apples basis, since they share common mechanisms.</p>
<h1 id="what-will-this-tutorial-cover"><a class="header" href="#what-will-this-tutorial-cover">What will this tutorial cover?</a></h1>
<p>This tutorial is intended to get you comfortable constructing new plans in 
MMTk.</p>
<p>You will first be guided through building a semispace collector. After that, 
you will extend this collector to be a generational collector, to further 
familiarise you with different concepts in MMTk. There will also be 
questions and exercises at various points in the tutorial, intended to 
encourage you to think about what the code is doing, increase your general 
understanding of MMTk, and motivate further research.</p>
<p>Where possible, there will be links to finished, functioning code after each 
section so that you can check that your code is correct. Note, however, that 
these will be full collectors. Therefore, there may be some differences between 
these files and your collector due to your position in the tutorial. By the end 
of each major section, your code should be functionally identical to the 
finished code provided.</p>
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p><em>allocator</em>: Code that allocates new objects into memory.</p>
<p><em>collector</em>: Finds and frees memory occupied by 'dead' objects. </p>
<p><em>dead</em>: An object that is not live.</p>
<p><em>GC work (unit), GC packet</em>: A schedulable unit of collection work. </p>
<p><em>GC worker</em>: A worker thread that performs garbage collection operations 
(as required by GC work units).</p>
<p><em>live</em>: An object that is reachable, and thus can still be accessed by other 
objects, is live/alive.</p>
<p><em>mutator</em>: Something that 'mutates', or changes, the objects stored in memory. 
This is the term that is traditionally used in the garbage collection literature 
to describe the running program (because it 'mutates' the object graph).</p>
<p><em>plan</em>: A garbage collection algorithm expressed as a configuration of policies. 
See also <a href="intro/glossary.html#plans-and-policies">Plans and policies</a> below.</p>
<p><em>policy</em>: A specific garbage collection algorithm, such as marksweep, copying, 
immix, etc. Plans are made up of an arrangement of one or more policies. 
See also <a href="intro/glossary.html#plans-and-policies">Plans and policies</a> below.</p>
<p><em>scheduler</em>: Dynamically dispatches units of GC work to workers.</p>
<p><em>zeroing</em>, <em>zero initialization</em>: Initializing and resetting unused memory 
bits to have a value of 0. Required by most memory-safe programming languages.</p>
<p>See also: <a href="intro/../further_reading.html">Further Reading</a></p>
<h2 id="plans-and-policies"><a class="header" href="#plans-and-policies">Plans and Policies</a></h2>
<p>In MMTk, collectors are instantiated as plans, which can be thought of as 
configurations of collector policies. In practice, most production 
collectors and almost all collectors in MMTk are comprised of multiple 
algorithms/policies. For example the gencopy plan describes a configuration 
that combines a copying nursery with a semispace mature space. In MMTk we 
think of these as three spaces, each of which happen to use the copyspace 
policy, and which have a relationship which is defined by the gencopy plan. 
Under the hood, gencopy builds upon a common plan which may also contain other 
policies including a space for code, a read-only space, etc.</p>
<p>Thus, someone wishing to construct a new collector based entirely on existing 
policies may be able to do so in MMTk by simply writing a new plan, which is 
what this tutorial covers.</p>
<p>On the other hand, someone wishing to introduce an entirely new garbage 
collection policy (such as Immix, for example), would need to first create 
a policy which specifies that algorithm, before creating a plan which defines 
how the GC algorithm fits together and utilizes that policy.</p>
<h1 id="set-up-mmtk-and-openjdk"><a class="header" href="#set-up-mmtk-and-openjdk">Set up MMTk and OpenJDK</a></h1>
<p>This tutorial can be completed with any binding. However, for the sake of 
simplicity, only the setup for the OpenJDK binding will be described in detail 
here. If you would like to use another binding, you will need to follow the 
README files in their respective repositories 
(<a href="https://github.com/mmtk/mmtk-jikesrvm">JikesRVM</a>, 
<a href="https://github.com/mmtk/mmtk-v8">V8</a>)
to set them up, and find appropriate benchmarks for testing. 
Also, while it may be useful to fork the relevant repositories to your own 
account, it is not required for this tutorial.</p>
<p>First, set up OpenJDK, MMTk, and the binding:</p>
<ol>
<li>Clone the OpenJDK binding and mmtk-core repository, and install any relevant
dependencies by following the instructions in the
<a href="https://github.com/mmtk/mmtk-openjdk/blob/master/README.md">OpenJDK binding repository</a>.</li>
<li>Ensure you can build OpenJDK according to the instructions in the READMEs of 
<a href="https://github.com/mmtk/mmtk-core/blob/master/README.md">the mmtk-core repository</a> and the 
<a href="https://github.com/mmtk/mmtk-openjdk/blob/master/README.md">OpenJDK binding repository</a>.
<ul>
<li>Use the <code>slowdebug</code> option when building the OpenJDK binding. This is the 
fastest debug variant to build, and allows for easier debugging and better 
testing. The rest of the tutorial will assume you are using <code>slowdebug</code>.</li>
<li>You can use the env var <code>MMTK_PLAN=[PlanName]</code> to choose a plan to use at run-time.
The plans that are relevant to this tutorial are <code>NoGC</code> and <code>SemiSpace</code>.</li>
</ul>
</li>
</ol>
<h1 id="test-the-build"><a class="header" href="#test-the-build">Test the build</a></h1>
<p>A few benchmarks of varying size will be used throughout the tutorial. If you 
haven't already, set them up now. All of the following commands should be 
entered in <code>repos/openjdk</code>.</p>
<ol>
<li>
<p><strong>HelloWorld</strong> (simplest, will never trigger GC): </p>
<ol>
<li>Copy the following code into a new Java file titled &quot;HelloWorld.java&quot; 
in <code>mmtk-openjdk/repos/openjdk</code>:
<pre><code class="language-java">class HelloWorld {
   public static void main(String[] args) {
      System.out.println(&quot;Hello World!&quot;);
   }
}
</code></pre>
</li>
<li>Use the command 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/javac HelloWorld.java</code>.</li>
<li>Then, run 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java HelloWorld -XX:+UseThirdPartyHeap</code> 
to run HelloWorld.</li>
<li>If your program printed out <code>Hello World!</code> as expected, then congratulations, you have MMTk working with OpenJDK!</li>
</ol>
</li>
<li>
<p>The Computer Language Benchmarks Game <strong>fannkuchredux</strong> (micro benchmark, 
allocates a small amount of memory but - depending on heap size and the GC 
plan - may not trigger a collection): </p>
<ol>
<li><a href="https://salsa.debian.org/benchmarksgame-team/benchmarksgame/-/blob/master/bencher/programs/fannkuchredux/fannkuchredux.java">Copy this code</a> 
into a new file named &quot;fannkuchredux.java&quot; 
in <code>mmtk-openjdk/repos/openjdk</code>.</li>
<li>Use the command 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/javac fannkuchredux.java</code>.</li>
<li>Then, run 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java fannkuchredux -XX:+UseThirdPartyHeap</code> 
to run fannkuchredux.</li>
</ol>
</li>
<li>
<p><strong>DaCapo</strong> benchmark suite (most complex, will likely trigger multiple 
collections): </p>
<ol>
<li>Fetch using 
<code>wget https://sourceforge.net/projects/dacapobench/files/9.12-bach-MR1/dacapo-9.12-MR1-bach.jar/download -O ./dacapo-9.12-MR1-bach.jar</code>.</li>
<li>DaCapo contains a variety of benchmarks, but this tutorial will only be 
using lusearch. Run the lusearch benchmark using the command 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java -XX:+UseThirdPartyHeap -Xms512M -Xmx512M -jar ./dacapo-9.12-MR1-bach.jar lusearch</code> in <code>repos/openjdk</code>. </li>
</ol>
</li>
</ol>
<h2 id="rust-logs"><a class="header" href="#rust-logs">Rust Logs</a></h2>
<p>By using one of the debug builds, you gain access to the Rust logs - a useful 
tool when testing a plan and observing the general behaviour of MMTk. 
There are two levels of trace that are useful when using MMTk - <code>trace</code> 
and <code>debug</code>. Generally, <code>debug</code> logs information about the slow paths 
(allocation through MMTk, rather than fast path allocation through the binding). 
<code>trace</code> includes all the information from <code>debug</code>, plus more information about 
both slow and fast paths and garbage collection activities. You can set which 
level to view the logs at by setting the environment variable <code>RUST_LOG</code>. For 
more information, see the 
<a href="https://crates.io/crates/env_logger">env_logger crate documentation</a>.</p>
<h2 id="working-with-different-gc-plans"><a class="header" href="#working-with-different-gc-plans">Working with different GC plans</a></h2>
<p>You will be using multiple GC plans in this tutorial. You should
familiarise yourself with how to do this now.</p>
<ol>
<li>The OpenJDK build will always generate in <code>mmtk-openjdk/repos/openjdk/build</code>. From the same
build, you can run different GC plans by using the environment variable <code>MMTK_PLAN=[PlanName]</code>.
Generally you won't need multiple VM builds. However, if you
do need to keep a build (for instance, to make quick performance
comparisons), you can do the following: rename either the <code>build</code> folder or the folder generated
within it (eg <code>linux-x86_64-normal-server-$DEBUG_LEVEL</code>). 
<ol>
<li>Renaming the <code>build</code> folder is the safest method for this.</li>
<li>If you rename the internal folder, there is a possibility that the new 
build will generate incorrectly. If a build appears to generate strangely 
quickly, it probably generated badly.</li>
<li>A renamed build folder can be tested by changing the file path in 
commands as appropriate.</li>
<li>If you plan to completely overwrite a build, deleting the folder you are 
writing over will help prevent errors.</li>
</ol>
</li>
<li>Try running your build with <code>NoGC</code>. Both HelloWorld and the fannkuchredux benchmark
should run without issue. If you then run lusearch, it should fail when a 
collection is triggered. It is possible to increase the heap size enough that 
no collections will be triggered, but it is okay to let it fail for now. When 
we build using a proper GC, it will be able to pass. The messages and errors 
produced should look identical or nearly identical to the log below.
<pre><code>$ MMTK_PLAN=NoGC ./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java -XX:+UseThirdPartyHeap -Xms512M -Xmx512M -jar ./dacapo-9.12-MR1-bach.jar lusearch
Using scaled threading model. 24 processors detected, 24 threads used to drive the workload, in a possible range of [1,64]
Warning: User attempted a collection request, but it is not supported in NoGC. The request is ignored.
===== DaCapo 9.12-MR1 lusearch starting =====
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
thread '&lt;unnamed&gt;' panicked at 'internal error: entered unreachable code: GC triggered in nogc', /opt/rust/toolchains/nightly-2020-07-08-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/macros.rs:16:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
fatal runtime error: failed to initiate panic, error 5
Aborted (core dumped)
</code></pre>
</li>
<li>Try running your build with <code>SemiSpace</code>. lusearch should now
pass, as garbage will be collected, and the smaller benchmarks should run the 
same as they did while using NoGC.
<pre><code>MMTK_PLAN=SemiSpace ./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java -XX:+UseThirdPartyHeap -Xms512M -Xmx512M -jar ./dacapo-9.12-MR1-bach.jar lusearch
</code></pre>
</li>
</ol>
<h1 id="create-mygc"><a class="header" href="#create-mygc">Create MyGC</a></h1>
<p>NoGC is a GC plan that only allocates memory, and does not have a collector. 
We're going to use it as a base for building a new garbage collector.</p>
<p>Recall that this tutorial will take you through the steps of building a 
collector from basic principles. To do that, you'll create your own plan 
called <code>MyGC</code> which you'll gradually refine and improve upon through the 
course of this tutorial. At the beginning MyGC will resemble the very 
simple NoGC plan.</p>
<ol>
<li>Each plan is stored in <code>mmtk-openjdk/repos/mmtk-core/src/plan</code>. Navigate 
there and create a copy of the folder <code>nogc</code>. Rename it to <code>mygc</code>.</li>
<li>In <em>each file</em> within <code>mygc</code>, rename any reference to <code>nogc</code> to <code>mygc</code>. 
You will also have to separately rename any reference to <code>NoGC</code> to <code>MyGC</code>.
<ul>
<li>For example, in Visual Studio Code, you can (making sure case sensitivity 
is selected in the search function) select one instance of <code>nogc</code> and either 
right click and select &quot;Change all instances&quot; or use the CTRL-F2 shortcut, 
and then type <code>mygc</code>, and repeat for <code>NoGC</code>.</li>
</ul>
</li>
<li>In order to use MyGC, you will need to make some changes to the following 
files. 
<ol>
<li><code>mmtk-core/src/plan/mod.rs</code>, add:
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod mygc;
<span class="boring">}
</span></code></pre></pre>
This adds <code>mygc</code> as a module.</li>
<li><code>mmtk-core/src/util/options.rs</code>, add <code>MyGC</code> to <code>PlanSelector</code>. This allows MMTk to accept <code>MyGC</code>
as a command line option for <code>plan</code>, or an environment variable for <code>MMTK_PLAN</code>:
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, EnumFromStr, Debug)]
pub enum PlanSelector {
    NoGC,
    SemiSpace,
    GenCopy,
    MyGC
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li><code>mmtk-core/src/plan/global.rs</code>, change <code>create_mutator()</code> and <code>create_plan()</code> to create the <code>MyGC</code> mutator and the <code>MyGC</code> plan
based on <code>PlanSelector</code>:
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_mutator&lt;VM: VMBinding&gt;(
    tls: OpaquePointer,
    mmtk: &amp;'static MMTK&lt;VM&gt;,
) -&gt; Box&lt;Mutator&lt;VM&gt;&gt; {
    Box::new(match mmtk.options.plan {
        PlanSelector::NoGC =&gt; crate::plan::nogc::mutator::create_nogc_mutator(tls, &amp;*mmtk.plan),
        PlanSelector::SemiSpace =&gt; {
            crate::plan::semispace::mutator::create_ss_mutator(tls, &amp;*mmtk.plan)
        }
        PlanSelector::GenCopy =&gt; crate::plan::gencopy::mutator::create_gencopy_mutator(tls, mmtk),
        // Create MyGC mutator based on selector
        PlanSelector::MyGC =&gt; crate::plan::mygc::mutator::create_mygc_mutator(tls, &amp;*mmtk.plan),
    })
}

pub fn create_plan&lt;VM: VMBinding&gt;(
    plan: PlanSelector,
    vm_map: &amp;'static VMMap,
    mmapper: &amp;'static Mmapper,
    options: Arc&lt;UnsafeOptionsWrapper&gt;,
    scheduler: &amp;'static MMTkScheduler&lt;VM&gt;,
) -&gt; Box&lt;dyn Plan&lt;VM = VM&gt;&gt; {
    match plan {
        PlanSelector::NoGC =&gt; Box::new(crate::plan::nogc::NoGC::new(
            vm_map, mmapper, options, scheduler,
        )),
        PlanSelector::SemiSpace =&gt; Box::new(crate::plan::semispace::SemiSpace::new(
            vm_map, mmapper, options, scheduler,
        )),
        PlanSelector::GenCopy =&gt; Box::new(crate::plan::gencopy::GenCopy::new(
            vm_map, mmapper, options, scheduler,
        )),
        // Create MyGC plan based on selector
        PlanSelector::MyGC =&gt; Box::new(crate::plan::mygc::MyGC::new(
            vm_map, mmapper, options, scheduler,
        ))
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
</li>
</ol>
<p>Note that all of the above changes almost exactly copy the NoGC entries in 
each of these files. However, NoGC has some variants, such as a lock-free 
variant. For simplicity, those are not needed for this tutorial. Remove references to them in
the MyGC plan now. </p>
<ol>
<li>Within <code>mygc/global.rs</code>, find any use of <code>#[cfg(feature = &quot;mygc_lock_free&quot;)]</code> 
and delete both it <em>and the line below it</em>.</li>
<li>Then, delete any use of the above line's negation, 
<code>#[cfg(not(feature = &quot;mygc_lock_free&quot;))]</code>, this time without changing the 
line below it.</li>
</ol>
<p>After you rebuild OpenJDK (and <code>mmtk-core</code>), you can run MyGC with your new build (<code>MMTK_PLAN=MyGC</code>). Try testing it
with the each of the three benchmarks. It should work identically to NoGC.</p>
<p>If you've got to this point, then congratulations! You have created your first working MMTk collector!</p>
<p>At this point, you should familiarise yourself with the MyGC plan if you 
haven't already. Try answering the following questions by looking at the code 
and <a href="mygc/../further_reading.html">Further Reading</a>: </p>
<ul>
<li>Where is the allocator defined?</li>
<li>How many memory spaces are there?</li>
<li>What kind of memory space policy is used?</li>
<li>What happens if garbage has to be collected?</li>
</ul>
<h1 id="building-a-semispace-collector"><a class="header" href="#building-a-semispace-collector">Building a semispace collector</a></h1>
<p>In a semispace collector, the heap is divided into two equally-sized spaces, 
called 'semispaces'. One of these is defined as a 'fromspace', and the other 
a 'tospace'. The allocator allocates to the tospace until it is full. </p>
<p>When the tospace is full, a stop-the-world GC is triggered. The mutator is 
paused, and the definitions of the spaces are flipped (the 'tospace' becomes 
a 'fromspace', and vice versa). Then, the collector scans each object in what 
is now the fromspace. If a live object is found, a copy of it is made in the 
tospace. That is to say, live objects are copied <em>from</em> the fromspace <em>to</em> 
the tospace. After every object is scanned, the fromspace is cleared. The GC 
finishes, and the mutator is resumed.</p>
<h1 id="allocation-add-copyspaces"><a class="header" href="#allocation-add-copyspaces">Allocation: Add copyspaces</a></h1>
<p>We will now change your MyGC plan from one that cannot collect garbage
into one that implements the semispace algorithm. The first step of this
is to add the two copyspaces, and allow collectors to allocate memory 
into them. This involves adding two copyspaces, the code to properly initialise 
and prepare the new spaces, and a copy context.</p>
<h2 id="change-the-plan-constraints"><a class="header" href="#change-the-plan-constraints">Change the plan constraints</a></h2>
<p>Firstly, change the plan constraints. Some of these constraints are not used 
at the moment, but it's good to set them properly regardless.</p>
<ol>
<li>
<p>Look in <code>plan/plan_constraints.rs</code>. <code>PlanConstraints</code> lists all the possible
options for plan-specific constraints. At the moment, <code>MYGC_CONSTRAINTS</code> in <code>mygc/global.rs</code> should be using
the default value for <code>PlanConstraints</code>. We will make the following changes.</p>
</li>
<li>
<p>Initialize <code>gc_header_bits</code> to 2. We reserve 2 bits in the header for GC use.</p>
</li>
<li>
<p>Initialize <code>moves_objects</code> to <code>true</code>.</p>
</li>
<li>
<p>Initialize <code>num_specialized_scans</code> to 1.</p>
</li>
</ol>
<p>Finished Code (Step 1-4):</p>
<pre><code>pub const MYGC_CONSTRAINTS: PlanConstraints = PlanConstraints {
    moves_objects: true,
    gc_header_bits: 2,
    gc_header_words: 0,
    num_specialized_scans: 1,
    ..PlanConstraints::default()
};
</code></pre>
<h2 id="change-the-plan-implementation"><a class="header" href="#change-the-plan-implementation">Change the plan implementation</a></h2>
<p>Next, in <code>global.rs</code>, replace the old immortal (nogc) space with two copyspaces.</p>
<h3 id="imports"><a class="header" href="#imports">Imports</a></h3>
<p>To the import statement block:</p>
<ol>
<li>Replace <code>crate::plan::global::{BasePlan, NoCopy};</code> with 
<code>use crate::plan::global::BasePlan;</code>. This collector is going to use 
copying, so there's no point to importing NoCopy any more.</li>
<li>Add <code>use crate::plan::global::CommonPlan;</code>. Semispace uses the common
plan, which includes an immortal space and a large object space, rather 
than the base plan. Any garbage collected plan should use <code>CommonPlan</code>.</li>
<li>Add <code>use std::sync::atomic::{AtomicBool, Ordering};</code>. These are going 
to be used to store an indicator of which copyspace is the tospace.</li>
<li>Delete <code>#[allow(unused_imports)]</code>.</li>
</ol>
<p>Finished Code(Step 1):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::gc_work::{MyGCCopyContext, MyGCProcessEdges}; // Add
use crate::mmtk::MMTK;
use crate::plan::global::BasePlan; //Modify
use crate::plan::global::CommonPlan; // Add
use crate::plan::global::GcStatus; // Add
use crate::plan::mutator_context::Mutator;
use crate::plan::mygc::mutator::create_mygc_mutator;
use crate::plan::mygc::mutator::ALLOCATOR_MAPPING;
use crate::plan::AllocationSemantics;
use crate::plan::Plan;
use crate::plan::PlanConstraints;
use crate::policy::copyspace::CopySpace; // Add
use crate::policy::space::Space;
use crate::scheduler::gc_work::*; // Add
use crate::scheduler::*; // Modify
use crate::util::alloc::allocators::AllocatorSelector;
use crate::util::heap::layout::heap_layout::Mmapper;
use crate::util::heap::layout::heap_layout::VMMap;
use crate::util::heap::layout::vm_layout_constants::{HEAP_END, HEAP_START};
use crate::util::heap::HeapMeta;
use crate::util::heap::VMRequest;
use crate::util::options::UnsafeOptionsWrapper;
use crate::util::OpaquePointer;
use crate::vm::VMBinding;
use enum_map::EnumMap;
use std::sync::atomic::{AtomicBool, Ordering}; // Add
use std::sync::Arc;
// Remove #[allow(unused_imports)].
// Remove handle_user_collection_request.
<span class="boring">}
</span></code></pre></pre>
<h3 id="struct-mygc"><a class="header" href="#struct-mygc">Struct MyGC</a></h3>
<p>Change <code>pub struct MyGC&lt;VM: VMBinding&gt;</code> to add new instance variables.</p>
<ol>
<li>Delete the existing fields in the constructor.</li>
<li>Add <code>pub hi: AtomicBool,</code>. This is a thread-safe bool, indicating which 
copyspace is the tospace.</li>
<li>Add <code>pub copyspace0: CopySpace&lt;VM&gt;,</code> 
and <code>pub copyspace1: CopySpace&lt;VM&gt;,</code>. These are the two copyspaces.</li>
<li>Add <code>pub common: CommonPlan&lt;VM&gt;,</code>.
This holds an instance of the common plan.</li>
</ol>
<p>Finished code (step 2):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGC&lt;VM: VMBinding&gt; {
    pub hi: AtomicBool,
    pub copyspace0: CopySpace&lt;VM&gt;,
    pub copyspace1: CopySpace&lt;VM&gt;,
    pub common: CommonPlan&lt;VM&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implement-the-plan-trait-for-mygc"><a class="header" href="#implement-the-plan-trait-for-mygc">Implement the Plan trait for MyGC</a></h3>
<h4 id="constructor"><a class="header" href="#constructor">Constructor</a></h4>
<p>Change <code>fn new()</code>. This section initialises and prepares the objects in MyGC that you just defined.</p>
<ol>
<li>Delete the definition of <code>mygc_space</code>. 
Instead, we will define the two copyspaces here.</li>
<li>Define one of the copyspaces by adding the following code: </li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            copyspace0: CopySpace::new(
                &quot;copyspace0&quot;,
                false,
                true,
                VMRequest::discontiguous(),
                vm_map,
                mmapper,
                &amp;mut heap,
            ),
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>Create another copyspace, called <code>copyspace1</code>, defining it as a fromspace 
instead of a tospace. (Hint: the definitions for 
copyspaces are in <code>src/policy/copyspace.rs</code>.) </li>
<li>Finally, replace the old MyGC initializer.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new(
        vm_map: &amp;'static VMMap,
        mmapper: &amp;'static Mmapper,
        options: Arc&lt;UnsafeOptionsWrapper&gt;,
        _scheduler: &amp;'static MMTkScheduler&lt;VM&gt;,
    ) -&gt; Self {
        // Modify
        let mut heap = HeapMeta::new(HEAP_START, HEAP_END);

        MyGC {
            hi: AtomicBool::new(false),
            copyspace0: CopySpace::new(
                &quot;copyspace0&quot;,
                false,
                true,
                VMRequest::discontiguous(),
                vm_map,
                mmapper,
                &amp;mut heap,
            ),
            copyspace1: CopySpace::new(
                &quot;copyspace1&quot;,
                true,
                true,
                VMRequest::discontiguous(),
                vm_map,
                mmapper,
                &amp;mut heap,
            ),
            common: CommonPlan::new(vm_map, mmapper, options, heap, &amp;MYGC_CONSTRAINTS, &amp;[]),
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h4 id="initializer"><a class="header" href="#initializer">Initializer</a></h4>
<p>Find <code>gc_init()</code>. Change it to initialise the common plan and the two 
copyspaces, rather than the base plan and mygc_space. The contents of the 
initializer calls are identical.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn gc_init(
        &amp;mut self,
        heap_size: usize,
        vm_map: &amp;'static VMMap,
        scheduler: &amp;Arc&lt;MMTkScheduler&lt;VM&gt;&gt;,
    ) {
        self.common.gc_init(heap_size, vm_map, scheduler);
        self.copyspace0.init(&amp;vm_map);
        self.copyspace1.init(&amp;vm_map);
    }
<span class="boring">}
</span></code></pre></pre>
<h4 id="other-methods-in-the-plan-trait"><a class="header" href="#other-methods-in-the-plan-trait">Other methods in the Plan trait</a></h4>
<p>The trait <code>Plan</code> requires a <code>common()</code> method that should return a 
reference to the common plan. Implement this method now.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn common(&amp;self) -&gt; &amp;CommonPlan&lt;VM&gt; {
        &amp;self.common
    }
<span class="boring">}
</span></code></pre></pre>
<p>Find the helper method <code>base</code> and change it so that it calls the 
base plan <em>through</em> the common plan.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn base(&amp;self) -&gt; &amp;BasePlan&lt;VM&gt; {
        &amp;self.common.base
    }
<span class="boring">}
</span></code></pre></pre>
<p>Find the method <code>get_pages_used</code>. Replace the current body with 
<code>self.tospace().reserved_pages() + self.common.get_pages_used()</code>, to 
correctly count the pages contained in the tospace and the common plan 
spaces (which will be explained later).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn get_pages_used(&amp;self) -&gt; usize {
        self.tospace().reserved_pages() + self.common.get_pages_used()
    }
<span class="boring">}
</span></code></pre></pre>
<p>Add and override the following helper function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn get_collection_reserve(&amp;self) -&gt; usize {
        self.tospace().reserved_pages()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="access-mygc-spaces"><a class="header" href="#access-mygc-spaces">Access MyGC spaces</a></h3>
<p>Add a new section of methods for MyGC:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM: VMBinding&gt; MyGC&lt;VM&gt; {
}
<span class="boring">}
</span></code></pre></pre>
<p>To this, add two helper methods, <code>tospace(&amp;self)</code> 
and <code>fromspace(&amp;self)</code>. They both have return type <code>&amp;CopySpace&lt;VM&gt;</code>, 
and return a reference to the tospace and fromspace respectively. 
<code>tospace()</code> (see below) returns a reference to the tospace, 
and <code>fromspace()</code> returns a reference to the fromspace.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn tospace(&amp;self) -&gt; &amp;CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;self.copyspace1
        } else {
            &amp;self.copyspace0
        }
    }

    pub fn fromspace(&amp;self) -&gt; &amp;CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;self.copyspace0
        } else {
            &amp;self.copyspace1
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="change-the-mutator-definition"><a class="header" href="#change-the-mutator-definition">Change the mutator definition</a></h2>
<p>Next, we need to change the mutator, in <code>mutator.rs</code>, to allocate to the 
tospace, and to the two spaces controlled by the common plan. </p>
<h3 id="imports-1"><a class="header" href="#imports-1">Imports</a></h3>
<p>Change the following import statements:</p>
<ol>
<li>Add <code>use super::MyGC;</code>.</li>
<li>Add <code>use crate::util::alloc::BumpAllocator;</code>.</li>
<li>Delete <code>use crate::plan::mygc::MyGC;</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::MyGC; // Add
use crate::plan::barriers::NoBarrier;
use crate::plan::mutator_context::Mutator;
use crate::plan::mutator_context::MutatorConfig;
use crate::plan::AllocationSemantics as AllocationType;
use crate::util::alloc::allocators::{AllocatorSelector, Allocators};
use crate::util::alloc::BumpAllocator;
use crate::util::OpaquePointer;
use crate::vm::VMBinding;
use enum_map::enum_map;
use enum_map::EnumMap;
// Remove crate::plan::mygc::MyGC
// Remove mygc_mutator_noop
<span class="boring">}
</span></code></pre></pre>
<h3 id="allocator-mapping"><a class="header" href="#allocator-mapping">Allocator mapping</a></h3>
<p>In <code>lazy_static!</code>, make the following changes to <code>ALLOCATOR_MAPPING</code>, 
which maps the required allocation semantics to the corresponding allocators. 
For example, for <code>Default</code>, we allocate using the first bump pointer allocator 
(<code>BumpPointer(0)</code>):</p>
<ol>
<li>Map <code>Default</code> to <code>BumpPointer(0)</code>.</li>
<li>Map <code>ReadOnly</code> to <code>BumpPointer(1)</code>.</li>
<li>Map <code>Los</code> to <code>LargeObject(0)</code>. </li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    pub static ref ALLOCATOR_MAPPING: EnumMap&lt;AllocationType, AllocatorSelector&gt; = enum_map! {
        AllocationType::Default =&gt; AllocatorSelector::BumpPointer(0),
        AllocationType::Immortal | AllocationType::Code | AllocationType::ReadOnly =&gt; AllocatorSelector::BumpPointer(1),
        AllocationType::Los =&gt; AllocatorSelector::LargeObject(0),
    };
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="space-mapping"><a class="header" href="#space-mapping">Space mapping</a></h3>
<p>Next, in <code>create_mygc_mutator</code>, change which allocator is allocated to what 
space in <code>space_mapping</code>. Note that the space allocation is formatted as a list 
of tuples. For example, the first bump pointer allocator (<code>BumpPointer(0)</code>) is 
bound with <code>tospace</code>.</p>
<ol>
<li><code>BumpPointer(0)</code> should map to the tospace.</li>
<li><code>BumpPointer(1)</code> should map to <code>plan.common.get_immortal()</code>.</li>
<li><code>LargeObject(0)</code> should map to <code>plan.common.get_los()</code>.</li>
<li>None of the above should be dereferenced (ie, they should not have 
the <code>&amp;</code> prefix).</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        space_mapping: box vec![
            (AllocatorSelector::BumpPointer(0), plan.tospace()),
            (
                AllocatorSelector::BumpPointer(1),
                plan.common.get_immortal(),
            ),
            (AllocatorSelector::LargeObject(0), plan.common.get_los()),
        ],
<span class="boring">}
</span></code></pre></pre>
<p>There may seem to be 2 extraneous spaces and allocators that have appeared all 
of a sudden in these past 2 steps. These are parts of the MMTk common plan 
itself.</p>
<ol>
<li>The immortal space is used for objects that the virtual machine or a 
library never expects to die.</li>
<li>The large object space is needed because MMTk handles particularly large 
objects differently to normal objects, as the space overhead of copying 
large objects is very high. Instead, this space is used by a free list 
allocator in the common plan to avoid having to copy them. </li>
</ol>
<p>With this, you should have the allocation working, but not garbage collection. 
Try building again. If you run HelloWorld or Fannkunchredux, they should
work. DaCapo's lusearch should fail, as it requires garbage to be collected. </p>
<h1 id="collection-implement-garbage-collection"><a class="header" href="#collection-implement-garbage-collection">Collection: Implement garbage collection</a></h1>
<p>We need to add a few more things to get garbage collection working. 
Specifically, we need to add a <code>CopyContext</code>, which a GC worker uses for 
copying objects, and GC work packets that will be scheduled for a collection.</p>
<h2 id="copycontext"><a class="header" href="#copycontext">CopyContext</a></h2>
<p>At the moment, none of the files in the plan are suited for garbage collection 
operations. So, we need to add a new file to hold the <code>CopyContext</code> and other 
structures and functions that will give the collector proper functionality.</p>
<p>Make a new file under <code>mygc</code>, called <code>gc_work.rs</code>. 
In <code>mod.rs</code>, import <code>gc_work</code> as a module by adding the line <code>mod gc_work</code>.
In <code>gc_work.rs</code>, add the following import statements:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::global::MyGC;
use crate::plan::CopyContext;
use crate::policy::space::Space;
use crate::scheduler::gc_work::*;
use crate::util::alloc::{Allocator, BumpAllocator};
use crate::util::forwarding_word;
use crate::util::{Address, ObjectReference, OpaquePointer};
use crate::vm::VMBinding;
use crate::MMTK;
use crate::plan::PlanConstraints;
use crate::scheduler::WorkerLocal;
use std::marker::PhantomData;
use std::ops::{Deref, DerefMut};
<span class="boring">}
</span></code></pre></pre>
<p>Add a new structure, <code>MyGCCopyContext</code>, with the type parameter 
<code>VM: VMBinding</code>. It should have the fields <code>plan: &amp;'static MyGC&lt;VM&gt;</code>
and <code>mygc: BumpAllocator</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCCopyContext&lt;VM: VMBinding&gt; {
    plan:&amp;'static MyGC&lt;VM&gt;,
    mygc: BumpAllocator&lt;VM&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Create an implementation block - 
<code>impl&lt;VM: VMBinding&gt; CopyContext for MyGCCopyContext&lt;VM&gt;</code>.
Define the associate type <code>VM</code> for <code>CopyContext</code> as the VMBinding type 
given to the class as <code>VM</code>: <code>type VM: VM</code>. </p>
<p>Add the following skeleton functions (taken from <code>plan/global.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn constraints(&amp;self) -&gt; &amp;'static PlanConstraints {
    unimplemented!()
}
fn init(&amp;mut self, tls: OpaquePointer) {
    unimplemented!()
}
fn prepare(&amp;mut self) {
    unimplemented!()
}
fn release(&amp;mut self) {
    unimplemented!()
}
fn alloc_copy(`init
    &amp;mut self,
    original: ObjectReference,
    bytes: usize,
    align: usize,
    offset: isize,
    semantics: AllocationSemantics,
) -&gt; Address {
    unimplemented!()
}
fn post_copy(
    &amp;mut self,
    _obj: ObjectReference,
    _tib: Address,
    _bytes: usize,
    _semantics: AllocationSemantics,
) {
    unimplemented!()
}
<span class="boring">}
</span></code></pre></pre>
<p>In <code>init()</code>, set the <code>tls</code> variable in the held instance of <code>mygc</code> to
the one passed to the function. In <code>constraints()</code>, return a reference of <code>MYGC_CONSTRAINTS</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn constraints(&amp;self) -&gt; &amp;'static PlanConstraints {
        &amp;super::global::MYGC_CONSTRAINTS
    }
    fn init(&amp;mut self, tls:OpaquePointer) {
        self.mygc.tls = tls;
    }
<span class="boring">}
</span></code></pre></pre>
<p>We just leave the rest of the functions empty for now and will implement them later.</p>
<p>Add a constructor to <code>MyGCCopyContext</code> and implement the <code>WorkerLocal</code> trait for <code>MyGCCopyContext</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM: VMBinding&gt; MyGCCopyContext&lt;VM&gt; {
    pub fn new(mmtk: &amp;'static MMTK&lt;VM&gt;) -&gt; Self {
        let plan = &amp;mmtk.plan.downcast_ref::&lt;MyGC&lt;VM&gt;&gt;().unwrap();
        Self {
            plan,
            mygc: BumpAllocator::new(OpaquePointer::UNINITIALIZED, plan.tospace(), &amp;*mmtk.plan),
        }
    }
}

impl&lt;VM: VMBinding&gt; WorkerLocal for MyGCCopyContext&lt;VM&gt; {
    fn init(&amp;mut self, tls: OpaquePointer) {
        CopyContext::init(self, tls);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="mygcprocessedges"><a class="header" href="#mygcprocessedges">MyGCProcessEdges</a></h2>
<p>Add a new public structure, <code>MyGCProcessEdges</code>, with the type parameter 
<code>&lt;VM:VMBinding&gt;</code>. It will hold an instance of <code>ProcessEdgesBase</code> and 
<code>MyGC</code>. This is the core part for tracing objects in the <code>MyGC</code> plan.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCProcessEdges&lt;VM: VMBinding&gt; {
    plan: &amp;'static MyGC&lt;VM&gt;,
    base: ProcessEdgesBase&lt;MyGCProcessEdges&lt;VM&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Add a new implementations block 
<code>impl&lt;VM:VMBinding&gt; ProcessEdgesWork for MyGCProcessEdges&lt;VM&gt;</code>.
Similarly to before, set <code>ProcessEdgesWork</code>'s associate type <code>VM</code> to 
the type parameter of <code>MyGCProcessEdges</code>, <code>VM</code>: <code>type VM:VM</code>.
Add a new constructor, <code>new()</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new(edges: Vec&lt;Address&gt;, _roots: bool, mmtk: &amp;'static MMTK&lt;VM&gt;) -&gt; Self {
        let base = ProcessEdgesBase::new(edges, mmtk);
        let plan = base.plan().downcast_ref::&lt;MyGC&lt;VM&gt;&gt;().unwrap();
        Self { base, plan }
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="introduce-collection-to-mygc-plan"><a class="header" href="#introduce-collection-to-mygc-plan">Introduce collection to MyGC plan</a></h2>
<p>Now that they've been added, you should import <code>MyGCCopyContext</code> and
<code>MyGCProcessEdges</code> into <code>global.rs</code>, which we will be working in for the
next few steps. </p>
<p>In <code>create_worker_local()</code> in <code>impl Plan for MyGC</code>, create an instance of <code>MyGCCopyContext</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn create_worker_local(
        &amp;self,
        tls: OpaquePointer,
        mmtk: &amp;'static MMTK&lt;Self::VM&gt;,
    ) -&gt; GCWorkerLocalPtr {
        let mut c = MyGCCopyContext::new(mmtk);
        c.init(tls);
        GCWorkerLocalPtr::new(c)
    }
<span class="boring">}
</span></code></pre></pre>
<p><code>NoCopy</code> is now no longer needed. Remove it from the import statement block. 
For the next step, import <code>crate::scheduler::gc_work::*;</code>, and modify the
line importing <code>MMTK</code> scheduler to read <code>use crate::scheduler::*;</code>.</p>
<p>Add a new method to <code>Plan for MyGC</code>, <code>schedule_collection()</code>. This function 
runs when a collection is triggered. It schedules GC work for the plan, i.e.,
it stops all mutators, runs the
scheduler's prepare stage and resumes the mutators. The <code>StopMutators</code> work
will invoke code from the bindings to scan threads and other roots, and those scanning work
will further push work for a transitive closure.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn schedule_collection(&amp;'static self, scheduler: &amp;MMTkScheduler&lt;VM&gt;) {
        self.base().set_collection_kind();
        self.base().set_gc_status(GcStatus::GcPrepare);
        scheduler.work_buckets[WorkBucketStage::Unconstrained]
            .add(StopMutators::&lt;MyGCProcessEdges&lt;VM&gt;&gt;::new());
        scheduler.work_buckets[WorkBucketStage::Prepare]
            .add(Prepare::&lt;Self, MyGCCopyContext&lt;VM&gt;&gt;::new(self));
        scheduler.work_buckets[WorkBucketStage::Release]
            .add(Release::&lt;Self, MyGCCopyContext&lt;VM&gt;&gt;::new(self));
        scheduler.set_finalizer(Some(EndOfGC));
    }
<span class="boring">}
</span></code></pre></pre>
<p>Delete <code>handle_user_collection_request()</code>. This function was an override of 
a Common plan function to ignore user requested collection for NoGC. Now we 
remove it and allow user requested collection.</p>
<h2 id="prepare-for-collection"><a class="header" href="#prepare-for-collection">Prepare for collection</a></h2>
<p>The collector has a number of steps it needs to perform before each collection.
We'll add these now.</p>
<h3 id="prepare-plan"><a class="header" href="#prepare-plan">Prepare plan</a></h3>
<p>In <code>global.rs</code>, find the method <code>prepare</code>. Delete the <code>unreachable!()</code> 
call, and add the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn prepare(&amp;self, tls: OpaquePointer) {
        self.common.prepare(tls, true);

        self.hi
            .store(!self.hi.load(Ordering::SeqCst), Ordering::SeqCst);
        // Flips 'hi' to flip space definitions
        let hi = self.hi.load(Ordering::SeqCst);
        self.copyspace0.prepare(hi);
        self.copyspace1.prepare(!hi);
    }
<span class="boring">}
</span></code></pre></pre>
<p>This function is called at the start of a collection. It prepares the two 
spaces in the common plan, flips the definitions for which space is 'to' 
and which is 'from', then prepares the copyspaces with the new definition.</p>
<h3 id="prepare-copycontext"><a class="header" href="#prepare-copycontext">Prepare CopyContext</a></h3>
<p>First, fill in some more of the skeleton functions we added to the 
<code>CopyContext</code> (in <code>gc_work.rs</code>) earlier.
In <code>prepare()</code>, rebind the allocator to the tospace using the function
<code>self.mygc.rebind(Some(self.plan.tospace()))</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn prepare(&amp;mut self) {
        self.mygc.rebind(self.plan.tospace());
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="prepare-mutator"><a class="header" href="#prepare-mutator">Prepare mutator</a></h3>
<p>Going back to <code>mutator.rs</code>, create a new function called 
<code>mygc_mutator_prepare(_mutator: &amp;mut Mutator &lt;MyGC&lt;VM&gt;&gt;, _tls: OpaquePointer,)</code>. 
This function will be called at the preparation stage of a collection 
(at the start of a collection) for each mutator. Its body can stay empty, as 
there aren't any preparation steps for the mutator in this GC.
In <code>create_mygc_mutator()</code>, find the field <code>prep_func</code> and change it from
<code>mygc_mutator_noop()</code> to <code>mygc_mutator_prepare()</code>.</p>
<h2 id="scan-objects"><a class="header" href="#scan-objects">Scan objects</a></h2>
<p>Next, we'll add the code to allow the plan to collect garbage - filling out 
functions for work packets.</p>
<p>In <code>gc_work.rs</code>, add a new method to <code>ProcessEdgesWork for MyGCProcessEdges</code>,
<code>trace_object(&amp;mut self, object: ObjectReference)</code>.
This method should return an ObjectReference, and use the 
inline attribute.
Check if the object passed into the function is null 
(<code>object.is_null()</code>). If it is, return the object.
Check if which space the object is in, and forward the call to the policy-specific
object tracing code. If it is in neither space, forward the call to the common space and let the common space to handle
object tracing in its spaces (e.g. immortal or large object space):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[inline]
    fn trace_object(&amp;mut self, object: ObjectReference) -&gt; ObjectReference {
        if object.is_null() {
            return object;
        }
        if self.mygc().tospace().in_space(object) {
            self.mygc().tospace().trace_object::&lt;Self, MyGCCopyContext&lt;VM&gt;&gt;(
                self,
                object,
                super::global::ALLOC_MyGC,
                unsafe { self.worker().local::&lt;MyGCCopyContext&lt;VM&gt;&gt;() },
            )
        } else if self.mygc().fromspace().in_space(object) {
            self.mygc().fromspace().trace_object::&lt;Self, MyGCCopyContext&lt;VM&gt;&gt;(
                self,
                object,
                super::global::ALLOC_MyGC,
                unsafe { self.worker().local::&lt;MyGCCopyContext&lt;VM&gt;&gt;() },
            )
        } else {
            self.mygc().common.trace_object::&lt;Self, MyGCCopyContext&lt;VM&gt;&gt;(self, object)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Add two new implementation blocks, <code>Deref</code> and <code>DerefMut</code> for 
<code>MyGCProcessEdges</code>. These allow <code>MyGCProcessEdges</code> to be dereferenced to 
<code>ProcessEdgesBase</code>, and allows easy access to fields in <code>ProcessEdgesBase</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM: VMBinding&gt; Deref for MyGCProcessEdges&lt;VM&gt; {
    type Target = ProcessEdgesBase&lt;Self&gt;;
    #[inline]
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.base
    }
}

impl&lt;VM: VMBinding&gt; DerefMut for MyGCProcessEdges&lt;VM&gt; {
    #[inline]
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.base
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="copying-objects"><a class="header" href="#copying-objects">Copying objects</a></h2>
<p>Go back to the <code>MyGCopyContext</code> in <code>gc_work.rs</code>. 
In <code>alloc_copy()</code>, call the allocator's <code>alloc</code> function. Above the function, 
use an inline attribute (<code>#[inline(always)]</code>) to tell the Rust compiler 
to always inline the function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[inline(always)]
    fn alloc_copy(
        &amp;mut self,
        _original: ObjectReference,
        bytes: usize,
        align: usize,
        offset: isize,
        _semantics: crate::AllocationSemantics,
    ) -&gt; Address {
        self.mygc.alloc(bytes, align, offset)
    }
<span class="boring">}
</span></code></pre></pre>
<p>To <code>post_copy()</code>, in the <code>CopyContext</code> implementations block, add 
<code>forwarding_word::clear_forwarding_bits::&lt;VM&gt;(obj);</code>. Also, add an 
inline attribute.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[inline(always)]
    fn post_copy(
        &amp;mut self,
        obj: ObjectReference,
        _tib: Address,
        _bytes: usize,
        _semantics: crate::AllocationSemantics,
    ) {
        forwarding_word::clear_forwarding_bits::&lt;VM&gt;(obj);
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="release"><a class="header" href="#release">Release</a></h2>
<p>Finally, we need to fill out the functions that are, roughly speaking, 
run after each collection.</p>
<h3 id="release-in-plan"><a class="header" href="#release-in-plan">Release in plan</a></h3>
<p>Find the method <code>release()</code> in <code>global.rs</code>. Replace the 
<code>unreachable!()</code> call with the following code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn release(&amp;self, tls: OpaquePointer) {
        self.common.release(tls, true);
        self.fromspace().release();
    }
<span class="boring">}
</span></code></pre></pre>
<p>This function is called at the end of a collection. It calls the release routines for the common
plan spaces and the fromspace.</p>
<h3 id="release-in-mutator"><a class="header" href="#release-in-mutator">Release in mutator</a></h3>
<p>Go back to <code>mutator.rs</code>. In <code>create_mygc_mutator()</code>, replace 
<code>mygc_mutator_noop()</code> in the <code>release_func</code> field with <code>mygc_mutator_release()</code>.
Leave the <code>release()</code> function in the <code>CopyContext</code> empty. There are no 
release steps for <code>CopyContext</code> in this collector.</p>
<p>Create a new function called <code>mygc_mutator_release()</code> that takes the same 
inputs as the <code>prepare()</code> function above. This function will be called at the 
release stage of a collection (at the end of a collection) for each mutator. 
It rebinds the allocator for the <code>Default</code> allocation semantics to the new 
tospace. When the mutator threads resume, any new allocations for <code>Default</code> 
will then go to the new tospace.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn mygc_mutator_release&lt;VM: VMBinding&gt;(
    mutator: &amp;mut Mutator&lt;VM&gt;,
    _tls: OpaquePointer,
) {
    // rebind the allocation bump pointer to the appropriate semispace
    let bump_allocator = unsafe {
        mutator
            .allocators
            .get_allocator_mut(mutator.config.allocator_mapping[AllocationType::Default])
    }
    .downcast_mut::&lt;BumpAllocator&lt;VM&gt;&gt;()
    .unwrap();
    bump_allocator.rebind(
        mutator
            .plan
            .downcast_ref::&lt;MyGC&lt;VM&gt;&gt;()
            .unwrap()
            .tospace(),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Delete <code>mygc_mutator_noop()</code>. It was a placeholder for the prepare and 
release functions that you have now added, so it is now dead code.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>You should now have MyGC working and able to collect garbage. All three
benchmarks should be able to pass now. </p>
<p>If the benchmarks pass - good job! You have built a functional copying
collector!</p>
<p>If you get particularly stuck, the code for the completed <code>MyGC</code> plan
is available <a href="https://github.com/mmtk/mmtk-core/tree/master/docs/tutorial/code/mygc_semispace">here</a>.</p>
<h1 id="exercise-adding-another-copyspace"><a class="header" href="#exercise-adding-another-copyspace">Exercise: Adding another copyspace</a></h1>
<p>Now that you have a working semispace collector, you should be familiar 
enough with the code to start writing some yourself. The intention of this 
exercise is to reinforce the information from the semispace section, rather 
than to create a useful new collector.</p>
<ol>
<li>Create a copy of your semispace collector, called <code>triplespace</code>. </li>
<li>Add a new copyspace to the collector, called the <code>youngspace</code>, with the 
following traits:
<ul>
<li>New objects are allocated to the youngspace (rather than the fromspace).</li>
<li>During a collection, live objects in the youngspace are moved to the 
tospace.</li>
<li>Garbage is still collected at the same time for all spaces.</li>
</ul>
</li>
</ol>
<p>Triplespace is a sort of generational garbage collector. These collectors 
separate out old objects and new objects into separate spaces. Newly 
allocated objects should be scanned far more often than old objects, which 
minimises the time spent repeatedly re-scanning long-lived objects. </p>
<p>Of course, this means that the Triplespace is incredibly inefficient for a 
generational collector, because the older objects are still being scanned 
every collection. It wouldn't be very useful in a real-life scenario. The 
next thing to do is to make this collector into a more efficient proper 
generational collector.</p>
<p>When you are finished, try running the benchmarks and seeing how the 
performance of this collector compares to MyGC. Great work!</p>
<h1 id="triplespace-backup-instructions"><a class="header" href="#triplespace-backup-instructions">Triplespace backup instructions</a></h1>
<p>This is <em>one</em> possible implementation of the Triplespace collector, provided
in case you are stuck on the exercise. </p>
<p><strong>Attempt the exercise yourself before reading this.</strong></p>
<p>First, rename all instances of <code>mygc</code> to <code>triplespace</code>, and add it as a
module by following the instructions in <a href="mygc/ss/./create.html">Create MyGC</a>.</p>
<p>In <code>global.rs</code>:</p>
<ol>
<li>
<p>Add a <code>youngspace</code> field to <code>pub struct TripleSpace</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TripleSpace&lt;VM: VMBinding&gt; {
   pub hi: AtomicBool,
   pub copyspace0: CopySpace&lt;VM&gt;,
   pub copyspace1: CopySpace&lt;VM&gt;,
   pub youngspace: CopySpace&lt;VM&gt;, // Add this!
   pub common: CommonPlan&lt;VM&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Define the parameters for the youngspace in <code>new()</code> in
<code>Plan for TripleSpace</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(
   vm_map: &amp;'static VMMap,
   mmapper: &amp;'static Mmapper,
   options: Arc&lt;UnsafeOptionsWrapper&gt;,
   _scheduler: &amp;'static MMTkScheduler&lt;Self::VM&gt;,
) -&gt; Self {
   //change - again, completely changed.
   let mut heap = HeapMeta::new(HEAP_START, HEAP_END);

   TripleSpace {
       hi: AtomicBool::new(false),
       copyspace0: CopySpace::new(
           &quot;copyspace0&quot;,
           false,
           true,
           VMRequest::discontiguous(),
           vm_map,
           mmapper,
           &amp;mut heap,
       ),
       copyspace1: CopySpace::new(
           &quot;copyspace1&quot;,
           true,
           true,
           VMRequest::discontiguous(),
           vm_map,
           mmapper,
           &amp;mut heap,
       ),

       // Add this!
       youngspace: CopySpace::new(
           &quot;youngspace&quot;,
           true,
           true,
           VMRequest::discontiguous(),
           vm_map,
           mmapper,
           &amp;mut heap,
       ),
       common: CommonPlan::new(vm_map, mmapper, options, heap, &amp;TRIPLESPACE_CONSTRAINTS, &amp;[]),
   }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Initialise the youngspace in <code>gc_init()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn gc_init(
    &amp;mut self,
    heap_size: usize,
    vm_map: &amp;'static VMMap,
    scheduler: &amp;Arc&lt;MMTkScheduler&lt;VM&gt;&gt;,
) {
    self.common.gc_init(heap_size, vm_map, scheduler);
    self.copyspace0.init(&amp;vm_map);
    self.copyspace1.init(&amp;vm_map);
    self.youngspace.init(&amp;vm_map); // Add this!
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Prepare the youngspace (as a fromspace) in <code>prepare()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prepare(&amp;self, tls: OpaquePointer) {
   self.common.prepare(tls, true);
   self.hi
       .store(!self.hi.load(Ordering::SeqCst), Ordering::SeqCst);
   let hi = self.hi.load(Ordering::SeqCst);
   self.copyspace0.prepare(hi);
   self.copyspace1.prepare(!hi);
   self.youngspace.prepare(true); // Add this!
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Release the youngspace in <code>release()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn release(&amp;self, tls: OpaquePointer) {
   self.common.release(tls, true);
   self.fromspace().release();
   self.youngspace().release(); // Add this!
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Under the reference functions <code>tospace()</code> and <code>fromspace()</code>, add a similar
reference function <code>youngspace()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn youngspace(&amp;self) -&gt; &amp;CopySpace&lt;VM&gt; {
   &amp;self.youngspace
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<p>In <code>mutator.rs</code>:</p>
<ol>
<li>Map a bump pointer to the youngspace (replacing the one mapped to the
tospace) in <code>space_mapping</code> in <code>create_triplespace_mutator()</code>:
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>space_mapping: box vec![
    (AllocatorSelector::BumpPointer(0), plan.youngspace()), // Change this!
    (
        AllocatorSelector::BumpPointer(1),
        plan.common.get_immortal(),
    ),
    (AllocatorSelector::LargeObject(0), plan.common.get_los()),
],
<span class="boring">}
</span></code></pre></pre>
</li>
<li>Rebind the bump pointer to youngspace (rather than the tospace) in
<code>triplespace_mutator_release()</code>:
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn triplespace_mutator_release&lt;VM: VMBinding&gt; (
    mutator: &amp;mut Mutator&lt;VM&gt;,
    _tls: OpaquePointer
) {
    let bump_allocator = unsafe {
        mutator
            .allocators
            . get_allocator_mut(
                mutator.config.allocator_mapping[AllocationType::Default]
            )
        }
        .downcast_mut::&lt;BumpAllocator&lt;VM&gt;&gt;()
        .unwrap();
        bump_allocator.rebind(Some(mutator.plan.youngspace())); // Change this!
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<p>In <code>gc_work.rs</code>:</p>
<ol>
<li>Add the youngspace to trace_object, following the same format as
the tospace and fromspace:
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn trace_object(&amp;mut self, object: ObjectReference) -&gt; ObjectReference {
        if object.is_null() {
            return object;
        }

        // Add this!
        else if self.plan().youngspace().in_space(object) {
            self.plan().youngspace.trace_object::&lt;Self, TripleSpaceCopyContext&lt;VM&gt;&gt;(
                self,
                object,
                super::global::ALLOC_TripleSpace,
                unsafe { self.worker().local::&lt;TripleSpaceCopyContext&lt;VM&gt;&gt;() },
            )
        }

        else if self.plan().tospace().in_space(object) {
            self.plan().tospace().trace_object::&lt;Self, TripleSpaceCopyContext&lt;VM&gt;&gt;(
                self,
                object,
                super::global::ALLOC_TripleSpace,
                unsafe { self.worker().local::&lt;MyGCCopyContext&lt;VM&gt;&gt;() },
            )
        } else if self.plan().fromspace().in_space(object) {
            self.plan().fromspace().trace_object::&lt;Self, MyGCCopyContext&lt;VM&gt;&gt;(
                self,
                object,
                super::global::ALLOC_TripleSpace,
                unsafe { self.worker().local::&lt;TripleSpaceCopyContext&lt;VM&gt;&gt;() },
            )
        } else {
            self.plan().common.trace_object::&lt;Self, TripleSpaceCopyContext&lt;VM&gt;&gt;(self, object)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<h1 id="building-a-generational-copying-collector"><a class="header" href="#building-a-generational-copying-collector">Building a generational copying collector</a></h1>
<blockquote>
<p>Note: This part is work in progress.</p>
</blockquote>
<h2 id="what-is-a-generational-collector"><a class="header" href="#what-is-a-generational-collector">What is a generational collector?</a></h2>
<p>The <em>weak generational hypothesis</em> states that most of the objects allocated
to a heap after one collection will die before the next collection.
Therefore, it is worth separating out 'young' and 'old' objects and only
scanning each as needed, to minimise the number of times old live objects are
scanned. New objects are allocated to a 'nursery', and after one collection
they move to the 'mature' space. In <code>triplespace</code>, <code>youngspace</code> is a
proto-nursery, and the <code>tospace</code> and <code>fromspace</code> are the mature spaces.</p>
<p>This collector fixes one of the major problems with semispace - namely, that
any long-lived objects are repeatedly copied back and forth. By separating
these objects into a separate 'mature' space, the number of full heap
collections needed is greatly reduced.</p>
<p>This section is currently incomplete. Instructions for building a
generational copying (gencopy) collector will be added in future.</p>
<h1 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h1>
<ul>
<li><a href="https://www.mmtk.io/mmtk-core/mmtk/index.html">MMTk Crate Documentation</a></li>
<li>Original MMTk papers:
<ul>
<li><a href="https://www.mmtk.io/assets/pubs/mmtk-icse-2004.pdf"><em>Oil and Water? High Performance Garbage Collection in Java with MMTk</em></a> (Blackburn, Cheng, McKinley, 2004)</li>
<li><a href="https://www.mmtk.io/assets/pubs/mmtk-sigmetrics-2004.pdf"><em>Myths and realities: The performance impact of garbage collection</em></a> (Blackburn, Cheng, McKinley, 2004)</li>
</ul>
</li>
<li><a href="https://learning.oreilly.com/library/view/the-garbage-collection/9781315388007"><em>The Garbage Collection Handbook</em></a> (Jones, Hosking, Moss, 2016)</li>
<li>Videos: <a href="https://www.youtube.com/watch?v=3L6XEVaYAmU">MPLR 2020 Keynote</a>, <a href="https://www.youtube.com/watch?v=MAk6RdApGLs">Deconstructing the Garbage-First Collector</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
