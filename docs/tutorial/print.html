<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MMTk Tutorial</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="prefix.html">MMTk Tutorial</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/what_is_mmtk.html"><strong aria-hidden="true">1.1.</strong> What is MMTk?</a></li><li class="chapter-item expanded "><a href="intro/what_will_this_tutorial_cover.html"><strong aria-hidden="true">1.2.</strong> What will this tutorial cover?</a></li><li class="chapter-item expanded "><a href="intro/glossary.html"><strong aria-hidden="true">1.3.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Preliminaries</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="preliminaries/set_up.html"><strong aria-hidden="true">2.1.</strong> Set up MMTk and OpenJDK</a></li><li class="chapter-item expanded "><a href="preliminaries/test.html"><strong aria-hidden="true">2.2.</strong> Test the build</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> MyGC</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="mygc/create.html"><strong aria-hidden="true">3.1.</strong> Create MyGC</a></li><li class="chapter-item expanded "><a href="mygc/ss/prefix.html"><strong aria-hidden="true">3.2.</strong> Building a semispace GC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mygc/ss/alloc.html"><strong aria-hidden="true">3.2.1.</strong> Allocation</a></li><li class="chapter-item expanded "><a href="mygc/ss/collection.html"><strong aria-hidden="true">3.2.2.</strong> Collection</a></li><li class="chapter-item expanded "><a href="mygc/ss/exercise.html"><strong aria-hidden="true">3.2.3.</strong> Exercise</a></li><li class="chapter-item expanded "><a href="mygc/ss/exercise_solution.html"><strong aria-hidden="true">3.2.4.</strong> Exercise solution</a></li></ol></li><li class="chapter-item expanded "><a href="mygc/gencopy.html"><strong aria-hidden="true">3.3.</strong> Building a generational copying GC</a></li></ol></li><li class="chapter-item expanded "><a href="further_reading.html"><strong aria-hidden="true">4.</strong> Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MMTk Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mmtk-tutorial"><a class="header" href="#mmtk-tutorial">MMTk Tutorial</a></h1>
<p>In this tutorial, you will build multiple garbage collectors from 
scratch using MMTk. 
You will start with an incredibly simple 'collector' called NoGC, 
and through a series of additions and refinements end up with a 
generational copying garbage collector. </p>
<p>This tutorial is aimed at GC implementors who would like to implement 
new GC algorithms/plans with MMTk. If you are a language implementor 
interested in <em>porting</em> your runtime to MMTk, you should refer to the 
<a href="https://www.mmtk.io/mmtk-core/portingguide/">porting guide</a> instead.</p>
<p>This tutorial is a work in progress. Some sections may be rough, and others may 
be missing information (especially about import statements). If something is 
missing or inaccurate, refer to the relevant completed garbage collector if
possible. Please also raise an issue, or create a pull request addressing 
the problem. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-mmtk"><a class="header" href="#what-is-mmtk">What <em>is</em> MMTk?</a></h1>
<p>The Memory Management Toolkit (MMTk) is a framework for designing and 
implementing memory managers. It has a runtime-neutral core (mmtk-core) 
written in Rust, and bindings that allow it to work with OpenJDK, V8, 
and JikesRVM, with more bindings currently in development. 
MMTk was originally written in Java as part of the JikesRVM Java runtime.
The current version is similar in its purpose, but was made to be 
very flexible with runtime and able to be ported to many different VMs.</p>
<p>The principal idea of MMTk is that it can be used as a 
toolkit, allowing new GC algorithms to be rapidly developed using 
common components. It also allows different GC algorithms to be 
compared on an apples-to-apples basis, since they share common mechanisms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-will-this-tutorial-cover"><a class="header" href="#what-will-this-tutorial-cover">What will this tutorial cover?</a></h1>
<p>This tutorial is intended to get you comfortable constructing new plans in 
MMTk.</p>
<p>You will first be guided through building a semispace collector. After that, 
you will extend this collector to be a generational collector, to further 
familiarise you with different concepts in MMTk. There will also be 
questions and exercises at various points in the tutorial, intended to 
encourage you to think about what the code is doing, increase your general 
understanding of MMTk, and motivate further research.</p>
<p>Where possible, there will be links to finished, functioning code after each 
section so that you can check that your code is correct. Note, however, that 
these will be full collectors. Therefore, there may be some differences between 
these files and your collector due to your position in the tutorial. By the end 
of each major section, your code should be functionally identical to the 
finished code provided.</p>
<p>Furthermore, please note that this code may not be identical to the main code
of the MMTk. It is deliberately kept separate as a simpler stable
version. Make sure to refer to the 
<a href="https://github.com/mmtk/mmtk-core/tree/master/docs/tutorial/code">provided tutorial code</a> 
and not the main collector code during the tutorial. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p><em>allocator</em>: Code that allocates new objects into memory.</p>
<p><em>collector</em>: Finds and frees memory occupied by 'dead' objects. </p>
<p><em>dead</em>: An object that is not live.</p>
<p><em>GC work (unit), GC packet</em>: A schedulable unit of collection work. </p>
<p><em>GC worker</em>: A worker thread that performs garbage collection operations 
(as required by GC work units).</p>
<p><em>live</em>: An object that is reachable, and thus can still be accessed by other 
objects, is live/alive.</p>
<p><em>mutator</em>: Something that 'mutates', or changes, the objects stored in memory. 
This is the term that is traditionally used in the garbage collection literature 
to describe the running program (because it 'mutates' the object graph).</p>
<p><em>plan</em>: A garbage collection algorithm expressed as a configuration of policies. 
See also <a href="intro/glossary.html#plans-and-policies">Plans and policies</a> below.</p>
<p><em>policy</em>: A specific garbage collection algorithm, such as marksweep, copying, 
immix, etc. Plans are made up of an arrangement of one or more policies. 
See also <a href="intro/glossary.html#plans-and-policies">Plans and policies</a> below.</p>
<p><em>scheduler</em>: Dynamically dispatches units of GC work to workers.</p>
<p><em>zeroing</em>, <em>zero initialization</em>: Initializing and resetting unused memory 
bits to have a value of 0. Required by most memory-safe programming languages.</p>
<p>See also: <a href="intro/../further_reading.html">Further Reading</a></p>
<h2 id="plans-and-policies"><a class="header" href="#plans-and-policies">Plans and Policies</a></h2>
<p>In MMTk, collectors are instantiated as plans, which can be thought of as 
configurations of collector policies. In practice, most production 
collectors and almost all collectors in MMTk are comprised of multiple 
algorithms/policies. For example the gencopy plan describes a configuration 
that combines a copying nursery with a semispace mature space. In MMTk we 
think of these as three spaces, each of which happen to use the copyspace 
policy, and which have a relationship which is defined by the gencopy plan. 
Under the hood, gencopy builds upon a common plan which may also contain other 
policies including a space for code, a read-only space, etc.</p>
<p>Thus, someone wishing to construct a new collector based entirely on existing 
policies may be able to do so in MMTk by simply writing a new plan, which is 
what this tutorial covers.</p>
<p>On the other hand, someone wishing to introduce an entirely new garbage 
collection policy (such as Immix, for example), would need to first create 
a policy which specifies that algorithm, before creating a plan which defines 
how the GC algorithm fits together and utilizes that policy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-up-mmtk-and-openjdk"><a class="header" href="#set-up-mmtk-and-openjdk">Set up MMTk and OpenJDK</a></h1>
<p>This tutorial can be completed with any binding. However, for the sake of 
simplicity, only the setup for the OpenJDK binding will be described in detail 
here. If you would like to use another binding, you will need to follow the 
README files in their respective repositories 
(<a href="https://github.com/mmtk/mmtk-jikesrvm">JikesRVM</a>, 
<a href="https://github.com/mmtk/mmtk-v8">V8</a>)
to set them up, and find appropriate benchmarks for testing. 
Also, while it may be useful to fork the relevant repositories to your own 
account, it is not required for this tutorial.</p>
<p>First, set up OpenJDK, MMTk, and the binding:</p>
<ol>
<li>Clone the OpenJDK binding and mmtk-core repository, and install any relevant
dependencies by following the instructions in the
<a href="https://github.com/mmtk/mmtk-openjdk/blob/master/README.md">OpenJDK binding repository</a>.</li>
<li>Ensure you can build OpenJDK according to the instructions in the READMEs of 
<a href="https://github.com/mmtk/mmtk-core/blob/master/README.md">the mmtk-core repository</a> and the 
<a href="https://github.com/mmtk/mmtk-openjdk/blob/master/README.md">OpenJDK binding repository</a>.
<ul>
<li>Use the <code>slowdebug</code> option when building the OpenJDK binding. This is the 
fastest debug variant to build, and allows for easier debugging and better 
testing. The rest of the tutorial will assume you are using <code>slowdebug</code>.</li>
<li>You can use the env var <code>MMTK_PLAN=[PlanName]</code> to choose a plan to use at run-time.
The plans that are relevant to this tutorial are <code>NoGC</code> and <code>SemiSpace</code>.</li>
<li>Make sure you <em>only</em> use the env var <code>MMTK_PLAN=[PlanName]</code> when you run the generated <code>java</code> binary
(<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java</code>). Do not set <code>MMTK_PLAN</code>
when you build OpenJDK (if you already have set the env var <code>MMTK_PLAN</code>, you would need to do
<code>export MMTK_PLAN=</code> or <code>unset MMTK_PLAN</code> to clear the env var before building).</li>
</ul>
</li>
</ol>
<p>The MMTk OpenJDK binding ships with a fixed version of mmtk-core, specified in <code>mmtk-openjdk/mmtk/Cargo.toml</code>.
For local development, you would need to build the binding with a local copy of the mmtk-core repo that you
can modify. You would need to point the mmtk dependency to a local path.</p>
<ol>
<li>Find <code>mmtk</code> under <code>[dependencies]</code> in <code>mmtk-openjdk/mmtk/Cargo.toml</code>. It should point
to the mmtk-core git path with a specific revision.</li>
<li>Comment out the line for the git dependency, and uncomment the following line for a local dependency.</li>
<li>The local dependency points to <code>mmtk-openjdk/repos/mmtk-core</code> by default. If your local mmtk-core path is
not <code>mmtk-openjdk/repos/mmtk-core</code>, modify the path to point to your local mmtk-core.</li>
<li>Rebuild the OpenJDK binding.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-the-build"><a class="header" href="#test-the-build">Test the build</a></h1>
<p>A few benchmarks of varying size will be used throughout the tutorial. If you 
haven't already, set them up now. All of the following commands should be 
entered in <code>repos/openjdk</code>.</p>
<ol>
<li>
<p><strong>HelloWorld</strong> (simplest, will never trigger GC): </p>
<ol>
<li>Copy the following code into a new Java file titled &quot;HelloWorld.java&quot; 
in <code>mmtk-openjdk/repos/openjdk</code>:
<pre><code class="language-java">class HelloWorld {
   public static void main(String[] args) {
      System.out.println(&quot;Hello World!&quot;);
   }
}
</code></pre>
</li>
<li>Use the command 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/javac HelloWorld.java</code>.</li>
<li>Then, run 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java -XX:+UseThirdPartyHeap HelloWorld</code> 
to run HelloWorld.</li>
<li>If your program printed out <code>Hello World!</code> as expected, then 
congratulations, you have MMTk working with OpenJDK!</li>
</ol>
</li>
<li>
<p>The Computer Language Benchmarks Game <strong>fannkuchredux</strong> (micro benchmark, 
allocates a small amount of memory but - depending on heap size and the GC 
plan - may not trigger a collection): </p>
<ol>
<li><a href="https://salsa.debian.org/benchmarksgame-team/benchmarksgame/-/blob/master/bencher/programs/fannkuchredux/fannkuchredux.java">Copy this code</a> 
into a new file named &quot;fannkuchredux.java&quot; 
in <code>mmtk-openjdk/repos/openjdk</code>.</li>
<li>Use the command 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/javac fannkuchredux.java</code>.</li>
<li>Then, run 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java -XX:+UseThirdPartyHeap fannkuchredux</code> 
to run fannkuchredux.</li>
</ol>
</li>
<li>
<p><strong>DaCapo</strong> benchmark suite (most complex, will likely trigger multiple 
collections): </p>
<ol>
<li>Fetch using 
<code>wget https://sourceforge.net/projects/dacapobench/files/9.12-bach-MR1/dacapo-9.12-MR1-bach.jar/download -O ./dacapo-9.12-MR1-bach.jar</code>.</li>
<li>DaCapo contains a variety of benchmarks, but this tutorial will only be 
using lusearch. Run the lusearch benchmark using the command 
<code>./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java -XX:+UseThirdPartyHeap -Xms512M -Xmx512M -jar ./dacapo-9.12-MR1-bach.jar lusearch</code> in <code>repos/openjdk</code>. </li>
</ol>
</li>
</ol>
<h2 id="rust-logs"><a class="header" href="#rust-logs">Rust Logs</a></h2>
<p>By using one of the debug builds, you gain access to the Rust logs - a useful 
tool when testing a plan and observing the general behaviour of MMTk. 
There are two levels of trace that are useful when using MMTk - <code>trace</code> 
and <code>debug</code>. Generally, <code>debug</code> logs information about the slow paths 
(allocation through MMTk, rather than fast path allocation through the binding). 
<code>trace</code> includes all the information from <code>debug</code>, plus more information about 
both slow and fast paths and garbage collection activities. You can set which 
level to view the logs at by setting the environment variable <code>RUST_LOG</code>. For 
more information, see the 
<a href="https://crates.io/crates/env_logger">env_logger crate documentation</a>.</p>
<h2 id="working-with-different-gc-plans"><a class="header" href="#working-with-different-gc-plans">Working with different GC plans</a></h2>
<p>You will be using multiple GC plans in this tutorial. You should
familiarise yourself with how to do this now.</p>
<ol>
<li>The OpenJDK build will always generate in <code>mmtk-openjdk/repos/openjdk/build</code>. 
From the same build, you can run different GC plans by using the environment 
variable <code>MMTK_PLAN=[PlanName]</code>. Generally you won't need multiple VM builds. 
However, if you do need to keep a build (for instance, to make quick performance
comparisons), you can do the following: rename either the <code>build</code> folder or the 
folder generated within it (eg <code>linux-x86_64-normal-server-$DEBUG_LEVEL</code>). 
<ol>
<li>Renaming the <code>build</code> folder is the safest method for this.</li>
<li>If you rename the internal folder, there is a possibility that the new 
build will generate incorrectly. If a build appears to generate strangely 
quickly, it probably generated badly.</li>
<li>A renamed build folder can be tested by changing the file path in 
commands as appropriate.</li>
<li>If you plan to completely overwrite a build, deleting the folder you are 
writing over will help prevent errors.</li>
</ol>
</li>
<li>Try running your build with <code>NoGC</code>. Both HelloWorld and the fannkuchredux 
benchmark should run without issue. If you then run lusearch, it should fail 
when a collection is triggered. It is possible to increase the heap size enough 
that no collections will be triggered, but it is okay to let it fail for now. 
When we build using a proper GC, it will be able to pass. The messages and 
errors produced should look identical or nearly identical to the log below.
<pre><code>$ MMTK_PLAN=NoGC ./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java -XX:+UseThirdPartyHeap -Xms512M -Xmx512M -jar ./dacapo-9.12-MR1-bach.jar lusearch
Using scaled threading model. 24 processors detected, 24 threads used to drive the workload, in a possible range of [1,64]
Warning: User attempted a collection request, but it is not supported in NoGC. The request is ignored.
===== DaCapo 9.12-MR1 lusearch starting =====
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
thread '&lt;unnamed&gt;' panicked at 'internal error: entered unreachable code: GC triggered in nogc', /opt/rust/toolchains/nightly-2020-07-08-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/macros.rs:16:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
[2020-12-18T00:27:49Z INFO  mmtk::plan::global]   [POLL] nogc_space: Triggering collection
fatal runtime error: failed to initiate panic, error 5
Aborted (core dumped)
</code></pre>
</li>
<li>Try running your build with <code>SemiSpace</code>. lusearch should now
pass, as garbage will be collected, and the smaller benchmarks should run the 
same as they did while using NoGC.
<pre><code>MMTK_PLAN=SemiSpace ./build/linux-x86_64-normal-server-$DEBUG_LEVEL/jdk/bin/java -XX:+UseThirdPartyHeap -Xms512M -Xmx512M -jar ./dacapo-9.12-MR1-bach.jar lusearch
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-mygc"><a class="header" href="#create-mygc">Create MyGC</a></h1>
<p>NoGC is a GC plan that only allocates memory, and does not have a collector. 
We're going to use it as a base for building a new garbage collector.</p>
<p>Recall that this tutorial will take you through the steps of building a 
collector from basic principles. To do that, you'll create your own plan 
called <code>MyGC</code> which you'll gradually refine and improve upon through the 
course of this tutorial. At the beginning MyGC will resemble the very 
simple NoGC plan.</p>
<ol>
<li>Each plan is stored in <code>mmtk-openjdk/repos/mmtk-core/src/plan</code>. Navigate 
there and create a copy of the folder <code>nogc</code>. Rename it to <code>mygc</code>.</li>
<li>In <em>each file</em> within <code>mygc</code>, rename any reference to <code>nogc</code> to <code>mygc</code>. 
You will also have to separately rename any reference to <code>NoGC</code> to <code>MyGC</code>.
<ul>
<li>For example, in Visual Studio Code, you can (making sure case sensitivity 
is selected in the search function) select one instance of <code>nogc</code> and either 
right click and select &quot;Change all instances&quot; or use the CTRL-F2 shortcut, 
and then type <code>mygc</code>, and repeat for <code>NoGC</code>.</li>
</ul>
</li>
<li>In order to use MyGC, you will need to make some changes to the following 
files. 
<ol>
<li><code>mmtk-core/src/plan/mod.rs</code>, add:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod mygc;
<span class="boring">}</span></code></pre></pre>
This adds <code>mygc</code> as a module.</li>
<li><code>mmtk-core/src/util/options.rs</code>, add <code>MyGC</code> to the enum <code>PlanSelector</code>. 
This allows MMTk to accept <code>MyGC</code> as a command line option for <code>plan</code>, 
or an environment variable for <code>MMTK_PLAN</code>:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, EnumFromStr, Debug)]
pub enum PlanSelector {
    NoGC,
    SemiSpace,
    GenCopy,
    GenImmix,
    MarkSweep,
    PageProtect,
    Immix,
    // Add this!
    MyGC,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li><code>mmtk-core/src/plan/global.rs</code>, add new expressions to 
<code>create_mutator()</code> and <code>create_plan()</code> for <code>MyGC</code>, following the pattern of 
the existing plans. These define the location of the mutator and plan's 
constructors. 
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOTE: Sections of this code snippet not relevant to this step of the 
// tutorial (marked by &quot;// ...&quot;) have been omitted.
pub fn create_mutator&lt;VM: VMBinding&gt;(
    tls: VMMutatorThread,
    mmtk: &amp;'static MMTK&lt;VM&gt;,
) -&gt; Box&lt;Mutator&lt;VM&gt;&gt; {
    Box::new(match mmtk.options.plan {
        PlanSelector::NoGC =&gt; crate::plan::nogc::mutator::create_nogc_mutator(tls, &amp;*mmtk.plan),
        PlanSelector::SemiSpace =&gt; {
            crate::plan::semispace::mutator::create_ss_mutator(tls, &amp;*mmtk.plan)
        }

        // ...

        // Create MyGC mutator based on selector
        PlanSelector::MyGC =&gt; crate::plan::mygc::mutator::create_mygc_mutator(tls, &amp;*mmtk.plan),    })
}

pub fn create_plan&lt;VM: VMBinding&gt;(
    plan: PlanSelector,
    vm_map: &amp;'static VMMap,
    mmapper: &amp;'static Mmapper,
    options: Arc&lt;UnsafeOptionsWrapper&gt;,
) -&gt; Box&lt;dyn Plan&lt;VM = VM&gt;&gt; {
    match plan {
        PlanSelector::NoGC =&gt; Box::new(crate::plan::nogc::NoGC::new(args)),
        PlanSelector::SemiSpace =&gt; Box::new(crate::plan::semispace::SemiSpace::new(args)),

        // ...

        // Create MyGC plan based on selector
        PlanSelector::MyGC =&gt; Box::new(crate::plan::mygc::MyGC::new(args))
    }
}       
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
</li>
</ol>
<p>Note that all of the above changes almost exactly copy the NoGC entries in 
each of these files. However, NoGC has some variants, such as a lock-free 
variant. For simplicity, those are not needed for this tutorial. Remove 
references to them in the MyGC plan now. </p>
<ol>
<li>Within <code>mygc/global.rs</code>, find any use of <code>#[cfg(feature = &quot;mygc_lock_free&quot;)]</code> 
and delete both it <em>and the line below it</em>.</li>
<li>Then, delete any use of the above line's negation, 
<code>#[cfg(not(feature = &quot;mygc_lock_free&quot;))]</code>, this time without changing the 
line below it.</li>
</ol>
<p>After you rebuild OpenJDK (and <code>mmtk-core</code>), you can run MyGC with your new 
build (<code>MMTK_PLAN=MyGC</code>). Try testing it with the each of the three benchmarks. 
It should work identically to NoGC.</p>
<p>If you've got to this point, then congratulations! You have created your first 
working MMTk collector!</p>
<p>At this point, you should familiarise yourself with the MyGC plan if you 
haven't already. Try answering the following questions by looking at the code 
and <a href="mygc/../further_reading.html">Further Reading</a>: </p>
<ul>
<li>Where is the allocator defined?</li>
<li>How many memory spaces are there?</li>
<li>What kind of memory space policy is used?</li>
<li>What happens if garbage has to be collected?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-semispace-collector"><a class="header" href="#building-a-semispace-collector">Building a semispace collector</a></h1>
<p>In a semispace collector, the heap is divided into two equally-sized spaces, 
called 'semispaces'. One of these is defined as a 'fromspace', and the other 
a 'tospace'. The allocator allocates to the tospace until it is full. </p>
<p>When the tospace is full, a stop-the-world GC is triggered. The mutator is 
paused, and the definitions of the spaces are flipped (the 'tospace' becomes 
a 'fromspace', and vice versa). Then, the collector scans each object in what 
is now the fromspace. If a live object is found, a copy of it is made in the 
tospace. That is to say, live objects are copied <em>from</em> the fromspace <em>to</em> 
the tospace. After every object is scanned, the fromspace is cleared. The GC 
finishes, and the mutator is resumed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allocation-add-copyspaces"><a class="header" href="#allocation-add-copyspaces">Allocation: Add copyspaces</a></h1>
<p>We will now change your MyGC plan from one that cannot collect garbage
into one that implements the semispace algorithm. The first step of this
is to add the two copyspaces, and allow collectors to allocate memory 
into them. This involves adding two copyspaces, the code to properly initialise 
and prepare the new spaces, and a copy context.</p>
<h2 id="change-the-plan-constraints"><a class="header" href="#change-the-plan-constraints">Change the plan constraints</a></h2>
<p>Firstly, change the plan constraints. Some of these constraints are not used 
at the moment, but it's good to set them properly regardless.</p>
<p>Look in <code>plan/plan_constraints.rs</code>. <code>PlanConstraints</code> lists all the possible
options for plan-specific constraints. At the moment, <code>MYGC_CONSTRAINTS</code> in 
<code>mygc/global.rs</code> should be using the default value for <code>PlanConstraints</code>. 
We will make the following changes:</p>
<ol>
<li>Initialize <code>gc_header_bits</code> to 2. We reserve 2 bits in the header for GC use.</li>
<li>Initialize <code>moves_objects</code> to <code>true</code>.</li>
<li>Initialize <code>num_specialized_scans</code> to 1.</li>
</ol>
<p>Finished code (step 1-3):</p>
<pre><code>pub const MYGC_CONSTRAINTS: PlanConstraints = PlanConstraints {
    moves_objects: true,
    gc_header_bits: 2,
    gc_header_words: 0,
    num_specialized_scans: 1,
    ..PlanConstraints::default()
};
</code></pre>
<h2 id="change-the-plan-implementation"><a class="header" href="#change-the-plan-implementation">Change the plan implementation</a></h2>
<p>Next, in <code>mygc/global.rs</code>, replace the old immortal (nogc) space with two 
copyspaces.</p>
<h3 id="imports"><a class="header" href="#imports">Imports</a></h3>
<p>To the import statement block:</p>
<ol>
<li>Replace <code>crate::plan::global::{BasePlan, NoCopy};</code> with 
<code>use crate::plan::global::BasePlan;</code>. This collector is going to use 
copying, so there's no point to importing NoCopy any more.</li>
<li>Add <code>use crate::plan::global::CommonPlan;</code>. Semispace uses the common
plan, which includes an immortal space and a large object space, rather 
than the base plan. Any garbage collected plan should use <code>CommonPlan</code>.</li>
<li>Add <code>use std::sync::atomic::{AtomicBool, Ordering};</code>. These are going 
to be used to store an indicator of which copyspace is the tospace.</li>
<li>Delete <code>#[allow(unused_imports)]</code>.</li>
</ol>
<p>Finished code (step 1):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::plan::global::BasePlan; //Modify
use crate::plan::global::CommonPlan; // Add
use crate::plan::global::GcStatus; // Add
use crate::plan::global::{CreateGeneralPlanArgs, CreateSpecificPlanArgs};
use crate::plan::mygc::mutator::ALLOCATOR_MAPPING;
use crate::plan::mygc::gc_work::MyGCWorkContext;
use crate::plan::AllocationSemantics;
use crate::plan::Plan;
use crate::plan::PlanConstraints;
use crate::policy::copyspace::CopySpace; // Add
use crate::policy::space::Space;
use crate::scheduler::*; // Modify
use crate::util::alloc::allocators::AllocatorSelector;
use crate::util::copy::*;
use crate::util::heap::VMRequest;
use crate::util::metadata::side_metadata::{SideMetadataSanity, SideMetadataContext};
use crate::util::opaque_pointer::*;
use crate::vm::VMBinding;
use enum_map::EnumMap;
use std::sync::atomic::{AtomicBool, Ordering}; // Add
<span class="boring">}</span></code></pre></pre>
<h3 id="struct-mygc"><a class="header" href="#struct-mygc">Struct MyGC</a></h3>
<p>Change <code>pub struct MyGC&lt;VM: VMBinding&gt;</code> to add new instance variables.</p>
<ol>
<li>Delete the existing fields in the constructor.</li>
<li>Add <code>pub hi: AtomicBool,</code>. This is a thread-safe bool, indicating which 
copyspace is the tospace.</li>
<li>Add <code>pub copyspace0: CopySpace&lt;VM&gt;,</code> 
and <code>pub copyspace1: CopySpace&lt;VM&gt;,</code>. These are the two copyspaces.</li>
<li>Add <code>pub common: CommonPlan&lt;VM&gt;,</code>.
This holds an instance of the common plan.</li>
</ol>
<p>Finished code (step 2):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PlanTraceObject)]
pub struct MyGC&lt;VM: VMBinding&gt; {
    pub hi: AtomicBool,
    #[trace(CopySemantics::DefaultCopy)]
    pub copyspace0: CopySpace&lt;VM&gt;,
    #[trace(CopySemantics::DefaultCopy)]
    pub copyspace1: CopySpace&lt;VM&gt;,
    #[fallback_trace]
    pub common: CommonPlan&lt;VM&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that we have attributes on some fields. These attributes tell MMTk's macros on
how to generate code to trace objects in this plan. Although there are other approaches that
you can implement object tracing, in this tutorial we use the macros, as it is the simplest.
Make sure you import the macros. We will discuss on what those attributes mean in later sections.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mmtk_macros::PlanTraceObject;
<span class="boring">}</span></code></pre></pre>
<h3 id="implement-the-plan-trait-for-mygc"><a class="header" href="#implement-the-plan-trait-for-mygc">Implement the Plan trait for MyGC</a></h3>
<h4 id="constructor"><a class="header" href="#constructor">Constructor</a></h4>
<p>Change <code>fn new()</code>. This section initialises and prepares the objects in MyGC 
that you just defined.</p>
<ol>
<li>Delete the definition of <code>mygc_space</code>. 
Instead, we will define the two copyspaces here.</li>
<li>Define one of the copyspaces by adding the following code: </li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            copyspace0: CopySpace::new(plan_args.get_space_args(&quot;copyspace0&quot;, true, VMRequest::discontiguous()), false),
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>Create another copyspace, called <code>copyspace1</code>, defining it as a fromspace 
instead of a tospace. (Hint: the definitions for 
copyspaces are in <code>src/policy/copyspace.rs</code>.) </li>
<li>Finally, replace the old MyGC initializer.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new(args: CreateGeneralPlanArgs&lt;VM&gt;) -&gt; Self {
        // Modify
        let mut plan_args = CreateSpecificPlanArgs {
            global_args: args,
            constraints: &amp;MYGC_CONSTRAINTS,
            global_side_metadata_specs: SideMetadataContext::new_global_specs(&amp;[]),
        };

        let res = MyGC {
            hi: AtomicBool::new(false),
            copyspace0: CopySpace::new(plan_args.get_space_args(&quot;copyspace0&quot;, true, VMRequest::discontiguous()), false),
            copyspace1: CopySpace::new(plan_args.get_space_args(&quot;copyspace1&quot;, true, VMRequest::discontiguous()), true),
            common: CommonPlan::new(plan_args),
        };

        // Use SideMetadataSanity to check if each spec is valid. This is also needed for check
        // side metadata in extreme_assertions.
        let mut side_metadata_sanity_checker = SideMetadataSanity::new();
        res.common.verify_side_metadata_sanity(&amp;mut side_metadata_sanity_checker);
        res.copyspace0.verify_side_metadata_sanity(&amp;mut side_metadata_sanity_checker);
        res.copyspace1.verify_side_metadata_sanity(&amp;mut side_metadata_sanity_checker);

        res
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="access-mygc-spaces"><a class="header" href="#access-mygc-spaces">Access MyGC spaces</a></h3>
<p>Add a new section of methods for MyGC:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM: VMBinding&gt; MyGC&lt;VM&gt; {
}
<span class="boring">}</span></code></pre></pre>
<p>To this, add two helper methods, <code>tospace(&amp;self)</code> 
and <code>fromspace(&amp;self)</code>. They both have return type <code>&amp;CopySpace&lt;VM&gt;</code>, 
and return a reference to the tospace and fromspace respectively. 
<code>tospace()</code> (see below) returns a reference to the tospace, 
and <code>fromspace()</code> returns a reference to the fromspace.</p>
<p>We also add another two helper methods to get <code>tospace_mut(&amp;mut self)</code>
and <code>fromspace_mut(&amp;mut self)</code>. Those will be used later when we implement
collection for our GC plan.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn tospace(&amp;self) -&gt; &amp;CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;self.copyspace1
        } else {
            &amp;self.copyspace0
        }
    }

    pub fn fromspace(&amp;self) -&gt; &amp;CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;self.copyspace0
        } else {
            &amp;self.copyspace1
        }
    }

    pub fn tospace_mut(&amp;mut self) -&gt; &amp;mut CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;mut self.copyspace1
        } else {
            &amp;mut self.copyspace0
        }
    }

    pub fn fromspace_mut(&amp;mut self) -&gt; &amp;mut CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;mut self.copyspace0
        } else {
            &amp;mut self.copyspace1
        }
    }
<span class="boring">}</span></code></pre></pre>
<h4 id="other-methods-in-the-plan-trait"><a class="header" href="#other-methods-in-the-plan-trait">Other methods in the Plan trait</a></h4>
<p>The trait <code>Plan</code> requires a <code>common()</code> method that should return a 
reference to the common plan. Implement this method now.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn common(&amp;self) -&gt; &amp;CommonPlan&lt;VM&gt; {
        &amp;self.common
    }
<span class="boring">}</span></code></pre></pre>
<p>Find the helper method <code>base</code> and change it so that it calls the 
base plan <em>through</em> the common plan.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn base(&amp;self) -&gt; &amp;BasePlan&lt;VM&gt; {
        &amp;self.common.base
    }
<span class="boring">}</span></code></pre></pre>
<p>The trait <code>Plan</code> requires <code>collection_required()</code> method to know when
we should trigger a collection. We can just use the implementation
in the <code>BasePlan</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn collection_required(&amp;self, space_full: bool, _space: Option&lt;&amp;dyn Space&lt;Self::VM&gt;&gt;) -&gt; bool {
        self.base().collection_required(self, space_full)
    }
<span class="boring">}</span></code></pre></pre>
<p>Find the method <code>get_pages_used</code>. Replace the current body with 
<code>self.tospace().reserved_pages() + self.common.get_pages_used()</code>, to 
correctly count the pages contained in the tospace and the common plan 
spaces (which will be explained later).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn get_used_pages(&amp;self) -&gt; usize {
        self.tospace().reserved_pages() + self.common.get_used_pages()
    }
<span class="boring">}</span></code></pre></pre>
<p>Add and override the following helper function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn get_collection_reserved_pages(&amp;self) -&gt; usize {
        self.tospace().reserved_pages()
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="change-the-mutator-definition"><a class="header" href="#change-the-mutator-definition">Change the mutator definition</a></h2>
<p>Next, we need to change the mutator, in <code>mutator.rs</code>, to allocate to the 
tospace, and to the two spaces controlled by the common plan. </p>
<h3 id="imports-1"><a class="header" href="#imports-1">Imports</a></h3>
<p>Change the following import statements:</p>
<ol>
<li>Add <code>use super::MyGC;</code>.</li>
<li>Add <code>use crate::util::alloc::BumpAllocator;</code>.</li>
<li>Delete <code>use crate::plan::mygc::MyGC;</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::MyGC; // Add
use crate::Plan;
use crate::plan::barriers::NoBarrier;
use crate::plan::mutator_context::Mutator;
use crate::plan::mutator_context::MutatorConfig;
use crate::plan::AllocationSemantics;
use crate::util::alloc::allocators::{AllocatorSelector, Allocators};
use crate::util::alloc::BumpAllocator;
use crate::util::opaque_pointer::*;
use crate::vm::VMBinding;
use crate::plan::mutator_context::{
    create_allocator_mapping, create_space_mapping, ReservedAllocators,
};
use enum_map::EnumMap;
// Remove crate::plan::mygc::MyGC
// Remove mygc_mutator_noop
<span class="boring">}</span></code></pre></pre>
<h3 id="allocator-mapping"><a class="header" href="#allocator-mapping">Allocator mapping</a></h3>
<p>In <code>lazy_static!</code>, make the following changes to <code>ALLOCATOR_MAPPING</code>, 
which maps the required allocation semantics to the corresponding allocators. 
For example, for <code>Default</code>, we allocate using the first bump pointer allocator 
(<code>BumpPointer(0)</code>):</p>
<ol>
<li>Define a <code>ReservedAllocators</code> instance to declare that we need one bump allocator.</li>
<li>Map the common plan allocators using <code>create_allocator_mapping</code>.</li>
<li>Map <code>Default</code> to <code>BumpPointer(0)</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RESERVED_ALLOCATORS: ReservedAllocators = ReservedAllocators {
    n_bump_pointer: 1,
    ..ReservedAllocators::DEFAULT
};

lazy_static! {
    pub static ref ALLOCATOR_MAPPING: EnumMap&lt;AllocationSemantics, AllocatorSelector&gt; = {
        let mut map = create_allocator_mapping(RESERVED_ALLOCATORS, true);
        map[AllocationSemantics::Default] = AllocatorSelector::BumpPointer(0);
        map
    };
}
<span class="boring">}</span></code></pre></pre>
<h3 id="space-mapping"><a class="header" href="#space-mapping">Space mapping</a></h3>
<p>Next, in <code>create_mygc_mutator</code>, change which allocator is allocated to what 
space in <code>space_mapping</code>. Note that the space allocation is formatted as a list 
of tuples. For example, the first bump pointer allocator (<code>BumpPointer(0)</code>) is 
bound with <code>tospace</code>.</p>
<p>Downcast the dynamic <code>Plan</code> type to <code>MyGC</code> so we can access specific spaces in 
<code>MyGC</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mygc = plan.downcast_ref::&lt;MyGC&lt;VM&gt;&gt;().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Then, use <code>mygc</code> to access the spaces in <code>MyGC</code>.</p>
<ol>
<li><code>BumpPointer(0)</code> should map to the tospace.</li>
<li>Other common plan allocators should be mapped using <code>create_space_mapping</code>.</li>
<li>None of the above should be dereferenced (ie, they should not have
the <code>&amp;</code> prefix).</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        space_mapping: Box::new({
            let mut vec = create_space_mapping(RESERVED_ALLOCATORS, true, plan);
            vec.push((AllocatorSelector::BumpPointer(0), mygc.tospace()));
            vec
        }),
<span class="boring">}</span></code></pre></pre>
<p>The <code>create_space_mapping</code> and <code>create_allocator_mapping</code> call that have appeared all
of a sudden in these past 2 steps, are parts of the MMTk common plan
itself. They are used to construct allocator-space mappings for the spaces defined
by the common plan:</p>
<ol>
<li>The immortal space is used for objects that the virtual machine or a 
library never expects to die.</li>
<li>The large object space is needed because MMTk handles particularly large 
objects differently to normal objects, as the space overhead of copying 
large objects is very high. Instead, this space is used by a free list 
allocator in the common plan to avoid having to copy them. </li>
<li>The read-only space is used to store all the immutable objects.</li>
<li>The code spaces are used for VM generated code objects.</li>
</ol>
<p>With this, you should have the allocation working, but not garbage collection. 
Try building again. If you run HelloWorld or Fannkunchredux, they should
work. DaCapo's lusearch should fail, as it requires garbage to be collected. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection-implement-garbage-collection"><a class="header" href="#collection-implement-garbage-collection">Collection: Implement garbage collection</a></h1>
<p>We need to add a few more things to get garbage collection working. 
Specifically, we need to config the <code>GCWorkerCopyContext</code>, which a GC worker uses for 
copying objects, and GC work packets that will be scheduled for a collection.</p>
<h2 id="copyconfig"><a class="header" href="#copyconfig">CopyConfig</a></h2>
<p><code>CopyConfig</code> defines how a GC plan copies objects.
Similar to the <code>MutatorConfig</code> struct, you would need to define <code>CopyConfig</code> for your plan.</p>
<p>In <code>impl&lt;VM: VMBinding&gt; Plan for MyGC&lt;VM&gt;</code>, override the method <code>create_copy_config()</code>.
The default implementation provides a default <code>CopyConfig</code> for non-copying plans. So for non-copying plans,
you do not need to override the method. But
for copying plans, you would have to provide a proper copy configuration.</p>
<p>In a semispace GC, objects will be copied between the two copy spaces. We will use one
<code>CopySpaceCopyContext</code> for the copying, and will rebind the copy context to the proper tospace
in the preparation step of a GC (which will be discussed later when we talk about preparing for collections).</p>
<p>We use <code>CopySemantics::DefaultCopy</code> for our copy
operation, and bind it with the first <code>CopySpaceCopyContext</code> (<code>CopySemantics::DefaultCopy =&gt; CopySelector::CopySpace(0)</code>).
Other copy semantics are unused in this plan. We also provide an initial space
binding for <code>CopySpaceCopyContext</code>. However, we will flip tospace in every GC, and rebind the
copy context to the new tospace in each GC, so it does not matter which space we use as the initial
space here.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn create_copy_config(&amp;'static self) -&gt; CopyConfig&lt;Self::VM&gt; {
        use enum_map::enum_map;
        CopyConfig {
            copy_mapping: enum_map! {
                CopySemantics::DefaultCopy =&gt; CopySelector::CopySpace(0),
                _ =&gt; CopySelector::Unused,
            },
            space_mapping: vec![
                // The tospace argument doesn't matter, we will rebind before a GC anyway.
                (CopySelector::CopySpace(0), &amp;self.copyspace0)
            ],
            constraints: &amp;MYGC_CONSTRAINTS,
        }
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="introduce-collection-to-mygc-plan"><a class="header" href="#introduce-collection-to-mygc-plan">Introduce collection to MyGC plan</a></h2>
<p>Add a new method to <code>Plan for MyGC</code>, <code>schedule_collection()</code>. This function 
runs when a collection is triggered. It schedules GC work for the plan, i.e.,
it stops all mutators, runs the
scheduler's prepare stage and resumes the mutators. The <code>StopMutators</code> work
will invoke code from the bindings to scan threads and other roots, and those 
scanning work will further push work for a transitive closure.</p>
<p>Though you can add those work packets by yourself, <code>GCWorkScheduler</code> provides a
method <code>schedule_common_work()</code> that will add common work packets for you.</p>
<p>To use <code>schedule_common_work()</code>, first we need to create a type <code>MyGCWorkContext</code>
and implement the trait <code>GCWorkContext</code> for it. We create <code>gc_work.rs</code> and add the
following implementation. Note that we will use the default
<a href="https://www.mmtk.io/mmtk-core/mmtk/scheduler/gc_work/struct.SFTProcessEdges.html"><code>SFTProcessEdges</code></a>,
which is a general work packet that a plan can use to trace objects. For plans
like semispace, <code>SFTProcessEdges</code> is sufficient. For more complex GC plans,
one can create and write their own work packet that implements the <code>ProcessEdgesWork</code> trait.
We will discuss about this later, and discuss the alternatives.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCWorkContext&lt;VM: VMBinding&gt;(std::marker::PhantomData&lt;VM&gt;);
impl&lt;VM: VMBinding&gt; crate::scheduler::GCWorkContext for MyGCWorkContext&lt;VM&gt; {
    type VM = VM;
    type PlanType = MyGC&lt;VM&gt;;
    type ProcessEdgesWorkType = SFTProcessEdges&lt;Self::VM&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Then we implement <code>schedule_collection()</code> using <code>MyGCWorkContext</code> and <code>schedule_common_work()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn schedule_collection(&amp;'static self, scheduler: &amp;GCWorkScheduler&lt;VM&gt;) {
        self.base().set_collection_kind::&lt;Self&gt;(self);
        self.base().set_gc_status(GcStatus::GcPrepare);
        scheduler.schedule_common_work::&lt;MyGCWorkContext&lt;VM&gt;&gt;(self);
    }
<span class="boring">}</span></code></pre></pre>
<p>Delete <code>handle_user_collection_request()</code>. This function was an override of 
a Common plan function to ignore user requested collection for NoGC. Now we 
remove it and allow user requested collection.</p>
<h2 id="prepare-for-collection"><a class="header" href="#prepare-for-collection">Prepare for collection</a></h2>
<p>The collector has a number of steps it needs to perform before each collection.
We'll add these now.</p>
<h3 id="prepare-plan"><a class="header" href="#prepare-plan">Prepare plan</a></h3>
<p>In <code>mygc/global.rs</code>, find the method <code>prepare</code>. Delete the <code>unreachable!()</code> 
call, and add the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn prepare(&amp;mut self, tls: VMWorkerThread) {
        self.common.prepare(tls, true);

        self.hi
            .store(!self.hi.load(Ordering::SeqCst), Ordering::SeqCst);
        // Flips 'hi' to flip space definitions
        let hi = self.hi.load(Ordering::SeqCst);
        self.copyspace0.prepare(hi);
        self.copyspace1.prepare(!hi);

        self.fromspace_mut()
            .set_copy_for_sft_trace(Some(CopySemantics::DefaultCopy));
        self.tospace_mut().set_copy_for_sft_trace(None);
    }
<span class="boring">}</span></code></pre></pre>
<p>This function is called at the start of a collection. It prepares the two 
spaces in the common plan, flips the definitions for which space is 'to' 
and which is 'from', then prepares the copyspaces with the new definition.</p>
<p>Note that we call <code>set_copy_for_sft_trace()</code> for both spaces. This step is required
when using <code>SFTProcessEdges</code> to tell the spaces which copy semantic to use for copying.
For fromspace, we use the <code>DefaultCopy</code> semantic, which we have defined earlier in our <code>CopyConfig</code>.
So for objects in fromspace that need to be copied, the policy will use the copy context that binds with
<code>DefaultCopy</code> (which allocates to the tospace) in the GC worker. For tospace, we set its
copy semantics to <code>None</code>, as we do not expect to copy objects from tospace, and if that ever happens,
we will simply panic.</p>
<h3 id="prepare-worker"><a class="header" href="#prepare-worker">Prepare worker</a></h3>
<p>As we flip tospace for the plan, we also need to rebind the copy context
to the new tospace. We will override <code>prepare_worker()</code> in our <code>Plan</code> implementation.
<code>Plan.prepare_worker()</code> is executed by each GC worker in the preparation phase of a GC. The code
is straightforward -- we get the first <code>CopySpaceCopyContext</code>, and call <code>rebind()</code> on it with
the new <code>tospace</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn prepare_worker(&amp;self, worker: &amp;mut GCWorker&lt;VM&gt;) {
        unsafe { worker.get_copy_context_mut().copy[0].assume_init_mut() }.rebind(self.tospace());
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="prepare-mutator"><a class="header" href="#prepare-mutator">Prepare mutator</a></h3>
<p>Going back to <code>mutator.rs</code>, create a new function called 
<code>mygc_mutator_prepare(_mutator: &amp;mut Mutator &lt;MyGC&lt;VM&gt;&gt;, _tls: OpaquePointer,)</code>. 
This function will be called at the preparation stage of a collection 
(at the start of a collection) for each mutator. Its body can stay empty, as 
there aren't any preparation steps for the mutator in this GC.
In <code>create_mygc_mutator()</code>, find the field <code>prep_func</code> and change it from
<code>mygc_mutator_noop()</code> to <code>mygc_mutator_prepare()</code>.</p>
<h2 id="release"><a class="header" href="#release">Release</a></h2>
<p>Finally, we need to fill out the functions that are, roughly speaking, 
run after each collection.</p>
<h3 id="release-in-plan"><a class="header" href="#release-in-plan">Release in plan</a></h3>
<p>Find the method <code>release()</code> in <code>mygc/global.rs</code>. Replace the 
<code>unreachable!()</code> call with the following code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn release(&amp;mut self, tls: VMWorkerThread) {
        self.common.release(tls, true);
        self.fromspace().release();
    }
<span class="boring">}</span></code></pre></pre>
<p>This function is called at the end of a collection. It calls the release 
routines for the common plan spaces and the fromspace.</p>
<h3 id="release-in-mutator"><a class="header" href="#release-in-mutator">Release in mutator</a></h3>
<p>Go back to <code>mutator.rs</code>. In <code>create_mygc_mutator()</code>, replace 
<code>mygc_mutator_noop()</code> in the <code>release_func</code> field with <code>mygc_mutator_release()</code>.
Leave the <code>release()</code> function in the <code>CopyContext</code> empty. There are no 
release steps for <code>CopyContext</code> in this collector.</p>
<p>Create a new function called <code>mygc_mutator_release()</code> that takes the same 
inputs as the <code>prepare()</code> function above. This function will be called at the 
release stage of a collection (at the end of a collection) for each mutator. 
It rebinds the allocator for the <code>Default</code> allocation semantics to the new 
tospace. When the mutator threads resume, any new allocations for <code>Default</code> 
will then go to the new tospace.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn mygc_mutator_release&lt;VM: VMBinding&gt;(
    mutator: &amp;mut Mutator&lt;VM&gt;,
    _tls: VMWorkerThread,
) {
    // rebind the allocation bump pointer to the appropriate semispace
    let bump_allocator = unsafe {
        mutator
            .allocators
            .get_allocator_mut(mutator.config.allocator_mapping[AllocationSemantics::Default])
    }
    .downcast_mut::&lt;BumpAllocator&lt;VM&gt;&gt;()
    .unwrap();
    bump_allocator.rebind(
        mutator
            .plan
            .downcast_ref::&lt;MyGC&lt;VM&gt;&gt;()
            .unwrap()
            .tospace(),
    );
}
<span class="boring">}</span></code></pre></pre>
<p>Delete <code>mygc_mutator_noop()</code>. It was a placeholder for the prepare and 
release functions that you have now added, so it is now dead code.</p>
<h2 id="processedgeswork-for-mygc"><a class="header" href="#processedgeswork-for-mygc">ProcessEdgesWork for MyGC</a></h2>
<p><a href="https://www.mmtk.io/mmtk-core/mmtk/scheduler/gc_work/trait.ProcessEdgesWork.html"><code>ProcessEdgesWork</code></a>
is the key work packet for tracing objects in a GC. A <code>ProcessEdgesWork</code> implementation
defines how to trace objects, and how to generate more work packets based on the current tracing
to finish the object closure.</p>
<p><code>GCWorkContext</code> specifies a type
that implements <code>ProcessEdgesWork</code>, and we used <code>SFTProcessEdges</code> earlier. In
this section, we discuss what <code>SFTProcessEdges</code> does, and what the alternatives
are.</p>
<h3 id="approach-1-use-sftprocessedges"><a class="header" href="#approach-1-use-sftprocessedges">Approach 1: Use <code>SFTProcessEdges</code></a></h3>
<p><a href="https://www.mmtk.io/mmtk-core/mmtk/scheduler/gc_work/struct.SFTProcessEdges.html"><code>SFTProcessEdges</code></a> dispatches
the tracing of objects to their respective spaces through <a href="https://www.mmtk.io/mmtk-core/mmtk/policy/space/trait.SFT.html">Space Function Table (SFT)</a>.
As long as all the policies in a plan provide an implementation of <code>sft_trace_object()</code> in their SFT implementations,
the plan can use <code>SFTProcessEdges</code>. Currently most policies provide an implementation for <code>sft_trace_object()</code>, except
mark compact and immix. Those two policies use multiple GC traces, and due to the limitation of SFT, SFT does not allow
multiple <code>sft_trace_object()</code> for a policy.</p>
<p><code>SFTProcessEdges</code> is the simplest approach when all the policies support it. Fortunately, we can use it for our GC, semispace.</p>
<h3 id="approach-2-derive-plantraceobject-and-use-planprocessedges"><a class="header" href="#approach-2-derive-plantraceobject-and-use-planprocessedges">Approach 2: Derive <code>PlanTraceObject</code> and use <code>PlanProcessEdges</code></a></h3>
<p><code>PlanProcessEdges</code> is another general <code>ProcessEdgesWork</code> implementation that can be used by most plans. When a plan
implements the <a href="https://www.mmtk.io/mmtk-core/mmtk/plan/transitive_closure/trait.PlanTraceObject.html"><code>PlanTraceObject</code></a>,
it can use <code>PlanProcessEdges</code>.</p>
<p>You can manually provide an implementation of <code>PlanTraceObject</code> for <code>MyGC</code>. But you can also use the derive macro MMTK provides,
and the macro will generate an implementation of <code>PlanTraceObject</code>:</p>
<ul>
<li>add <code>#[derive(PlanTraceObject)]</code> for <code>MyGC</code> (import the macro properly: <code>use mmtk_macros::PlanTraceObject</code>)</li>
<li>add <code>#[trace(CopySemantics::Default)]</code> to both copy space fields, <code>copyspace0</code> and <code>copyspace1</code>. This tells the macro to generate
trace code for both spaces, and for any copying in the spaces, use <code>CopySemantics::DefaultCopy</code> that we have configured early.</li>
<li>add <code>#[fallback_trace]</code> to <code>common</code>. This tells the macro that if an object is not found in any space with <code>#[trace]</code> in ths plan,
try find the space for the object in the 'parent' plan. In our case, we fall back to the <code>CommonPlan</code>, as the object may be
in large object space or immortal space in the common plan. <code>CommonPlan</code> also implements <code>PlanTraceObject</code>, so it knows how to
find a space for the object and trace it in the same way.</li>
</ul>
<p>With the derive macro, your <code>MyGC</code> struct should look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PlanTraceObject)]
pub struct MyGC&lt;VM: VMBinding&gt; {
    pub hi: AtomicBool,
    #[trace(CopySemantics::DefaultCopy)]
    pub copyspace0: CopySpace&lt;VM&gt;,
    #[trace(CopySemantics::DefaultCopy)]
    pub copyspace1: CopySpace&lt;VM&gt;,
    #[fallback_trace]
    pub common: CommonPlan&lt;VM&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Once this is done, you can specify <code>PlanProcessEdges</code> as the <code>ProcessEdgesWorkType</code> in your GC work context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::scheduler::gc_work::PlanProcessEdges;
use crate::policy::gc_work::DEFAULT_TRACE;
pub struct MyGCWorkContext2&lt;VM: VMBinding&gt;(std::marker::PhantomData&lt;VM&gt;);
impl&lt;VM: VMBinding&gt; crate::scheduler::GCWorkContext for MyGCWorkContext2&lt;VM&gt; {
    type VM = VM;
    type PlanType = MyGC&lt;VM&gt;;
    type ProcessEdgesWorkType = PlanProcessEdges&lt;Self::VM, MyGC&lt;VM&gt;, DEFAULT_TRACE&gt;;
}

use crate::util::ObjectReference;
use crate::util::copy::CopySemantics;
use crate::MMTK;
use crate::policy::space::Space;

pub struct MyGCProcessEdges&lt;VM: VMBinding&gt; {
    plan: &amp;'static MyGC&lt;VM&gt;,
    base: ProcessEdgesBase&lt;VM&gt;,
}

impl&lt;VM:VMBinding&gt; ProcessEdgesWork for MyGCProcessEdges&lt;VM&gt; {
    type VM = VM;
    type ScanObjectsWorkType = ScanObjects&lt;Self&gt;;

    fn new(edges: Vec&lt;EdgeOf&lt;Self&gt;&gt;, roots: bool, mmtk: &amp;'static MMTK&lt;VM&gt;) -&gt; Self {
        let base = ProcessEdgesBase::new(edges, roots, mmtk);
        let plan = base.plan().downcast_ref::&lt;MyGC&lt;VM&gt;&gt;().unwrap();
        Self { base, plan }
    }

    fn trace_object(&amp;mut self, object: ObjectReference) -&gt; ObjectReference {
        if object.is_null() {
            return object;
        }
        let worker = self.worker();
        let queue = &amp;mut self.base.nodes;
        if self.plan.tospace().in_space(object) {
            self.plan.tospace().trace_object(
                queue,
                object,
                Some(CopySemantics::DefaultCopy),
                worker,
            )
        } else if self.plan.fromspace().in_space(object) {
            self.plan.fromspace().trace_object(
                queue,
                object,
                Some(CopySemantics::DefaultCopy),
                worker,
            )
        } else {
            self.plan.common.trace_object(queue, object, worker)
        }
    }

    fn create_scan_work(&amp;self, nodes: Vec&lt;ObjectReference&gt;, roots: bool) -&gt; ScanObjects&lt;Self&gt; {
        ScanObjects::&lt;Self&gt;::new(nodes, false, roots)
    }
}

impl&lt;VM: VMBinding&gt; Deref for MyGCProcessEdges&lt;VM&gt; {
    type Target = ProcessEdgesBase&lt;VM&gt;;
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.base
    }
}

impl&lt;VM: VMBinding&gt; DerefMut for MyGCProcessEdges&lt;VM&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.base
    }
}

pub struct MyGCWorkContext3&lt;VM: VMBinding&gt;(std::marker::PhantomData&lt;VM&gt;);
impl&lt;VM: VMBinding&gt; crate::scheduler::GCWorkContext for MyGCWorkContext3&lt;VM&gt; {
    type VM = VM;
    type PlanType = MyGC&lt;VM&gt;;
    type ProcessEdgesWorkType = MyGCProcessEdges&lt;Self::VM&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-3-implement-your-own-processedgeswork"><a class="header" href="#approach-3-implement-your-own-processedgeswork">Approach 3: Implement your own <code>ProcessEdgesWork</code></a></h3>
<p>Apart from the two approaches above, you can always implement your own <code>ProcessEdgesWork</code>. This is
an overkill for simple plans like semi space, but might be necessary for more complex plans.
We discuss how to implement it for <code>MyGC</code>.</p>
<p>Create a struct <code>MyGCProcessEdges&lt;VM: VMBinding&gt;</code> in the <code>gc_work</code> module. It includes a reference
back to the plan, and a <code>ProcessEdgesBase</code> field:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCProcessEdges&lt;VM: VMBinding&gt; {
    plan: &amp;'static MyGC&lt;VM&gt;,
    base: ProcessEdgesBase&lt;VM&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Implement <code>ProcessEdgesWork</code> for <code>MyGCProcessEdges</code>. As most methods in the trait have a default
implemetation, we only need to implement <code>new()</code> and <code>trace_object()</code> for our plan. However, this
may not be true when you implement it for other GC plans. It would be better to check the default
implementation of <code>ProcessEdgesWork</code>.</p>
<p>For <code>trace_object()</code>, what we do is similar to the approach above (except that we need to write the code
ourselves rather than letting the macro to generate it for us). We try to figure out
which space the object is in, and invoke <code>trace_object()</code> for the object on that space. If the
object is not in any of the semi spaces in the plan, we forward the call to <code>CommonPlan</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM:VMBinding&gt; ProcessEdgesWork for MyGCProcessEdges&lt;VM&gt; {
    type VM = VM;
    type ScanObjectsWorkType = ScanObjects&lt;Self&gt;;

    fn new(edges: Vec&lt;EdgeOf&lt;Self&gt;&gt;, roots: bool, mmtk: &amp;'static MMTK&lt;VM&gt;) -&gt; Self {
        let base = ProcessEdgesBase::new(edges, roots, mmtk);
        let plan = base.plan().downcast_ref::&lt;MyGC&lt;VM&gt;&gt;().unwrap();
        Self { base, plan }
    }

    fn trace_object(&amp;mut self, object: ObjectReference) -&gt; ObjectReference {
        if object.is_null() {
            return object;
        }
        let worker = self.worker();
        let queue = &amp;mut self.base.nodes;
        if self.plan.tospace().in_space(object) {
            self.plan.tospace().trace_object(
                queue,
                object,
                Some(CopySemantics::DefaultCopy),
                worker,
            )
        } else if self.plan.fromspace().in_space(object) {
            self.plan.fromspace().trace_object(
                queue,
                object,
                Some(CopySemantics::DefaultCopy),
                worker,
            )
        } else {
            self.plan.common.trace_object(queue, object, worker)
        }
    }

    fn create_scan_work(&amp;self, nodes: Vec&lt;ObjectReference&gt;, roots: bool) -&gt; ScanObjects&lt;Self&gt; {
        ScanObjects::&lt;Self&gt;::new(nodes, false, roots)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We would also need to implement <code>Deref</code> and <code>DerefMut</code> to our <code>ProcessEdgesWork</code> impl to be
dereferenced as <code>ProcessEdgesBase</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM: VMBinding&gt; Deref for MyGCProcessEdges&lt;VM&gt; {
    type Target = ProcessEdgesBase&lt;VM&gt;;
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.base
    }
}

impl&lt;VM: VMBinding&gt; DerefMut for MyGCProcessEdges&lt;VM&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.base
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the end, use <code>MyGCProcessEdges</code> as <code>ProcessEdgesWorkType</code> in the <code>GCWorkContext</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCWorkContext3&lt;VM: VMBinding&gt;(std::marker::PhantomData&lt;VM&gt;);
impl&lt;VM: VMBinding&gt; crate::scheduler::GCWorkContext for MyGCWorkContext3&lt;VM&gt; {
    type VM = VM;
    type PlanType = MyGC&lt;VM&gt;;
    type ProcessEdgesWorkType = MyGCProcessEdges&lt;Self::VM&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>You should now have MyGC working and able to collect garbage. All three
benchmarks should be able to pass now. </p>
<p>If the benchmarks pass - good job! You have built a functional copying
collector!</p>
<p>If you get particularly stuck, the code for the completed <code>MyGC</code> plan
is available <a href="https://github.com/mmtk/mmtk-core/tree/master/docs/tutorial/code/mygc_semispace">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-adding-another-copyspace"><a class="header" href="#exercise-adding-another-copyspace">Exercise: Adding another copyspace</a></h1>
<p>Now that you have a working semispace collector, you should be familiar 
enough with the code to start writing some yourself. The intention of this 
exercise is to reinforce the information from the semispace section, rather 
than to create a useful new collector.</p>
<ol>
<li>Create a copy of your semispace collector, called <code>triplespace</code>. </li>
<li>Add a new copyspace to the collector, called the <code>youngspace</code>, with the 
following traits:
<ul>
<li>New objects are allocated to the youngspace (rather than the fromspace).</li>
<li>During a collection, live objects in the youngspace are moved to the 
tospace.</li>
<li>Garbage is still collected at the same time for all spaces.</li>
</ul>
</li>
</ol>
<p>Triplespace is a sort of generational garbage collector. These collectors 
separate out old objects and new objects into separate spaces. Newly 
allocated objects should be scanned far more often than old objects, which 
minimises the time spent repeatedly re-scanning long-lived objects. </p>
<p>Of course, this means that the Triplespace is incredibly inefficient for a 
generational collector, because the older objects are still being scanned 
every collection. It wouldn't be very useful in a real-life scenario. The 
next thing to do is to make this collector into a more efficient proper 
generational collector.</p>
<p>When you are finished, try running the benchmarks and seeing how the 
performance of this collector compares to MyGC. Great work!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="triplespace-backup-instructions"><a class="header" href="#triplespace-backup-instructions">Triplespace backup instructions</a></h1>
<p>This is <em>one</em> possible implementation of the Triplespace collector, provided
in case you are stuck on the exercise.</p>
<p><strong>Attempt the exercise yourself before reading this.</strong></p>
<p>First, rename all instances of <code>mygc</code> to <code>triplespace</code>, and add it as a
module by following the instructions in <a href="mygc/ss/./create.html">Create MyGC</a>.</p>
<p>In <code>triplespace/global.rs</code>:</p>
<ol>
<li>
<p>Add a <code>youngspace</code> field to <code>pub struct TripleSpace</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TripleSpace&lt;VM: VMBinding&gt; {
   pub hi: AtomicBool,
   pub copyspace0: CopySpace&lt;VM&gt;,
   pub copyspace1: CopySpace&lt;VM&gt;,
   pub youngspace: CopySpace&lt;VM&gt;, // Add this!
   pub common: CommonPlan&lt;VM&gt;,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Define the parameters for the youngspace in <code>new()</code> in
<code>Plan for TripleSpace</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(
   vm_map: &amp;'static VMMap,
   mmapper: &amp;'static Mmapper,
   options: Arc&lt;UnsafeOptionsWrapper&gt;,
   _scheduler: &amp;'static MMTkScheduler&lt;Self::VM&gt;,
) -&gt; Self {
   //change - again, completely changed.
   let mut heap = HeapMeta::new(HEAP_START, HEAP_END);

   TripleSpace {
       hi: AtomicBool::new(false),
       copyspace0: CopySpace::new(
           &quot;copyspace0&quot;,
           false,
           true,
           VMRequest::discontiguous(),
           vm_map,
           mmapper,
           &amp;mut heap,
       ),
       copyspace1: CopySpace::new(
           &quot;copyspace1&quot;,
           true,
           true,
           VMRequest::discontiguous(),
           vm_map,
           mmapper,
           &amp;mut heap,
       ),

       // Add this!
       youngspace: CopySpace::new(
           &quot;youngspace&quot;,
           true,
           true,
           VMRequest::discontiguous(),
           vm_map,
           mmapper,
           &amp;mut heap,
       ),
       common: CommonPlan::new(vm_map, mmapper, options, heap, &amp;TRIPLESPACE_CONSTRAINTS, &amp;[]),
   }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Initialise the youngspace in <code>gc_init()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn gc_init(
    &amp;mut self,
    heap_size: usize,
    vm_map: &amp;'static VMMap,
    scheduler: &amp;Arc&lt;MMTkScheduler&lt;VM&gt;&gt;,
) {
    self.common.gc_init(heap_size, vm_map, scheduler);
    self.copyspace0.init(&amp;vm_map);
    self.copyspace1.init(&amp;vm_map);
    self.youngspace.init(&amp;vm_map); // Add this!
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Prepare the youngspace (as a fromspace) in <code>prepare()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prepare(&amp;self, tls: OpaquePointer) {
   self.common.prepare(tls, true);
   self.hi
       .store(!self.hi.load(Ordering::SeqCst), Ordering::SeqCst);
   let hi = self.hi.load(Ordering::SeqCst);
   self.copyspace0.prepare(hi);
   self.copyspace1.prepare(!hi);
   self.youngspace.prepare(true); // Add this!
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Release the youngspace in <code>release()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn release(&amp;self, tls: OpaquePointer) {
   self.common.release(tls, true);
   self.fromspace().release();
   self.youngspace().release(); // Add this!
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Under the reference functions <code>tospace()</code> and <code>fromspace()</code>, add a similar
reference function <code>youngspace()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn youngspace(&amp;self) -&gt; &amp;CopySpace&lt;VM&gt; {
   &amp;self.youngspace
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<p>In <code>mutator.rs</code>:</p>
<ol>
<li>Map a bump pointer to the youngspace (replacing the one mapped to the
tospace) in <code>space_mapping</code> in <code>create_triplespace_mutator()</code>:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>space_mapping: box vec![
    (AllocatorSelector::BumpPointer(0), plan.youngspace()), // Change this!
    (
        AllocatorSelector::BumpPointer(1),
        plan.common.get_immortal(),
    ),
    (AllocatorSelector::LargeObject(0), plan.common.get_los()),
],
<span class="boring">}</span></code></pre></pre>
</li>
<li>Rebind the bump pointer to youngspace (rather than the tospace) in
<code>triplespace_mutator_release()</code>:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn triplespace_mutator_release&lt;VM: VMBinding&gt; (
    mutator: &amp;mut Mutator&lt;VM&gt;,
    _tls: OpaquePointer
) {
    let bump_allocator = unsafe {
        mutator
            .allocators
            . get_allocator_mut(
                mutator.config.allocator_mapping[AllocationType::Default]
            )
        }
        .downcast_mut::&lt;BumpAllocator&lt;VM&gt;&gt;()
        .unwrap();
        bump_allocator.rebind(Some(mutator.plan.youngspace())); // Change this!
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<p>In <code>gc_work.rs</code>:</p>
<ol>
<li>Add the youngspace to trace_object, following the same format as
the tospace and fromspace:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn trace_object(&amp;mut self, object: ObjectReference) -&gt; ObjectReference {
        if object.is_null() {
            return object;
        }

        // Add this!
        else if self.plan().youngspace().in_space(object) {
            self.plan().youngspace.trace_object::&lt;Self, TripleSpaceCopyContext&lt;VM&gt;&gt;(
                self,
                object,
                super::global::ALLOC_TripleSpace,
                unsafe { self.worker().local::&lt;TripleSpaceCopyContext&lt;VM&gt;&gt;() },
            )
        }

        else if self.plan().tospace().in_space(object) {
            self.plan().tospace().trace_object::&lt;Self, TripleSpaceCopyContext&lt;VM&gt;&gt;(
                self,
                object,
                super::global::ALLOC_TripleSpace,
                unsafe { self.worker().local::&lt;MyGCCopyContext&lt;VM&gt;&gt;() },
            )
        } else if self.plan().fromspace().in_space(object) {
            self.plan().fromspace().trace_object::&lt;Self, MyGCCopyContext&lt;VM&gt;&gt;(
                self,
                object,
                super::global::ALLOC_TripleSpace,
                unsafe { self.worker().local::&lt;TripleSpaceCopyContext&lt;VM&gt;&gt;() },
            )
        } else {
            self.plan().common.trace_object::&lt;Self, TripleSpaceCopyContext&lt;VM&gt;&gt;(self, object)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-generational-copying-collector"><a class="header" href="#building-a-generational-copying-collector">Building a generational copying collector</a></h1>
<blockquote>
<p>Note: This part is work in progress.</p>
</blockquote>
<h2 id="what-is-a-generational-collector"><a class="header" href="#what-is-a-generational-collector">What is a generational collector?</a></h2>
<p>The <em>weak generational hypothesis</em> states that most of the objects allocated
to a heap after one collection will die before the next collection.
Therefore, it is worth separating out 'young' and 'old' objects and only
scanning each as needed, to minimise the number of times old live objects are
scanned. New objects are allocated to a 'nursery', and after one collection
they move to the 'mature' space. In <code>triplespace</code>, <code>youngspace</code> is a
proto-nursery, and the <code>tospace</code> and <code>fromspace</code> are the mature spaces.</p>
<p>This collector fixes one of the major problems with semispace - namely, that
any long-lived objects are repeatedly copied back and forth. By separating
these objects into a separate 'mature' space, the number of full heap
collections needed is greatly reduced.</p>
<p>This section is currently incomplete. Instructions for building a
generational copying (gencopy) collector will be added in future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h1>
<ul>
<li><a href="https://www.mmtk.io/mmtk-core/mmtk/index.html">MMTk Crate Documentation</a></li>
<li>Original MMTk papers:
<ul>
<li><a href="https://www.mmtk.io/assets/pubs/mmtk-icse-2004.pdf"><em>Oil and Water? High Performance Garbage Collection in Java with MMTk</em></a> (Blackburn, Cheng, McKinley, 2004)</li>
<li><a href="https://www.mmtk.io/assets/pubs/mmtk-sigmetrics-2004.pdf"><em>Myths and realities: The performance impact of garbage collection</em></a> (Blackburn, Cheng, McKinley, 2004)</li>
</ul>
</li>
<li><a href="https://learning.oreilly.com/library/view/the-garbage-collection/9781315388007"><em>The Garbage Collection Handbook</em></a> (Jones, Hosking, Moss, 2016)</li>
<li>Videos: <a href="https://www.youtube.com/watch?v=3L6XEVaYAmU">MPLR 2020 Keynote</a>, <a href="https://www.youtube.com/watch?v=MAk6RdApGLs">Deconstructing the Garbage-First Collector</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
