<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-specific methods for garbage collection."><meta name="keywords" content="rust, rustlang, rust-lang, Collection"><title>Collection in mmtk::vm::collection - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../mmtk/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo.png' alt='logo'></div></a><h2 class="location">Trait Collection</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#associated-const">Associated Constants</a></h3><div class="sidebar-links"><a href="#associatedconstant.COORDINATOR_ONLY_STW">COORDINATOR_ONLY_STW</a></div><h3 class="sidebar-title"><a href="#required-methods">Required Methods</a></h3><div class="sidebar-links"><a href="#tymethod.block_for_gc">block_for_gc</a><a href="#tymethod.prepare_mutator">prepare_mutator</a><a href="#tymethod.resume_mutators">resume_mutators</a><a href="#tymethod.spawn_worker_thread">spawn_worker_thread</a><a href="#tymethod.stop_all_mutators">stop_all_mutators</a></div><h3 class="sidebar-title"><a href="#provided-methods">Provided Methods</a></h3><div class="sidebar-links"><a href="#method.out_of_memory">out_of_memory</a><a href="#method.process_weak_refs">process_weak_refs</a><a href="#method.schedule_finalization">schedule_finalization</a><a href="#method.vm_release">vm_release</a></div><h3 class="sidebar-title"><a href="#implementors">Implementors</a></h3></div><h2 class="location">Other items in<br><a href="../../index.html">mmtk</a>::<wbr><a href="../index.html">vm</a>::<wbr><a href="index.html">collection</a></h2><div id="sidebar-vars" data-name="Collection" data-ty="trait" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Trait <a href="../../index.html">mmtk</a>::<wbr><a href="../index.html">vm</a>::<wbr><a href="index.html">collection</a>::<wbr><a class="trait" href="#">Collection</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#8-86" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust trait"><code>pub trait Collection&lt;VM:&nbsp;<a class="trait" href="../trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    const <a href="#associatedconstant.COORDINATOR_ONLY_STW" class="constant">COORDINATOR_ONLY_STW</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>;

    fn <a href="#tymethod.stop_all_mutators" class="fnname">stop_all_mutators</a>&lt;E:&nbsp;<a class="trait" href="../../scheduler/gc_work/trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::gc_work::ProcessEdgesWork">ProcessEdgesWork</a>&lt;VM = VM&gt;&gt;(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>);
<div class="item-spacer"></div>    fn <a href="#tymethod.resume_mutators" class="fnname">resume_mutators</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>);
<div class="item-spacer"></div>    fn <a href="#tymethod.block_for_gc" class="fnname">block_for_gc</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>);
<div class="item-spacer"></div>    fn <a href="#tymethod.spawn_worker_thread" class="fnname">spawn_worker_thread</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, ctx: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;&gt;);
<div class="item-spacer"></div>    fn <a href="#tymethod.prepare_mutator" class="fnname">prepare_mutator</a>&lt;T:&nbsp;<a class="trait" href="../../plan/mutator_context/trait.MutatorContext.html" title="trait mmtk::plan::mutator_context::MutatorContext">MutatorContext</a>&lt;VM&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls_worker: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls_mutator: <a class="struct" href="../../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T<br>&nbsp;&nbsp;&nbsp;&nbsp;);

    fn <a href="#method.out_of_memory" class="fnname">out_of_memory</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>) { ... }
<div class="item-spacer"></div>    fn <a href="#method.schedule_finalization" class="fnname">schedule_finalization</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>) { ... }
<div class="item-spacer"></div>    fn <a href="#method.vm_release" class="fnname">vm_release</a>() { ... }
<div class="item-spacer"></div>    fn <a href="#method.process_weak_refs" class="fnname">process_weak_refs</a>&lt;E:&nbsp;<a class="trait" href="../../scheduler/gc_work/trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::gc_work::ProcessEdgesWork">ProcessEdgesWork</a>&lt;VM = VM&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
}</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-specific methods for garbage collection.</p>
</div></details><h2 id="associated-const" class="small-section-header">Associated Constants<a href="#associated-const" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open><summary><div id="associatedconstant.COORDINATOR_ONLY_STW" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#16" title="goto source code">[src]</a></div><h4 class="code-header">const <a href="#associatedconstant.COORDINATOR_ONLY_STW" class="constant">COORDINATOR_ONLY_STW</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>If true, only the coordinator thread can call stop_all_mutators and the resume_mutators methods.
If false, any GC thread can call these methods.</p>
<p>This constant exists because some VMs require the thread that resumes a thread to be the same thread that
stopped it.  The MMTk Core will use the appropriate thread to stop or start the world according to the value of
this constant.  If a VM does not have such a requirement, the VM binding shall set this to false to reduce an
unnecessary context switch.</p>
</div></details></div><h2 id="required-methods" class="small-section-header">Required methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open><summary><div id="tymethod.stop_all_mutators" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#25" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.stop_all_mutators" class="fnname">stop_all_mutators</a>&lt;E:&nbsp;<a class="trait" href="../../scheduler/gc_work/trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::gc_work::ProcessEdgesWork">ProcessEdgesWork</a>&lt;VM = VM&gt;&gt;(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></div></summary><div class="docblock"><p>Stop all the mutator threads. MMTk calls this method when it requires all the mutator to yield for a GC.
This method is called by a single thread in MMTk (the GC controller).
This method should not return until all the threads are yielded.
The actual thread synchronization mechanism is up to the VM, and MMTk does not make assumptions on that.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC controller/coordinator.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.resume_mutators" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#31" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.resume_mutators" class="fnname">resume_mutators</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></div></summary><div class="docblock"><p>Resume all the mutator threads, the opposite of the above. When a GC is finished, MMTk calls this method.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC controller/coordinator.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.block_for_gc" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#40" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.block_for_gc" class="fnname">block_for_gc</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>)</h4></div></summary><div class="docblock"><p>Block the current thread for GC. This is called when an allocation request cannot be fulfilled and a GC
is needed. MMTk calls this method to inform the VM that the current thread needs to be blocked as a GC
is going to happen. Then MMTk starts a GC. For a stop-the-world GC, MMTk will then call <code>stop_all_mutators()</code>
before the GC, and call <code>resume_mutators()</code> after the GC.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The current thread pointer that should be blocked. The VM can optionally check if the current thread matches <code>tls</code>.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.spawn_worker_thread" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#52" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.spawn_worker_thread" class="fnname">spawn_worker_thread</a>(tls: <a class="struct" href="../../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, ctx: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;&gt;)</h4></div></summary><div class="docblock"><p>Ask the VM to spawn a GC thread for MMTk. A GC thread may later call into the VM through these VM traits. Some VMs
have assumptions that those calls needs to be within VM internal threads.
As a result, MMTk does not spawn GC threads itself to avoid breaking this kind of assumptions.
MMTk calls this method to spawn GC threads during <a href="../memory_manager/fn.initialize_collection.html"><code>initialize_collection()</code></a>.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the parent thread that we spawn new threads from. This is the same <code>tls</code> when the VM
calls <code>initialize_collection()</code> and passes as an argument.</li>
<li><code>ctx</code>: The GC worker context for the GC thread. If <code>None</code> is passed, it means spawning a GC thread for the GC controller,
which does not have a worker context.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.prepare_mutator" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#60-64" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.prepare_mutator" class="fnname">prepare_mutator</a>&lt;T:&nbsp;<a class="trait" href="../../plan/mutator_context/trait.MutatorContext.html" title="trait mmtk::plan::mutator_context::MutatorContext">MutatorContext</a>&lt;VM&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;tls_worker: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;tls_mutator: <a class="struct" href="../../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;m: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T<br>)</h4></div></summary><div class="docblock"><p>Allow VM-specific behaviors for a mutator after all the mutators are stopped and before any actual GC work starts.</p>
<p>Arguments:</p>
<ul>
<li><code>tls_worker</code>: The thread pointer for the worker thread performing this call.</li>
<li><code>tls_mutator</code>: The thread pointer for the target mutator thread.</li>
<li><code>m</code>: The mutator context for the thread.</li>
</ul>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided methods<a href="#provided-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open><summary><div id="method.out_of_memory" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#71-73" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.out_of_memory" class="fnname">out_of_memory</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>)</h4></div></summary><div class="docblock"><p>Inform the VM for an out-of-memory error. The VM can implement its own error routine for OOM.
Note the VM needs to fail in this call. We do not expect the VM to resume in any way.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the mutator which failed the allocation and triggered the OOM.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.schedule_finalization" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#79" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.schedule_finalization" class="fnname">schedule_finalization</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></div></summary><div class="docblock"><p>Inform the VM to schedule finalization threads.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the current GC thread.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.vm_release" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#82" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.vm_release" class="fnname">vm_release</a>()</h4></div></summary><div class="docblock"><p>Inform the VM to do its VM-specific release work at the end of a GC.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.process_weak_refs" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/mmtk/vm/collection.rs.html#85" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.process_weak_refs" class="fnname">process_weak_refs</a>&lt;E:&nbsp;<a class="trait" href="../../scheduler/gc_work/trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::gc_work::ProcessEdgesWork">ProcessEdgesWork</a>&lt;VM = VM&gt;&gt;(_worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;)</h4></div></summary><div class="docblock"><p>Delegate to the VM binding for reference processing.</p>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div class="item-list" id="implementors-list"></div><script type="text/javascript" src="../../../implementors/mmtk/vm/collection/trait.Collection.js" async></script></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="mmtk" data-search-index-js="../../../search-index.js" data-search-js="../../../search.js"></div>
    <script src="../../../main.js"></script>
</body></html>