<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-specific methods for garbage collection."><meta name="keywords" content="rust, rustlang, rust-lang, Collection"><title>Collection in mmtk::vm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../../mmtk/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.png" alt="logo"></div>
        </a><h2 class="location">Trait Collection</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#associated-const">Associated Constants</a></h3><div class="sidebar-links"><a href="#associatedconstant.COORDINATOR_ONLY_STW">COORDINATOR_ONLY_STW</a></div><h3 class="sidebar-title"><a href="#required-methods">Required Methods</a></h3><div class="sidebar-links"><a href="#tymethod.block_for_gc">block_for_gc</a><a href="#tymethod.prepare_mutator">prepare_mutator</a><a href="#tymethod.resume_mutators">resume_mutators</a><a href="#tymethod.spawn_gc_thread">spawn_gc_thread</a><a href="#tymethod.stop_all_mutators">stop_all_mutators</a></div><h3 class="sidebar-title"><a href="#provided-methods">Provided Methods</a></h3><div class="sidebar-links"><a href="#method.out_of_memory">out_of_memory</a><a href="#method.post_forwarding">post_forwarding</a><a href="#method.schedule_finalization">schedule_finalization</a></div><h3 class="sidebar-title"><a href="#implementors">Implementors</a></h3></div><h2 class="location">Other items in<br><a href="../index.html">mmtk</a>::<wbr><a href="index.html">vm</a></h2><div id="sidebar-vars" data-name="Collection" data-ty="trait" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../mmtk/index.html"><img class="rust-logo" src="../../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><h1 class="fqn"><span class="in-band">Trait <a href="../index.html">mmtk</a>::<wbr><a href="index.html">vm</a>::<wbr><a class="trait" href="#">Collection</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#14-123" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust trait"><code>pub trait Collection&lt;VM:&nbsp;<a class="trait" href="trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    const <a href="#associatedconstant.COORDINATOR_ONLY_STW" class="constant">COORDINATOR_ONLY_STW</a>: <a class="primitive" href="https://doc.rust-lang.org/1.59.0/std/primitive.bool.html">bool</a>;

    fn <a href="#tymethod.stop_all_mutators" class="fnname">stop_all_mutators</a>&lt;F&gt;(tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, mutator_visitor: F)<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.59.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;'static mut <a class="struct" href="../plan/struct.Mutator.html" title="struct mmtk::plan::Mutator">Mutator</a>&lt;VM&gt;)</span>;
<div class="item-spacer"></div>    fn <a href="#tymethod.resume_mutators" class="fnname">resume_mutators</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>);
<div class="item-spacer"></div>    fn <a href="#tymethod.block_for_gc" class="fnname">block_for_gc</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>);
<div class="item-spacer"></div>    fn <a href="#tymethod.spawn_gc_thread" class="fnname">spawn_gc_thread</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, ctx: <a class="enum" href="enum.GCThreadContext.html" title="enum mmtk::vm::GCThreadContext">GCThreadContext</a>&lt;VM&gt;);
<div class="item-spacer"></div>    fn <a href="#tymethod.prepare_mutator" class="fnname">prepare_mutator</a>&lt;T:&nbsp;<a class="trait" href="../plan/trait.MutatorContext.html" title="trait mmtk::plan::MutatorContext">MutatorContext</a>&lt;VM&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls_worker: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls_mutator: <a class="struct" href="../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m: <a class="primitive" href="https://doc.rust-lang.org/1.59.0/std/primitive.reference.html">&amp;</a>T<br>&nbsp;&nbsp;&nbsp;&nbsp;);

    fn <a href="#method.out_of_memory" class="fnname">out_of_memory</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, err_kind: <a class="enum" href="../util/alloc/enum.AllocationError.html" title="enum mmtk::util::alloc::AllocationError">AllocationError</a>) { ... }
<div class="item-spacer"></div>    fn <a href="#method.schedule_finalization" class="fnname">schedule_finalization</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>) { ... }
<div class="item-spacer"></div>    fn <a href="#method.post_forwarding" class="fnname">post_forwarding</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>) { ... }
}</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-specific methods for garbage collection.</p>
</div></details><h2 id="associated-const" class="small-section-header">Associated Constants<a href="#associated-const" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open><summary><div id="associatedconstant.COORDINATOR_ONLY_STW" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#22" title="goto source code">[src]</a></div><h4 class="code-header">const <a href="#associatedconstant.COORDINATOR_ONLY_STW" class="constant">COORDINATOR_ONLY_STW</a>: <a class="primitive" href="https://doc.rust-lang.org/1.59.0/std/primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>If true, only the coordinator thread can call stop_all_mutators and the resume_mutators methods.
If false, any GC thread can call these methods.</p>
<p>This constant exists because some VMs require the thread that resumes a thread to be the same thread that
stopped it.  The MMTk Core will use the appropriate thread to stop or start the world according to the value of
this constant.  If a VM does not have such a requirement, the VM binding shall set this to false to reduce an
unnecessary context switch.</p>
</div></details></div><h2 id="required-methods" class="small-section-header">Required methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open><summary><div id="tymethod.stop_all_mutators" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#31-33" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.stop_all_mutators" class="fnname">stop_all_mutators</a>&lt;F&gt;(tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, mutator_visitor: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.59.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;'static mut <a class="struct" href="../plan/struct.Mutator.html" title="struct mmtk::plan::Mutator">Mutator</a>&lt;VM&gt;),&nbsp;</span></h4></div></summary><div class="docblock"><p>Stop all the mutator threads. MMTk calls this method when it requires all the mutator to yield for a GC.
This method is called by a single thread in MMTk (the GC controller).
This method should not return until all the threads are yielded.
The actual thread synchronization mechanism is up to the VM, and MMTk does not make assumptions on that.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC controller/coordinator.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.resume_mutators" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#39" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.resume_mutators" class="fnname">resume_mutators</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></div></summary><div class="docblock"><p>Resume all the mutator threads, the opposite of the above. When a GC is finished, MMTk calls this method.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC controller/coordinator.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.block_for_gc" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#48" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.block_for_gc" class="fnname">block_for_gc</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>)</h4></div></summary><div class="docblock"><p>Block the current thread for GC. This is called when an allocation request cannot be fulfilled and a GC
is needed. MMTk calls this method to inform the VM that the current thread needs to be blocked as a GC
is going to happen. Then MMTk starts a GC. For a stop-the-world GC, MMTk will then call <code>stop_all_mutators()</code>
before the GC, and call <code>resume_mutators()</code> after the GC.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The current thread pointer that should be blocked. The VM can optionally check if the current thread matches <code>tls</code>.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.spawn_gc_thread" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#64" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.spawn_gc_thread" class="fnname">spawn_gc_thread</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, ctx: <a class="enum" href="enum.GCThreadContext.html" title="enum mmtk::vm::GCThreadContext">GCThreadContext</a>&lt;VM&gt;)</h4></div></summary><div class="docblock"><p>Ask the VM to spawn a GC thread for MMTk. A GC thread may later call into the VM through these VM traits. Some VMs
have assumptions that those calls needs to be within VM internal threads.
As a result, MMTk does not spawn GC threads itself to avoid breaking this kind of assumptions.
MMTk calls this method to spawn GC threads during <a href="../memory_manager/fn.initialize_collection.html"><code>initialize_collection()</code></a>.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the parent thread that we spawn new threads from. This is the same <code>tls</code> when the VM
calls <code>initialize_collection()</code> and passes as an argument.</li>
<li><code>ctx</code>: The context for the GC thread.
<ul>
<li>If <code>Controller</code> is passed, it means spawning a thread to run as the GC controller.
The spawned thread shall call <code>memory_manager::start_control_collector</code>.</li>
<li>If <code>Worker</code> is passed, it means spawning a thread to run as a GC worker.
The spawned thread shall call <code>memory_manager::start_worker</code>.
In either case, the <code>Box</code> inside should be passed back to the called function.</li>
</ul>
</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.prepare_mutator" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#72-76" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.prepare_mutator" class="fnname">prepare_mutator</a>&lt;T:&nbsp;<a class="trait" href="../plan/trait.MutatorContext.html" title="trait mmtk::plan::MutatorContext">MutatorContext</a>&lt;VM&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;tls_worker: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;tls_mutator: <a class="struct" href="../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;m: <a class="primitive" href="https://doc.rust-lang.org/1.59.0/std/primitive.reference.html">&amp;</a>T<br>)</h4></div></summary><div class="docblock"><p>Allow VM-specific behaviors for a mutator after all the mutators are stopped and before any actual GC work starts.</p>
<p>Arguments:</p>
<ul>
<li><code>tls_worker</code>: The thread pointer for the worker thread performing this call.</li>
<li><code>tls_mutator</code>: The thread pointer for the target mutator thread.</li>
<li><code>m</code>: The mutator context for the thread.</li>
</ul>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided methods<a href="#provided-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open><summary><div id="method.out_of_memory" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#91-93" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.out_of_memory" class="fnname">out_of_memory</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, err_kind: <a class="enum" href="../util/alloc/enum.AllocationError.html" title="enum mmtk::util::alloc::AllocationError">AllocationError</a>)</h4></div></summary><div class="docblock"><p>Inform the VM of an out-of-memory error. The binding should hook into the VM’s error
routine for OOM. Note that there are two different categories of OOM:</p>
<ul>
<li>Critical OOM: This is the case where the OS is unable to mmap or acquire more memory.
MMTk expects the VM to abort immediately if such an error is thrown.</li>
<li>Heap OOM: This is the case where the specified heap size is insufficient to execute the
application. MMTk expects the binding to notify the VM about this OOM. MMTk makes no
assumptions about whether the VM will continue executing or abort immediately.</li>
</ul>
<p>See <a href="../util/alloc/enum.AllocationError.html" title="AllocationError"><code>AllocationError</code></a> for more information.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the mutator which failed the allocation and triggered the OOM.</li>
<li><code>err_kind</code>: The type of OOM error that was encountered.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.schedule_finalization" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#99" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.schedule_finalization" class="fnname">schedule_finalization</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></div></summary><div class="docblock"><p>Inform the VM to schedule finalization threads.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the current GC thread.</li>
</ul>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.post_forwarding" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#122" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.post_forwarding" class="fnname">post_forwarding</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></div></summary><div class="docblock"><p>A hook for the VM to do work after forwarding objects.</p>
<p>This function is called after all of the following have finished:</p>
<ul>
<li>The life and death of objects are determined.  Objects determined to be live will not
be reclaimed in this GC.</li>
<li>Live objects have been moved to their destinations. (copying GC only)</li>
<li>References in objects have been updated to point to new addresses. (copying GC only)</li>
</ul>
<p>And this function may run concurrently with the release work of GC, i.e. freeing the space
occupied by dead objects.</p>
<p>It is safe for the VM to read and write object fields at this time, although GC has not
finished yet.  GC will be reclaiming spaces of dead objects, but will not damage live
objects.  However, the VM cannot allocate new objects at this time.</p>
<p>One possible use of this hook is enqueuing <code>{Soft,Weak,Phantom}Reference</code> instances to
reference queues (for Java).  VMs (including JVM implementations) do not have to handle
weak references this way, but mmtk-core provides this opportunity.</p>
<p>Arguments:</p>
<ul>
<li><code>tls_worker</code>: The thread pointer for the worker thread performing this call.</li>
</ul>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div class="item-list" id="implementors-list"></div><script type="text/javascript" src="../../implementors/mmtk/vm/trait.Collection.js" async></script></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="mmtk" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0 (9d1b2106e 2022-02-23)" ></div>
</body></html>