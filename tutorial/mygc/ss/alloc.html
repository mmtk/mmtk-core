<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Allocation - MMTk User Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="The guide describes the usage of MMTk for GC and language runtime developers.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../assets/css/api-migration-details.css">
        <link rel="stylesheet" href="../../../assets/css/mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MMTk User Guide</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/mmtk/mmtk-core/tree/master/docs/userguide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/mmtk/mmtk-core/edit/master/docs/userguide/src/tutorial/mygc/ss/alloc.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="allocation-add-copyspaces"><a class="header" href="#allocation-add-copyspaces">Allocation: Add copyspaces</a></h1>
<p>We will now change your MyGC plan from one that cannot collect garbage
into one that implements the semispace algorithm. The first step of this
is to add the two copyspaces, and allow collectors to allocate memory
into them. This involves adding two copyspaces, the code to properly initialise
and prepare the new spaces, and a copy context.</p>
<h2 id="change-the-plan-constraints"><a class="header" href="#change-the-plan-constraints">Change the plan constraints</a></h2>
<p>Firstly, change the plan constraints. Some of these constraints are not used
at the moment, but it's good to set them properly regardless.</p>
<p>Look in <code>plan/plan_constraints.rs</code>. <code>PlanConstraints</code> lists all the possible
options for plan-specific constraints. At the moment, <code>MYGC_CONSTRAINTS</code> in
<code>mygc/global.rs</code> should be using the default value for <code>PlanConstraints</code>.
We will make the following changes:</p>
<ol>
<li>Initialize <code>gc_header_bits</code> to 2. We reserve 2 bits in the header for GC use.</li>
<li>Initialize <code>moves_objects</code> to <code>true</code>.</li>
</ol>
<p>Finished code (step 1-3):</p>
<pre><code>pub const MYGC_CONSTRAINTS: PlanConstraints = PlanConstraints {
    moves_objects: true,
    ..PlanConstraints::default()
};
</code></pre>
<h2 id="change-the-plan-implementation"><a class="header" href="#change-the-plan-implementation">Change the plan implementation</a></h2>
<p>Next, in <code>mygc/global.rs</code>, replace the old immortal (nogc) space with two
copyspaces.</p>
<h3 id="imports"><a class="header" href="#imports">Imports</a></h3>
<p>To the import statement block:</p>
<ol>
<li>Replace <code>crate::plan::global::{BasePlan, NoCopy};</code> with
<code>use crate::plan::global::BasePlan;</code>. This collector is going to use
copying, so there's no point to importing NoCopy any more.</li>
<li>Add <code>use crate::plan::global::CommonPlan;</code>. Semispace uses the common
plan, which includes an immortal space and a large object space, rather
than the base plan. Any garbage collected plan should use <code>CommonPlan</code>.</li>
<li>Add <code>use std::sync::atomic::{AtomicBool, Ordering};</code>. These are going
to be used to store an indicator of which copyspace is the tospace.</li>
<li>Delete <code>#[allow(unused_imports)]</code>.</li>
</ol>
<p>Finished code (step 1):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::plan::global::BasePlan; //Modify
use crate::plan::global::CommonPlan; // Add
use crate::plan::global::{CreateGeneralPlanArgs, CreateSpecificPlanArgs};
use crate::plan::mygc::mutator::ALLOCATOR_MAPPING;
use crate::plan::mygc::gc_work::MyGCWorkContext;
use crate::plan::AllocationSemantics;
use crate::plan::Plan;
use crate::plan::PlanConstraints;
use crate::policy::copyspace::CopySpace; // Add
use crate::policy::space::Space;
use crate::scheduler::*; // Modify
use crate::util::alloc::allocators::AllocatorSelector;
use crate::util::copy::*;
use crate::util::heap::VMRequest;
use crate::util::heap::gc_trigger::SpaceStats;
use crate::util::metadata::side_metadata::SideMetadataContext;
use crate::util::opaque_pointer::*;
use crate::vm::VMBinding;
use enum_map::EnumMap;
use std::sync::atomic::{AtomicBool, Ordering}; // Add
<span class="boring">}</span></code></pre></pre>
<h3 id="struct-mygc"><a class="header" href="#struct-mygc">Struct MyGC</a></h3>
<p>Change <code>pub struct MyGC&lt;VM: VMBinding&gt;</code> to add new instance variables.</p>
<ol>
<li>Delete the existing fields in the constructor.</li>
<li>Add <code>pub hi: AtomicBool,</code>. This is a thread-safe bool, indicating which
copyspace is the tospace.</li>
<li>Add <code>pub copyspace0: CopySpace&lt;VM&gt;,</code>
and <code>pub copyspace1: CopySpace&lt;VM&gt;,</code>. These are the two copyspaces.</li>
<li>Add <code>pub common: CommonPlan&lt;VM&gt;,</code>.
This holds an instance of the common plan.</li>
</ol>
<p>Finished code (step 2):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(HasSpaces, PlanTraceObject)]
pub struct MyGC&lt;VM: VMBinding&gt; {
    pub hi: AtomicBool,
    #[space]
    #[copy_semantics(CopySemantics::DefaultCopy)]
    pub copyspace0: CopySpace&lt;VM&gt;,
    #[space]
    #[copy_semantics(CopySemantics::DefaultCopy)]
    pub copyspace1: CopySpace&lt;VM&gt;,
    #[parent]
    pub common: CommonPlan&lt;VM&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that <code>MyGC</code> now also derives <code>PlanTraceObject</code> besides <code>HasSpaces</code>, and we
have attributes on some fields. These attributes tell MMTk's macros how to
generate code to visit each space of this plan as well as trace objects in this
plan.  Although there are other approaches that you can implement object
tracing, in this tutorial we use the macros, as it is the simplest.  Make sure
you import the macros. We will discuss on what those attributes mean in later
sections.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mmtk_macros::{HasSpaces, PlanTraceObject};
<span class="boring">}</span></code></pre></pre>
<h3 id="implement-the-plan-trait-for-mygc"><a class="header" href="#implement-the-plan-trait-for-mygc">Implement the Plan trait for MyGC</a></h3>
<h4 id="constructor"><a class="header" href="#constructor">Constructor</a></h4>
<p>Change <code>fn new()</code>. This section initialises and prepares the objects in MyGC
that you just defined.</p>
<ol>
<li>Delete the definition of <code>mygc_space</code>.
Instead, we will define the two copyspaces here.</li>
<li>Define one of the copyspaces by adding the following code:</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            copyspace0: CopySpace::new(plan_args.get_space_args("copyspace0", true, false, VMRequest::discontiguous()), false),
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>Create another copyspace, called <code>copyspace1</code>, defining it as a fromspace
instead of a tospace. (Hint: the definitions for
copyspaces are in <code>src/policy/copyspace.rs</code>.)</li>
<li>Finally, replace the old MyGC initializer.</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new(args: CreateGeneralPlanArgs&lt;VM&gt;) -&gt; Self {
        // Modify
        let mut plan_args = CreateSpecificPlanArgs {
            global_args: args,
            constraints: &amp;MYGC_CONSTRAINTS,
            global_side_metadata_specs: SideMetadataContext::new_global_specs(&amp;[]),
        };

        let res = MyGC {
            hi: AtomicBool::new(false),
            copyspace0: CopySpace::new(plan_args.get_space_args("copyspace0", true, false, VMRequest::discontiguous()), false),
            copyspace1: CopySpace::new(plan_args.get_space_args("copyspace1", true, false, VMRequest::discontiguous()), true),
            common: CommonPlan::new(plan_args),
        };

        res.verify_side_metadata_sanity();

        res
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="access-mygc-spaces"><a class="header" href="#access-mygc-spaces">Access MyGC spaces</a></h3>
<p>Add a new section of methods for MyGC:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM: VMBinding&gt; MyGC&lt;VM&gt; {
}
<span class="boring">}</span></code></pre></pre>
<p>To this, add two helper methods, <code>tospace(&amp;self)</code>
and <code>fromspace(&amp;self)</code>. They both have return type <code>&amp;CopySpace&lt;VM&gt;</code>,
and return a reference to the tospace and fromspace respectively.
<code>tospace()</code> (see below) returns a reference to the tospace,
and <code>fromspace()</code> returns a reference to the fromspace.</p>
<p>We also add another two helper methods to get <code>tospace_mut(&amp;mut self)</code>
and <code>fromspace_mut(&amp;mut self)</code>. Those will be used later when we implement
collection for our GC plan.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn tospace(&amp;self) -&gt; &amp;CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;self.copyspace1
        } else {
            &amp;self.copyspace0
        }
    }

    pub fn fromspace(&amp;self) -&gt; &amp;CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;self.copyspace0
        } else {
            &amp;self.copyspace1
        }
    }

    pub fn tospace_mut(&amp;mut self) -&gt; &amp;mut CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;mut self.copyspace1
        } else {
            &amp;mut self.copyspace0
        }
    }

    pub fn fromspace_mut(&amp;mut self) -&gt; &amp;mut CopySpace&lt;VM&gt; {
        if self.hi.load(Ordering::SeqCst) {
            &amp;mut self.copyspace0
        } else {
            &amp;mut self.copyspace1
        }
    }
<span class="boring">}</span></code></pre></pre>
<h4 id="other-methods-in-the-plan-trait"><a class="header" href="#other-methods-in-the-plan-trait">Other methods in the Plan trait</a></h4>
<p>The trait <code>Plan</code> requires a <code>common()</code> method that should return a
reference to the common plan. Implement this method now.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn common(&amp;self) -&gt; &amp;CommonPlan&lt;VM&gt; {
        &amp;self.common
    }
<span class="boring">}</span></code></pre></pre>
<p>Find the helper method <code>base</code> and change it so that it calls the
base plan <em>through</em> the common plan.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn base(&amp;self) -&gt; &amp;BasePlan&lt;VM&gt; {
        &amp;self.common.base
    }

    fn base_mut(&amp;mut self) -&gt; &amp;mut BasePlan&lt;Self::VM&gt; {
        &amp;mut self.common.base
    }
<span class="boring">}</span></code></pre></pre>
<p>The trait <code>Plan</code> requires <code>collection_required()</code> method to know when
we should trigger a collection. We can just use the implementation
in the <code>BasePlan</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn collection_required(&amp;self, space_full: bool, _space: Option&lt;SpaceStats&lt;Self::VM&gt;&gt;) -&gt; bool {
        self.base().collection_required(self, space_full)
    }
<span class="boring">}</span></code></pre></pre>
<p>Find the method <code>get_pages_used</code>. Replace the current body with
<code>self.tospace().reserved_pages() + self.common.get_pages_used()</code>, to
correctly count the pages contained in the tospace and the common plan
spaces (which will be explained later).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn get_used_pages(&amp;self) -&gt; usize {
        self.tospace().reserved_pages() + self.common.get_used_pages()
    }
<span class="boring">}</span></code></pre></pre>
<p>Add and override the following helper function:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn get_collection_reserved_pages(&amp;self) -&gt; usize {
        self.tospace().reserved_pages()
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="change-the-mutator-definition"><a class="header" href="#change-the-mutator-definition">Change the mutator definition</a></h2>
<p>Next, we need to change the mutator, in <code>mutator.rs</code>, to allocate to the
tospace, and to the two spaces controlled by the common plan.</p>
<h3 id="imports-1"><a class="header" href="#imports-1">Imports</a></h3>
<p>Change the following import statements:</p>
<ol>
<li>Add <code>use super::MyGC;</code>.</li>
<li>Add <code>use crate::util::alloc::BumpAllocator;</code>.</li>
<li>Delete <code>use crate::plan::mygc::MyGC;</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::MyGC; // Add
use crate::MMTK;
use crate::plan::barriers::NoBarrier;
use crate::plan::mutator_context::Mutator;
use crate::plan::mutator_context::MutatorConfig;
use crate::plan::AllocationSemantics;
use crate::util::alloc::allocators::{AllocatorSelector, Allocators};
use crate::util::alloc::BumpAllocator;
use crate::util::opaque_pointer::*;
use crate::vm::VMBinding;
use crate::plan::mutator_context::{
    create_allocator_mapping, create_space_mapping, ReservedAllocators,
};
use enum_map::EnumMap;
// Remove crate::plan::mygc::MyGC
// Remove mygc_mutator_noop
<span class="boring">}</span></code></pre></pre>
<h3 id="allocator-mapping"><a class="header" href="#allocator-mapping">Allocator mapping</a></h3>
<p>In <code>lazy_static!</code>, make the following changes to <code>ALLOCATOR_MAPPING</code>,
which maps the required allocation semantics to the corresponding allocators.
For example, for <code>Default</code>, we allocate using the first bump pointer allocator
(<code>BumpPointer(0)</code>):</p>
<ol>
<li>Define a <code>ReservedAllocators</code> instance to declare that we need one bump allocator.</li>
<li>Map the common plan allocators using <code>create_allocator_mapping</code>.</li>
<li>Map <code>Default</code> to <code>BumpPointer(0)</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RESERVED_ALLOCATORS: ReservedAllocators = ReservedAllocators {
    n_bump_pointer: 1,
    ..ReservedAllocators::DEFAULT
};

lazy_static! {
    pub static ref ALLOCATOR_MAPPING: EnumMap&lt;AllocationSemantics, AllocatorSelector&gt; = {
        let mut map = create_allocator_mapping(RESERVED_ALLOCATORS, true);
        map[AllocationSemantics::Default] = AllocatorSelector::BumpPointer(0);
        map
    };
}
<span class="boring">}</span></code></pre></pre>
<h3 id="space-mapping"><a class="header" href="#space-mapping">Space mapping</a></h3>
<p>Next, in <code>create_mygc_mutator</code>, change which allocator is allocated to what
space in <code>space_mapping</code>. Note that the space allocation is formatted as a list
of tuples. For example, the first bump pointer allocator (<code>BumpPointer(0)</code>) is
bound with <code>tospace</code>.</p>
<p>Downcast the dynamic <code>Plan</code> type to <code>MyGC</code> so we can access specific spaces in
<code>MyGC</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mygc = mmtk.get_plan().downcast_ref::&lt;MyGC&lt;VM&gt;&gt;().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Then, use <code>mygc</code> to access the spaces in <code>MyGC</code>.</p>
<ol>
<li><code>BumpPointer(0)</code> should map to the tospace.</li>
<li>Other common plan allocators should be mapped using <code>create_space_mapping</code>.</li>
<li>None of the above should be dereferenced (ie, they should not have
the <code>&amp;</code> prefix).</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        space_mapping: Box::new({
            let mut vec = create_space_mapping(RESERVED_ALLOCATORS, true, mygc);
            vec.push((AllocatorSelector::BumpPointer(0), mygc.tospace()));
            vec
        }),
<span class="boring">}</span></code></pre></pre>
<p>The <code>create_space_mapping</code> and <code>create_allocator_mapping</code> call that have appeared all
of a sudden in these past 2 steps, are parts of the MMTk common plan
itself. They are used to construct allocator-space mappings for the spaces defined
by the common plan:</p>
<ol>
<li>The immortal space is used for objects that the virtual machine or a
library never expects to die.</li>
<li>The large object space is needed because MMTk handles particularly large
objects differently to normal objects, as the space overhead of copying
large objects is very high. Instead, this space is used by a free list
allocator in the common plan to avoid having to copy them.</li>
<li>The read-only space is used to store all the immutable objects.</li>
<li>The code spaces are used for VM generated code objects.</li>
</ol>
<p>With this, you should have the allocation working, but not garbage collection.
Try building again. If you run HelloWorld or Fannkunchredux, they should
work. DaCapo's lusearch should fail, as it requires garbage to be collected.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../tutorial/mygc/ss/prefix.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../tutorial/mygc/ss/collection.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../tutorial/mygc/ss/prefix.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../tutorial/mygc/ss/collection.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../assets/js/api-migration-details.js"></script>


    </div>
    </body>
</html>
