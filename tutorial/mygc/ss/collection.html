<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Collection - MMTk User Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="The guide describes the usage of MMTk for GC and language runtime developers.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../assets/css/api-migration-details.css">
        <link rel="stylesheet" href="../../../assets/css/mdbook-admonish.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MMTk User Guide</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/mmtk/mmtk-core/tree/master/docs/userguide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/mmtk/mmtk-core/edit/master/docs/userguide/src/tutorial/mygc/ss/collection.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="collection-implement-garbage-collection"><a class="header" href="#collection-implement-garbage-collection">Collection: Implement garbage collection</a></h1>
<p>We need to add a few more things to get garbage collection working.
Specifically, we need to config the <code>GCWorkerCopyContext</code>, which a GC worker uses for
copying objects, and GC work packets that will be scheduled for a collection.</p>
<h2 id="copyconfig"><a class="header" href="#copyconfig">CopyConfig</a></h2>
<p><code>CopyConfig</code> defines how a GC plan copies objects.
Similar to the <code>MutatorConfig</code> struct, you would need to define <code>CopyConfig</code> for your plan.</p>
<p>In <code>impl&lt;VM: VMBinding&gt; Plan for MyGC&lt;VM&gt;</code>, override the method <code>create_copy_config()</code>.
The default implementation provides a default <code>CopyConfig</code> for non-copying plans. So for non-copying plans,
you do not need to override the method. But
for copying plans, you would have to provide a proper copy configuration.</p>
<p>In a semispace GC, objects will be copied between the two copy spaces. We will use one
<code>CopySpaceCopyContext</code> for the copying, and will rebind the copy context to the proper tospace
in the preparation step of a GC (which will be discussed later when we talk about preparing for collections).</p>
<p>We use <code>CopySemantics::DefaultCopy</code> for our copy
operation, and bind it with the first <code>CopySpaceCopyContext</code> (<code>CopySemantics::DefaultCopy =&gt; CopySelector::CopySpace(0)</code>).
Other copy semantics are unused in this plan. We also provide an initial space
binding for <code>CopySpaceCopyContext</code>. However, we will flip tospace in every GC, and rebind the
copy context to the new tospace in each GC, so it does not matter which space we use as the initial
space here.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn create_copy_config(&amp;'static self) -&gt; CopyConfig&lt;Self::VM&gt; {
        use enum_map::enum_map;
        CopyConfig {
            copy_mapping: enum_map! {
                CopySemantics::DefaultCopy =&gt; CopySelector::CopySpace(0),
                _ =&gt; CopySelector::Unused,
            },
            space_mapping: vec![
                // The tospace argument doesn't matter, we will rebind before a GC anyway.
                (CopySelector::CopySpace(0), &amp;self.copyspace0)
            ],
            constraints: &amp;MYGC_CONSTRAINTS,
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Because the semispace GC copies objects in every single GC, we modify the method
<code>current_gc_may_move_object()</code> in <code>MyGC</code> so that it always returns <code>true</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn current_gc_may_move_object(&amp;self) -&gt; bool {
        true
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="introduce-collection-to-mygc-plan"><a class="header" href="#introduce-collection-to-mygc-plan">Introduce collection to MyGC plan</a></h2>
<p>Add a new method to <code>Plan for MyGC</code>, <code>schedule_collection()</code>. This function
runs when a collection is triggered. It schedules GC work for the plan, i.e.,
it stops all mutators, runs the
scheduler's prepare stage and resumes the mutators. The <code>StopMutators</code> work
will invoke code from the bindings to scan threads and other roots, and those
scanning work will further push work for a transitive closure.</p>
<p>Though you can add those work packets by yourself, <code>GCWorkScheduler</code> provides a
method <code>schedule_common_work()</code> that will add common work packets for you.</p>
<p>To use <code>schedule_common_work()</code>, first we need to create a type <code>MyGCWorkContext</code>
and implement the trait <code>GCWorkContext</code> for it. We create <code>gc_work.rs</code> and add the
following implementation. Note that we will use the default
<a href="https://docs.mmtk.io/api/mmtk/scheduler/gc_work/struct.SFTProcessEdges.html"><code>SFTProcessEdges</code></a>,
which is a general work packet that a plan can use to trace objects. For plans
like semispace, <code>SFTProcessEdges</code> is sufficient. For more complex GC plans,
one can create and write their own work packet that implements the <code>ProcessEdgesWork</code> trait.
We will discuss about this later, and discuss the alternatives.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCWorkContext&lt;VM: VMBinding&gt;(std::marker::PhantomData&lt;VM&gt;);
impl&lt;VM: VMBinding&gt; crate::scheduler::GCWorkContext for MyGCWorkContext&lt;VM&gt; {
    type VM = VM;
    type PlanType = MyGC&lt;VM&gt;;
    type DefaultProcessEdges = SFTProcessEdges&lt;Self::VM&gt;;
    type PinningProcessEdges = UnsupportedProcessEdges&lt;Self::VM&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Then we implement <code>schedule_collection()</code> using <code>MyGCWorkContext</code> and <code>schedule_common_work()</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn schedule_collection(&amp;'static self, scheduler: &amp;GCWorkScheduler&lt;VM&gt;) {
        scheduler.schedule_common_work::&lt;MyGCWorkContext&lt;VM&gt;&gt;(self);
    }
<span class="boring">}</span></code></pre></pre>
<p>Delete <code>handle_user_collection_request()</code>. This function was an override of
a Common plan function to ignore user requested collection for NoGC. Now we
remove it and allow user requested collection.</p>
<h2 id="prepare-for-collection"><a class="header" href="#prepare-for-collection">Prepare for collection</a></h2>
<p>The collector has a number of steps it needs to perform before each collection.
We'll add these now.</p>
<h3 id="prepare-plan"><a class="header" href="#prepare-plan">Prepare plan</a></h3>
<p>In <code>mygc/global.rs</code>, find the method <code>prepare</code>. Delete the <code>unreachable!()</code>
call, and add the following code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn prepare(&amp;mut self, tls: VMWorkerThread) {
        self.common.prepare(tls, true);

        self.hi
            .store(!self.hi.load(Ordering::SeqCst), Ordering::SeqCst);
        // Flips 'hi' to flip space definitions
        let hi = self.hi.load(Ordering::SeqCst);
        self.copyspace0.prepare(hi);
        self.copyspace1.prepare(!hi);

        self.fromspace_mut()
            .set_copy_for_sft_trace(Some(CopySemantics::DefaultCopy));
        self.tospace_mut().set_copy_for_sft_trace(None);
    }
<span class="boring">}</span></code></pre></pre>
<p>This function is called at the start of a collection. It prepares the two
spaces in the common plan, flips the definitions for which space is 'to'
and which is 'from', then prepares the copyspaces with the new definition.</p>
<p>Note that we call <code>set_copy_for_sft_trace()</code> for both spaces. This step is required
when using <code>SFTProcessEdges</code> to tell the spaces which copy semantic to use for copying.
For fromspace, we use the <code>DefaultCopy</code> semantic, which we have defined earlier in our <code>CopyConfig</code>.
So for objects in fromspace that need to be copied, the policy will use the copy context that binds with
<code>DefaultCopy</code> (which allocates to the tospace) in the GC worker. For tospace, we set its
copy semantics to <code>None</code>, as we do not expect to copy objects from tospace, and if that ever happens,
we will simply panic.</p>
<h3 id="prepare-worker"><a class="header" href="#prepare-worker">Prepare worker</a></h3>
<p>As we flip tospace for the plan, we also need to rebind the copy context
to the new tospace. We will override <code>prepare_worker()</code> in our <code>Plan</code> implementation.
<code>Plan.prepare_worker()</code> is executed by each GC worker in the preparation phase of a GC. The code
is straightforward -- we get the first <code>CopySpaceCopyContext</code>, and call <code>rebind()</code> on it with
the new <code>tospace</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn prepare_worker(&amp;self, worker: &amp;mut GCWorker&lt;VM&gt;) {
        unsafe { worker.get_copy_context_mut().copy[0].assume_init_mut() }.rebind(self.tospace());
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="prepare-mutator"><a class="header" href="#prepare-mutator">Prepare mutator</a></h3>
<p>Going back to <code>mutator.rs</code>, create a new function called
<code>mygc_mutator_prepare&lt;VM: VMBinding&gt;(_mutator: &amp;mut Mutator&lt;VM&gt;, _tls: VMWorkerThread)</code>.
This function will be called at the preparation stage of a collection (at the start of a
collection) for each mutator. Its body can stay empty, as there aren't any preparation steps for
the mutator in this GC.  In <code>create_mygc_mutator()</code>, find the field <code>prepare_func</code> and change it
from <code>&amp;unreachable_prepare_func</code> to <code>&amp;mygc_mutator_prepare</code>.</p>
<blockquote>
<p>💡 Hint: If your plan does nothing when preparing mutators, there is an optimization you can do.
You may set the plan constraints field <code>PlanConstraints::needs_prepare_mutator</code> to <code>false</code> so that
the <code>PrepareMutator</code> work packets which call <code>prepare_func</code> will not be created in the first place.
This optimization is helpful for VMs that run with a large number of mutator threads.  If you do
this optimization, you may also leave the <code>MutatorConfig::prepare_func</code> field as
<code>&amp;unreachable_prepare_func</code> to indicate it should not be called.</p>
</blockquote>
<h2 id="release"><a class="header" href="#release">Release</a></h2>
<p>Finally, we need to fill out the functions that are, roughly speaking,
run after each collection.</p>
<h3 id="release-in-plan"><a class="header" href="#release-in-plan">Release in plan</a></h3>
<p>Find the method <code>release()</code> in <code>mygc/global.rs</code>. Replace the
<code>unreachable!()</code> call with the following code.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn release(&amp;mut self, tls: VMWorkerThread) {
        self.common.release(tls, true);
        self.fromspace().release();
    }
<span class="boring">}</span></code></pre></pre>
<p>This function is called at the end of a collection. It calls the release
routines for the common plan spaces and the fromspace.</p>
<h3 id="release-in-mutator"><a class="header" href="#release-in-mutator">Release in mutator</a></h3>
<p>Go back to <code>mutator.rs</code>.  Create a new function called <code>mygc_mutator_release()</code> that takes the same
inputs as the <code>mygc_mutator_prepare()</code> function above.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn mygc_mutator_release&lt;VM: VMBinding&gt;(
    mutator: &amp;mut Mutator&lt;VM&gt;,
    _tls: VMWorkerThread,
) {
    // rebind the allocation bump pointer to the appropriate semispace
    let bump_allocator = unsafe {
        mutator
            .allocators
            .get_allocator_mut(mutator.config.allocator_mapping[AllocationSemantics::Default])
    }
    .downcast_mut::&lt;BumpAllocator&lt;VM&gt;&gt;()
    .unwrap();
    bump_allocator.rebind(
        mutator
            .plan
            .downcast_ref::&lt;MyGC&lt;VM&gt;&gt;()
            .unwrap()
            .tospace(),
    );
}
<span class="boring">}</span></code></pre></pre>
<p>Then go to <code>create_mygc_mutator()</code>, replace <code>&amp;unreachable_release_func</code> in the <code>release_func</code> field
with <code>&amp;mygc_mutator_release</code>.  This function will be called at the release stage of a collection
(at the end of a collection) for each mutator.  It rebinds the allocator for the <code>Default</code>
allocation semantics to the new tospace. When the mutator threads resume, any new allocations for
<code>Default</code> will then go to the new tospace.</p>
<h2 id="processedgeswork-for-mygc"><a class="header" href="#processedgeswork-for-mygc">ProcessEdgesWork for MyGC</a></h2>
<p><a href="https://docs.mmtk.io/api/mmtk/scheduler/gc_work/trait.ProcessEdgesWork.html"><code>ProcessEdgesWork</code></a>
is the key work packet for tracing objects in a GC. A <code>ProcessEdgesWork</code> implementation
defines how to trace objects, and how to generate more work packets based on the current tracing
to finish the object closure.</p>
<p><code>GCWorkContext</code> specifies a type
that implements <code>ProcessEdgesWork</code>, and we used <code>SFTProcessEdges</code> earlier. In
this section, we discuss what <code>SFTProcessEdges</code> does, and what the alternatives
are.</p>
<h3 id="approach-1-use-sftprocessedges"><a class="header" href="#approach-1-use-sftprocessedges">Approach 1: Use <code>SFTProcessEdges</code></a></h3>
<p><a href="https://docs.mmtk.io/api/mmtk/scheduler/gc_work/struct.SFTProcessEdges.html"><code>SFTProcessEdges</code></a> dispatches
the tracing of objects to their respective spaces through <a href="https://docs.mmtk.io/api/mmtk/policy/sft/trait.SFT.html">Space Function Table (SFT)</a>.
As long as all the policies in a plan provide an implementation of <code>sft_trace_object()</code> in their SFT implementations,
the plan can use <code>SFTProcessEdges</code>. Currently most policies provide an implementation for <code>sft_trace_object()</code>, except
mark compact and immix. Those two policies use multiple GC traces, and due to the limitation of SFT, SFT does not allow
multiple <code>sft_trace_object()</code> for a policy.</p>
<p><code>SFTProcessEdges</code> is the simplest approach when all the policies support it. Fortunately, we can use it for our GC, semispace.</p>
<h3 id="approach-2-derive-plantraceobject-and-use-planprocessedges"><a class="header" href="#approach-2-derive-plantraceobject-and-use-planprocessedges">Approach 2: Derive <code>PlanTraceObject</code> and use <code>PlanProcessEdges</code></a></h3>
<p><code>PlanProcessEdges</code> is another general <code>ProcessEdgesWork</code> implementation that can be used by most plans. When a plan
implements the <a href="https://docs.mmtk.io/api/mmtk/plan/global/trait.PlanTraceObject.html"><code>PlanTraceObject</code></a>,
it can use <code>PlanProcessEdges</code>.</p>
<p>You can manually provide an implementation of <code>PlanTraceObject</code> for <code>MyGC</code>. But you can also use the derive macro MMTK provides,
and the macro will generate an implementation of <code>PlanTraceObject</code>:</p>
<ul>
<li>Make sure <code>MyGC</code> already has the <code>#[derive(HasSpaces)]</code> attribute because all plans need to
implement the <code>HasSpaces</code> trait anyway.  (import the macro properly: <code>use mmtk_macros::HasSpaces</code>)</li>
<li>Add <code>#[derive(PlanTraceObject)]</code> for <code>MyGC</code> (import the macro properly: <code>use mmtk_macros::PlanTraceObject</code>)</li>
<li>Add both <code>#[space]</code> and <code>#[copy_semantics(CopySemantics::Default)]</code> to both copy space fields,
<code>copyspace0</code> and <code>copyspace1</code>. <code>#[space]</code> tells the macro that both <code>copyspace0</code> and <code>copyspace1</code>
are spaces in the <code>MyGC</code> plan, and the generated trace code will check both spaces.
<code>#[copy_semantics(CopySemantics::DefaultCopy)]</code> specifies the copy semantics to use when tracing
objects in the corresponding space.</li>
<li>Add <code>#[parent]</code> to <code>common</code>. This tells the macro that there are more spaces defined in <code>common</code>
and its nested structs.  If an object is not found in any space with <code>#[space]</code> in this plan,
the trace code will try to find the space for the object in the 'parent' plan.  In our case, the
trace code will proceed by checking spaces in the <code>CommonPlan</code>, as the object may be
in large object space or immortal space in the common plan. <code>CommonPlan</code> also implements <code>PlanTraceObject</code>, so it knows how to
find a space for the object and trace it in the same way.</li>
</ul>
<p>With the derive macro, your <code>MyGC</code> struct should look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(HasSpaces, PlanTraceObject)]
pub struct MyGC&lt;VM: VMBinding&gt; {
    pub hi: AtomicBool,
    #[space]
    #[copy_semantics(CopySemantics::DefaultCopy)]
    pub copyspace0: CopySpace&lt;VM&gt;,
    #[space]
    #[copy_semantics(CopySemantics::DefaultCopy)]
    pub copyspace1: CopySpace&lt;VM&gt;,
    #[parent]
    pub common: CommonPlan&lt;VM&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Once this is done, you can specify <code>PlanProcessEdges</code> as the <code>DefaultProcessEdges</code> in your GC work context:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::policy::gc_work::DEFAULT_TRACE;
use crate::scheduler::gc_work::PlanProcessEdges;
pub struct MyGCWorkContext2&lt;VM: VMBinding&gt;(std::marker::PhantomData&lt;VM&gt;);
impl&lt;VM: VMBinding&gt; crate::scheduler::GCWorkContext for MyGCWorkContext2&lt;VM&gt; {
    type VM = VM;
    type PlanType = MyGC&lt;VM&gt;;
    type DefaultProcessEdges = PlanProcessEdges&lt;Self::VM, MyGC&lt;VM&gt;, DEFAULT_TRACE&gt;;
    type PinningProcessEdges = UnsupportedProcessEdges&lt;Self::VM&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-3-implement-your-own-processedgeswork"><a class="header" href="#approach-3-implement-your-own-processedgeswork">Approach 3: Implement your own <code>ProcessEdgesWork</code></a></h3>
<p>Apart from the two approaches above, you can always implement your own <code>ProcessEdgesWork</code>. This is
an overkill for simple plans like semi space, but might be necessary for more complex plans.
We discuss how to implement it for <code>MyGC</code>.</p>
<p>Create a struct <code>MyGCProcessEdges&lt;VM: VMBinding&gt;</code> in the <code>gc_work</code> module. It includes a reference
back to the plan, and a <code>ProcessEdgesBase</code> field:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCProcessEdges&lt;VM: VMBinding&gt; {
    plan: &amp;'static MyGC&lt;VM&gt;,
    base: ProcessEdgesBase&lt;VM&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Implement <code>ProcessEdgesWork</code> for <code>MyGCProcessEdges</code>. As most methods in the trait have a default
implemetation, we only need to implement <code>new()</code> and <code>trace_object()</code> for our plan. However, this
may not be true when you implement it for other GC plans. It would be better to check the default
implementation of <code>ProcessEdgesWork</code>.</p>
<p>For <code>trace_object()</code>, what we do is similar to the approach above (except that we need to write the code
ourselves rather than letting the macro to generate it for us). We try to figure out
which space the object is in, and invoke <code>trace_object()</code> for the object on that space. If the
object is not in any of the semi spaces in the plan, we forward the call to <code>CommonPlan</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM: VMBinding&gt; ProcessEdgesWork for MyGCProcessEdges&lt;VM&gt; {
    type VM = VM;
    type ScanObjectsWorkType = ScanObjects&lt;Self&gt;;

    fn new(
        slots: Vec&lt;SlotOf&lt;Self&gt;&gt;,
        roots: bool,
        mmtk: &amp;'static MMTK&lt;VM&gt;,
        bucket: WorkBucketStage,
    ) -&gt; Self {
        let base = ProcessEdgesBase::new(slots, roots, mmtk, bucket);
        let plan = base.plan().downcast_ref::&lt;MyGC&lt;VM&gt;&gt;().unwrap();
        Self { base, plan }
    }

    fn trace_object(&amp;mut self, object: ObjectReference) -&gt; ObjectReference {
        let worker = self.worker();
        let queue = &amp;mut self.base.nodes;
        if self.plan.tospace().in_space(object) {
            self.plan.tospace().trace_object(
                queue,
                object,
                Some(CopySemantics::DefaultCopy),
                worker,
            )
        } else if self.plan.fromspace().in_space(object) {
            self.plan.fromspace().trace_object(
                queue,
                object,
                Some(CopySemantics::DefaultCopy),
                worker,
            )
        } else {
            self.plan.common.trace_object(queue, object, worker)
        }
    }

    fn create_scan_work(&amp;self, nodes: Vec&lt;ObjectReference&gt;) -&gt; ScanObjects&lt;Self&gt; {
        ScanObjects::&lt;Self&gt;::new(nodes, false, self.bucket)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We would also need to implement <code>Deref</code> and <code>DerefMut</code> to our <code>ProcessEdgesWork</code> impl to be
dereferenced as <code>ProcessEdgesBase</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM: VMBinding&gt; Deref for MyGCProcessEdges&lt;VM&gt; {
    type Target = ProcessEdgesBase&lt;VM&gt;;
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.base
    }
}

impl&lt;VM: VMBinding&gt; DerefMut for MyGCProcessEdges&lt;VM&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.base
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the end, use <code>MyGCProcessEdges</code> as <code>DefaultProcessEdges</code> in the <code>GCWorkContext</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCWorkContext3&lt;VM: VMBinding&gt;(std::marker::PhantomData&lt;VM&gt;);
impl&lt;VM: VMBinding&gt; crate::scheduler::GCWorkContext for MyGCWorkContext3&lt;VM&gt; {
    type VM = VM;
    type PlanType = MyGC&lt;VM&gt;;
    type DefaultProcessEdges = MyGCProcessEdges&lt;Self::VM&gt;;
    type PinningProcessEdges = UnsupportedProcessEdges&lt;Self::VM&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>You should now have MyGC working and able to collect garbage. All three
benchmarks should be able to pass now.</p>
<p>If the benchmarks pass - good job! You have built a functional copying
collector!</p>
<p>If you get particularly stuck, the code for the completed <code>MyGC</code> plan
is available <a href="https://github.com/mmtk/mmtk-core/tree/master/docs/userguide/src/tutorial/code/mygc_semispace">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../tutorial/mygc/ss/alloc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../tutorial/mygc/ss/exercise.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../tutorial/mygc/ss/alloc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../tutorial/mygc/ss/exercise.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../assets/js/api-migration-details.js"></script>


    </div>
    </body>
</html>
